{"meta":{"title":"TG'S BLOG","subtitle":null,"description":null,"author":"cdtaogang","url":"https://hellotaogang.github.io","root":"/"},"pages":[{"title":"","date":"2019-10-14T05:23:33.279Z","updated":"2019-10-14T05:23:33.279Z","comments":true,"path":"archives/index.html","permalink":"https://hellotaogang.github.io/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-10-13T13:04:34.003Z","updated":"2019-10-13T13:04:34.003Z","comments":true,"path":"categories/index.html","permalink":"https://hellotaogang.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-10-13T13:02:11.746Z","updated":"2019-10-13T13:02:11.746Z","comments":true,"path":"tags/index.html","permalink":"https://hellotaogang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flask项目之手机端租房网站的实战开发（六）","slug":"Flask项目之手机端租房网站的实战开发（六）","date":"2019-11-03T10:50:08.631Z","updated":"2019-11-03T11:27:24.362Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（六）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（六）/","excerpt":"","text":"一丶补充1.之前写的获取的图片验证码，有一个地方需要做进一步的处理，需要删除redis数据库中的图片验证码，防止用户使用同一个图片验证码验证多次，所以将删除代码放在取出redis数据库中图片验证码的值之后，也就是在real_image_code变量之后进行删除，这样即使删除了redis数据中的数据，也不会影响接下来的判断校验，这样做的目的就是说不管用户填对填错，只有一次验证机会 2.测试以上逻辑是否正确 step1 重新运行程序，刷新http://127.0.0.1:5000/register.html 注册页面 step2 查看redis数据库图片验证码的值 step3 在Postman工具中发送短信验证码路由地址 此时绑定的手机号码上就会收到我们定义的6位数验证码 step4 查看redis数据库(这个时候并没有超过180秒)，发现图片验证码的key已经被删除 3.短信验证码这一块，大多网站都会在用户发送第一次验证码后，在前端页面会出现60s后再试之类的提醒，那么对于后端来说，也是需要的，比如被人知道了后我端口的接口，1分钟之类不断的发送短信，那可就不好了，所以为了做到优化以及安全防范，那么就需要在后端进行一个禁止60s内发送第二次短信的一个逻辑，不仅仅限于前端 step1 逻辑分析，首先当发送第一次短信时，需要记住发送短信记录，当时间超过60s以上，才可以发送第二条短信，此时就需要想想是在什么时候将这个发送短信的记录存到redis数据库，大多公司是这样做的，不管发送成功与否，都是需要等待60s后才能发送第二次，所以我们这里也是这样做的，在发送短信之前就将记录存到redis数据库当中去 step2 当在保存短信验证码的时候，将这个第一次发送短信的记录存到redis数据库中，让redis数据库去维护记录的有效期60s，这个记录的数据随便起，这里设置1，那么当在redis数据库查询不到这个记录时，代表可以记录过了有效期被删除了，则代表可以发送第二条短信验证码了 1redis_store.setex(\"send_sms_code_%s\" % mobile, constants.SEND_SMS_CODE_INTERVAL, 1) step3 然后在判断手机号是否注册之前进行校验判断，判断对于此手机号码在60s以内有没有之前发送短信的操作，如果有，则不代表用户操作频繁，不予处理（注：经测试如果在判断获取记录的值的时候代码为if send_flag == 1时，会出现bug，所以建议使用is not None即可） 4.测试以上逻辑是否正常 step1 启动项目程序 step2 刷新http://127.0.0.1:5000/register.html 注册页面，生成新的图片验证码，将验证码内容以及对应编码通过发送短信路由发送到对应接口进行测试 step3 此时从redis数据库中查看图片验证码的id以及值 step4 在Postman工具中，对短信接口地址进行访问，并携带image_code以及image_code_id 同时收到手机短信验证码 step5 最关键的一步，与此同时，刷新图片验证码，获取新的图片验证码，然后在redis数据查询id以及图片验证码的值后在Postman中进行再次发送（注：这里的演示是在60s之内发送第二次请求给后端短信接口），出现如下提示，代表逻辑正确 二丶短信验证码前端编写1.在register.js中构造请求数据 1234var req_data = &#123; \"image_code\": imageCode, //用户输入图片验证码的值 \"image_code_id\": imageCodeId //对应图片验证码的编号 &#125;; 2.通过ajax方式想后端去发送请求 123456789101112131415161718192021222324// 想后端发送请求$.get(\"/api/v1.0/sms_codes/\"+mobile, req_data, function (resp) &#123; // 回调函数中的resp是后端返回的json字符串，通过ajax将这个字符串转换成js对象 // 所以这里的resp为ajax转换后的对象 if (resp.error == \"0\") &#123; // 表示发送成功 var num = 60; var timer = setInterval(function () &#123; if (num&gt;1) &#123; // 修改倒计时的文本内容 $(\".phonecode-a\").html(num + \"s\"); num -= 1 &#125; else &#123; $(\".phonecode-a\").html(\"获取验证码\"); $(\".phonecode-a\").attr(\"onclick\", \"sendSMSCode();\"); clearInterval(timer) &#125; &#125;, 1000, 60) &#125; else &#123; alert(resp.errmsg); $(\".phonecode-a\").attr(\"onclick\", \"sendSMSCode();\"); &#125; &#125;); 3.测试 step1 启动程序 step2 访问http://127.0.0.1:5000/register.html 注册界面 step3 输入手机号，图片验证码后点击获取短信验证码，成功出现倒计时，同时手机收到短信验证码 手机验证码 step4 在谷歌浏览器中查看接口地址的NetWork General数据 Response响应数据 三丶注册后端接口编写1.在项目api_1_0目录下创建passport.py文件用作于注册以及登录的逻辑接口文件 2.构建register视图函数，并在ihome/init文件中导入passport模块 123@api.route(\"/users\", methods=[\"POST\"])def register(): pass 3.逻辑编写 step1 获取前端请求发送请求中的json数据 12345req_dict = request.get_json()mobile = req_dict.get(\"mobile\") #跟前端约定好的sms_code = req_dict.get(\"sms_code\")password = req_dict.get(\"password\")password2 = req_dict.get(\"password2\") step2 校验参数 12if not all([mobile, sms_code, password, password2]): return jsonify(errno=RET.PARAMERR, errmsg=\"请求参数不完整\") step3 判断用户输入的手机号码格式 step4 从redis数据库中取出短信验证码 12345try: real_sms_code = redis_store.get(\"sms_code_%s\" % mobile)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"读取真实短信验证码异常\") step5 判断短信验证码是否过期 12if real_sms_code is None: return jsonify(errno=RET.NODATA, errmsg=\"短信验证码失效\") step6 判断用户输入的短信验证码是否正确 12if real_sms_code != sms_code: return jsonify(errno=RET.DATAERR, errmsg=\"短信验证码填写错误\") step7 同图片验证码一样，在redis数据库中进行删除，防止一个短信验证码多次使用 1234try: redis_store.delete(\"sms_code_%s\" % mobile)except Exception as e: current_app.logger.error(e) step8 判断用户的手机号是否注册过 step9 将用户注册的数据保存到mysql数据库中，这时候为了减少数据库的查询，不增加程序运行的负荷，所以我们在判断用户手机号是否注册过的时候，不再进行查询，而是在保存用户注册数据时候，判断手机号码是否存在，因之前在models中创建数据库表时，将mobile字段的数据设置为唯一约束，所以当数据库ih_user_profile表中已存在mobile字段的数据时，再进行插入相同手机号mobile的数据时，mysql数据库则会抛出异常，那么我们就利用数据库抛出的异常来判断手机号码是否存在，从而减少在视图函数中数据库的查询 数据库测试mobile字段异常 step10 注释step8代码重新编写，大体如下，因密码需要进行加密后再存到数据库，所以到最后面再进行处理 说明：这里的注册名为手机号，后面会另写接口让name为名字昵称，当出现异常时候，需要进行数据库回滚操作 step11 将登陆状态保存到session中，并返回注册成功结果 12345session[\"name\"] = mobilesession[\"mobile\"] = mobilesession[\"user_id\"] = user.id return jsonify(errno=RET.OK, errmsg=\"注册成功\") step12 将用户输入的密码进行加密 说明：将对用户输入的密码添加salt值(盐值)，再进行加密存储，说白了就是，在户输入的密码基础上再添加一个随机生成的字符串，即使用户1和用户2密码一样，但在进行salt处理后，在数据库中也不会相同，不存在撞库说法，这样做安全性极高，即使密码泄露，破解出来后也并不是用户的真是密码 问题：反过来当用户注册成功后，进行用户登录时，那么这个密码是如何进行判断？是将用户输入的密码进行加密后再和数据库加密密码进行对比，可是当初在注册时对用户输入的密码进行加密时候添加了随机的salt值，所以这里需要注意思考一下，我们这里的想法是通过在注册时候将salt值进行保存在数据库中另起一个字段，这是其一方法，其二是将这个salt值与加密后的密码中间以某个分隔符进行分隔，这样做的话就不用再创建表字段另存salt值，如qwe@ohcuncacaucaooa08c03qoca08q08，@符前为salt值，后为用户加密后的密码 注：MD5已被攻破，利用暴力测试以及算法公式成功反推出加密前的密码，sh1估计等不了几年就会被破解，我们这里使用的是sha256进行密码的加密 ①在models文件中通过导入werkzeug.security类中的generate_password_hash方法将密码进行加密，并存到数据库中 12def generate_password_hash(self, origin_password): self.password_hash = generate_password_hash(origin_password) ②在passport文件中，在构建User对象的时候，通过调用models文件中的generate_password_hash方法，将前端用户输入的password传参给此方法，并保存到User模型类的passwor_hash字段中 1user.generate_password_hash(password) 4.property装饰器的使用 step1 将函数调用转换为对象属性设置（在passport文件中） 1user.password = password step2 在models中注释之前的generate_password_hash方法的调用，使用property装饰器对新创建的password函数装饰为password属性(注，在passport文件中user.password对象的password属性名要与models文件中的方法同名)，再通过password属性的setter方法，设置类属性的值，这个值就是我们在passport文件中通过user.password = password这个password值 四丶注册后端测试 step1 因测试users注册后端接口使用的POST请求方式，而此时还没有编写注册前端端口测试，所以需要在ihome/init文件中将csrf后端机制关闭，再进行测试 12# 为flask补充csrf防护# CSRFProtect(app) step2 运行程序，在浏览器输入http://127.0.0.1:5000/register.html，进入注册页面 step3 在注册页面输入错误手机号，正确的图片验证码，当点击获取短信验证码时候，会提示发送短信失败，无所谓，我们从redis数据库直接读取sms_code即可 step4 在redis数据库中获取短信验证码(因为在上一步输入的是错误手机号，导致无法发送短信，测试无所谓嘛) step5 在测试工具Postman中，添加127.0.0.1:5000/api/v1.0/users地址，构造json格式的body体数据，就是我们注册页面所需要的数据，成功返回注册成功响应数据，代表注册后端接口没问题 step6 响应数据表示注册成功后，查看数据库ih_user_profile表信息，第一条数据是之前测试使用的 五丶注册前端编写1.前端注册HTML代码（不展示） 2.前端注册JS代码（不展示） 3.在register.js文件中通过ajax方式向后端接口发送注册请求（在callback for submit()） 1234567891011121314151617181920212223242526272829// 调用ajax向后端发送注册请求 var req_data = &#123; mobile:mobile, sms_code:phoneCode, password:passwd, password2:passwd2 &#125;; var req_json = JSON.stringify(req_data) $.ajax(&#123; url:\"/api/v1.0/users\", type:\"post\", data:req_json, contentType:\"application/json\", dataType: \"json\", headers:&#123; \"X-CSRFToken\":getCookie(\"csrf_token\") &#125;, success: function (resp) &#123; if (resp.errno== \"0\")&#123; // 注册成功，即跳转到主页 location.href = \"/index.html\"; &#125;else &#123; alert(resp.errmsg); &#125; &#125; &#125;) 4.在js构建一个getCookie的方法来获取前端名为csrf_token的cookie的值 1234function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125; 5.将获取的cookie的值，放在请求头中的X-CSRFToken键中，方便后端进行csrf验证（需将ihome/init中的CSRF验证开启） 123headers:&#123; \"X-CSRFToken\":getCookie(\"csrf_token\") &#125;, 六丶用户注册功能测试1.进行注册测试，输入不存在的号码是为了演示给大家，虽然提示发送短信验证码失败，但我可以从redis数据库去拿取短信验证码，注册成功后，即跳转到登录页面 2.用户注册成功后，查看数据库中ih_user_profile表的内容，成功将用户注册信息保存到数据库 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85934776","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（五）","slug":"Flask项目之手机端租房网站的实战开发（五）","date":"2019-11-03T09:54:24.218Z","updated":"2019-11-03T10:34:13.977Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（五）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（五）/","excerpt":"","text":"一丶图片验证码前端编写1.当用户进入到注册页后，页面进行刷新，所以在static前端静态资源register.js中定义一个generateImageCode函数，当页面加载完后，形成图片验证码的后端地址， 设置到页面中，让浏览请求验证码图片，同理在register.html中onclick点击验证码图片时，也要触发generateImageCode函数 register.html 1&lt;div class=\"input-group-addon image-code\" οnclick=\"generateImageCode();\"&gt;&lt;img src=\"\"&gt;&lt;/div&gt; register.js 12$(document).ready(function() &#123; generateImageCode();&#125; 2.生成图片验证码编号两种方式：第一种是时间轴；第二种是UUID全局唯一标识符，这里我们使用UUID step1 在js中获取UUID的值（这里在网上找的一个代码） 123456789101112function generateUUID() &#123; var d = new Date().getTime(); if(window.performance &amp;&amp; typeof window.performance.now === \"function\")&#123; d += performance.now(); //use high-precision timer if available &#125; var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) &#123; var r = (d + Math.random()*16)%16 | 0; d = Math.floor(d/16); return (c=='x' ? r : (r&amp;0x3|0x8)).toString(16); &#125;); return uuid;&#125; step2 在generateImageCode函数中调用generateUUID，将生成的UUID赋值给imageCodeId变量，记得先使用var在函数外声明该变量 1234function generateImageCode() &#123; // 生成图片验证码编号 imageCodeId = generateUUID();&#125; 3.拼接二维码图片的url地址，设置register.html中图片二维码div标签class=image_code下的img标签的src地址为拼接后的url，也就是二维码图片的链接地址 12var url = \"/api/v1.0/image_codes/\" + imageCodeId; $(\".image-code img\").attr(\"src\", url); 4.运行程序，清除浏览器缓存，输入http://127.0.0.1:5000/register.html后，查看注册页面二维码生成是否成功 5.在后端redis数据库中成功生成image_code_uuid的key了 6.效果图，鼠标连续点击图片验证码，请注意验证码 二丶短信验证码后端编写1.发送短信服务介绍，这里使用的是容联云，云通讯 step1 需要在官网https://www.yuntongxun.com/进行注册，注册时会通过打电话形式告诉你验证码，注册成功后会赠送8元测试费用，如下图 step2 然后选择测试平台，添加测试手机号，最多三个，验证成功才能添加上 step3 进入开发文档—Rest API—-短信—-短信发送接口，具体文档说明请到官网自寻查看 step4 我们直接去下载官方给开发人员封装好的工具SDK，找到Demo示例，然后在文章上方点击Demo下载，找到python语言对应的SDK进行下载即可 step5 解压后的目录文件如下，请查看README.txt等说明文件，DEMO问案列，这里我们只需要将SDK文件拷贝到项目中的libs目录下，并命名为yuntongxun，然后再将DEMO文件夹中的SendTemplateSMS.py文件拷贝到yuntongxun目录下 2.封装发送短信辅助工具 step1 在libs以及云通讯目录下创建init文件，使其变成python的包 step2 在SendTemplateSMS.py文件中创建一个CCP的类，用于封装发送短信的辅助类，目的是在我们调用sendTemplateSMS方法的时候，只初始化一次REST SDK，使用python单例达到不管创建多少个对象，都只初始化一次 step3 将云通讯开发者主账号中的ACCOUNT SID和AUTH TOKEN以及AppID，复制到代码中 step4 编写测试脚本，内容分为验证码9527，有效期5分钟，使用测试模板1 step5 运行sendTemplateSMS程序，最下面的statusCode为000000，代表短信发送成功，在官网短信接口有详细说明 step6 此时手机便收到了短信 step7 修改代码，不需要使用官方的代码将result字典数据进行遍历打印，而是只获取状态statusCode进行判断，如果为000000代表发送成功返回0，否则发送失败返回-1 查看运行结果，验证逻辑没有问题 step8 将sendTemplateSMS重命名为sendSMS，为了后面使用方便 3.定义获取短信接口 step1 在接口文件verify_code中定义一个get_sms_code的视图函数 1def get_sms_code() step2 构建路由规则，同理与构建图片验证码一样，使用restful风格，并且需要有一个短信验证码的编码，以手机进行编号，之前在分析图片验证码时，已经说过发送短信验证码时需携带图片验证码的文本内容以及图片验证码的编号，所以路由如下 1# GET /api/v1.0/sms_codes/&lt;mobile&gt;?image_code=xxxx&amp;image_code_id=xxxx step3 获取image_code以及image_code_id 12image_code = request.args.get(\"image_code\")image_code_id = request.args.get(\"image_code_id\") step4 校验参数 1234# 校验参数if not all([image_code, image_code_id]): # 参数不完整返回对应错误 return jsonify(errno=RET.PARAMERR, errmsg=\"参数不完整\") step5 业务逻辑处理，从redis数据库取出验证码与用户输入的验证码进行校验，期间需要对验证码是否存在进行判断 step6 接下来判断手机号是否存在 step7 随机生成6位数验证码（使用字符串格式化的方式来生成，从0到999999，当不足6位时，以0做填充） 1sms_code = \"%06d\" % random.randint(0, 999999) step8 在redis数据库中保存真实的短信验证码 step9 发送短信 step10 异常说明 放在try与except中的代码越少越好，会影响程序执行效率 三丶测试向后端接口发送短信验证码 step1 打开Postman测试工具，发送接口路由127.0.0.1:5000/api/v1.0/sms_codes/180xxxxxx96?image_code&amp;image_code_id step2 运行项目 step3 在浏览器输入http://127.0.0.1:5000/register.html，进入项目注册页面 step4 回到Postman工具，取消参数，什么都不传的情况下，出现如下错误信息，就是我们在程序中定义的错误信息 step5 此时刷新http://127.0.0.1:5000/register.html注册页，查看验证码，并在redis数据中获取验证码 获取redis数据库中图片验证码的文本值与注册页图片二维码的值一样 step6 当过了180s后也就是我们在constants.py中设置的图片验证码有效期，在Postman工具中发送地址，提示 我们定义的错误图片验证码失效，在程序中的逻辑为无法在redis数据库中获取image_code_id键的值，或者说不存在此键，返回结果为None step7 刷新注册页面，获取新的验证码，在Postman工具中向错误号码发送验证码，或者说是未在云通讯测试平台关联的号码发送验证码，则出现以下错误提示，这个提示就是我们在接口文件中写的res不等于0的时候，返回错误的json格式的错误信息 step8 刷新http://127.0.0.1:5000/register.html，将最新的验证码存储到redis数据库，在Postman工具中向正确地址发送正确号码，返回的响应数据为发送成功，如下图所示 注册页界面 redis数据库中的图片验证码值 Postman响应数据 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85858348","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（四）","slug":"Flask项目之手机端租房网站的实战开发（四）","date":"2019-11-03T09:26:31.303Z","updated":"2019-11-03T10:01:51.295Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（四）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（四）/","excerpt":"","text":"一丶在项目中添加静态资源文件1.将静态资源文件拷贝到项目static目录下 2.在终端上运行项目python manage.py runserver 3.在浏览器中输入http://127.0.0.1:5000/static/html/index.html 访问前端主页，如下图 4.当在不使用nginx服务器给用户提供静态资源，而是以flask来提供，当用户在浏览器中输入/static/html/index.html就会显得不友好，正常来说访问主页只需要输入ip地址或者是域名加端口号就可以了，那么就需要我们专门写个视图函数来提供有好的链接地址，把地址前缀给去掉 5.创建一个蓝图，专门负责提供静态文件的 step1 在ihome目录下创建一个web_html.py文件 step2 创建蓝图html 1html = Blueprint(\"web_html\", __name__) step3 在utils目录下创建一个init.py文件，使这个目录变成python的包，然后在这个utils包中创建commons.py文件，作为通用工具，在里面定义一个正则转换器 step4 在ihome/init文件中，在创建app对象时候，将ReConverter对象添加到app中 step5 回到commons.py文件中，定义视图函数get_html step6 在ihome/init中进入此蓝图注册 step7 启动项目 1python manage.py runserver step8 清除网页缓存数据 step9 在浏览器地址栏输入http://127.0.0.1:5000/就直接跳转到主页了index.html了 step10 输入http://127.0.0.1:5000/register.html也是没有问题的，直接跳转到register.html 二丶关于csrf防护机制1.csrf验证机制：从cookie中获取一个csrf_token的值，再从请求体中获取一个csrf_token的值，如果这两个值相同，则检验通过，可以进入视图函数中执行，如果两个值不同，则检验失败，会想前端返回状态码404的错，之前在ihome/init中设置的csrf只是负责验证，并不负责cookie与请求体中的csrf_token的值从哪里来 12# 为flask补充csrf防护CSRFProtect(app) 2.分析：前后端不分离时跟django一样直接在模板中进行设置csrf，而我们这个项目使用的是前后端分离，没有模板，对于cookie我们可以提前进行设置csrf_token，然后对于请求体中的cookie而言，当 发送POST请求时，就将那时候的请求体数据中设置csrf_token这样就能csrf防护了 3.设置cookie中的csrf_token step1 为web_html.py中导入csrf包 1from flask_wtf import csrf step2 创建一个csrf_token的值 1csrf_token = csrf.generate_csrf() step3 导入make_response，将返回的静态文件方法的值构建成响应对象 1resp = make_response(current_app.send_static_file(html_file_name)) step4 设置cookie的值，有效期为临时会话 1resp.set_cookie(\"csrf_token\", csrf_token) step5 重新启动程序，刷新网页，查看我们设置的cookie 三丶用户注册模块（图片验证码以及短信验证码）1.图片验证码使用流程 step1 分析流程： 第一步，需要前端像后端发起一个获取图片验证码的请求，对于后端来说就需要去生成一个随机的验证码图片；第二步将生成的验证码图片返回给前端；第三步验证图片验证码的准确性，如果正确，才能发起获取短信验证码的请求 step2 具体细节 在发起获取短信验证码请求的时候将携带填写的图片验证码与后端生成的图片验证码进行校验，因此后端在生成图片验证码的时候，需要将图片进行保存，意义是为了与用户输入的图片验证码进行对比，对比成功，才会给用户返回短信验证码 step3 问题分析 后端生成的图片验证码是存在哪里，谁来维护有效期，不可能一张图片一直用下去，所以将在后端生成的图片验证码，存到redis数据库中，在后端进行验证的时候，就从redis中取出这个值，与前端用户输入的值进行对比即可；但是对于多个用户来说同一时间向我发送获取图片验证码时，该怎么去判断谁是谁的，所以要将图片验证码进行编号处理，来分辨是属于哪个用户的图片验证码，那么就需要在用户发起短信验证码请求的携带参数里面除了填写的图片验证码，还需要携带一个用户编号，因此对于后端服务器来说，除了生成图片验证码的值，还需要生成一个对应验证码的编码，一起保存到redis数据库中，还需要将验证码值和编码返回给前端用户，那么就需要从返回的响应体中取解析编码，这样做太麻烦了，为了减轻后端的压力，将不再由后端去生成这个编码了，而是由前端在一开始就去生成这个编号，再前端向后端服务器发起获取图片验证码请求的时候携带一个编码参数，然后后端将编码和图片验证码的值一起存到redis数据库中 step4 在ihome/api_1_0目录下创建一个verify_code.py文件，将图片验证码以及短信验证码放在这个文件里面进行使用 step5 使用restful风格构建前端向后端发起图片验证码请求地址 1GET http://127.0.0.1:5000/api/v1.0/image_codes/&lt;image_code_id&gt; 2.图片验证码后端接口编写 step1 将图片验证码工具包captcha拷贝到ihome/utils目录下 step2 在verify.py中导入captcha包中的captcha模块中的captcha对象 1from ihome.utils.captcha.captcha import captcha step3 通过调用captcha对象中的generate_captcha方法来获取生成的验证码名字，文本内容，以及图片二进制数据 1name, text, image_data = captcha.generate_captcha() step4 选择存储数据类型，将验证码的文本内容以及编码存到redis数据库中，并设置有效期 可以使用哈希格式进行存储，但是无法设置单个图片的有效期 示例： 1\"image_codes\": &#123;\"id1\":\"abc\", \"\":\"\"&#125; 哈希 hset(\"image_codes\", \"id1\", \"abc\") hget(\"image_codes\", \"id1\") 使用字符串格式对数据进行存储，以编码作为key，以文本内容作为value值进行存储即可 示例： 1234\"image_code_编号1\": \"真实值\"\"image_code_编号2\": \"真实值\"redis_store.set(\"image_code_%s\" % image_code_id, text)redis_store.expire(\"image_code_%s\" % image_code_id, constants.IMAGE_CODE_REDIS_EXPIRES) step5 在verify.py中导入redis数据库连接对象，然后将编码和文本内容存到redis数据库 123from ihome import redis_store redis_store.set(\"image_code_%s\" %image_code_id, text) step6 设置图片验证码有效期为三分钟，首先在ihome目录下创建一个constants.py文件，用于存放常量 1redis_store.expire(\"image_code_%s\" %image_code_id, constants.IMAGE_CODE_REDIS_EXPIRES) 设置值和有效期一步到位 1redis_store.setex(\"image_code_%s\" %image_code_id, constants.IMAGE_CODE_REDIS_EXPIRES, text) step7 对于数据库连接，可能会出现连接错误以及连接不上等问题，所以需要捕获异常，并且将捕获到的异常保存到日志中 1current_app.logger.error(e) step8 当出现异常后，需要返回错误信息的json数据，先将工程项目定义好的response_code.py响应状态码文件，拷贝到utils中 1return jsonify(errno=RET.DBERR, errmsg=\"save image code failed\") step9 没有出现异常，则先通过make_response构造图片image_data数据响应体对象，再设置该响应体对象的请求头中的Content-Type为图片格式jpg，返回给前端 3.开发流程与编写接口文档 step1 开发流程 分析需求 编写代码 编写单元测试 自测 编写接口文档 提测代码 step2 编写接口文档 123456789101112131415161718192021222324252627282930313233接口文档 1. 接口名字2. 描述（描述清楚接口的功能）3. url4. 请求方式5. 传入参数6. 返回值 接口：获取图片验证码 描述：前端访问，可以获取到验证码图片 url： /api/v1.0/image_codes/&lt;image_code_id&gt; 请求方式： GET 传入参数： 格式：路径参数 （参数是查询字符串、请求体的表单、json、xml） 名字 类型 是否必须 说明 image_code_id 字符串 是 验证码图片的编号 返回值： 格式： 正常：图片， 异常：json 名字 类型 是否必传 说明 errno 字符串 否 错误代码 errmsg 字符串 否 错误内容 实例： &apos;&#123;&quot;errno&quot;: &quot;4001&quot;, &quot;errmsg&quot;: &quot;保存图片验证码失败&quot;&#125;&apos; 四丶测试后端verify_code接口是否正确1.需要在api_1_0/init中导入我们写的接口文件verify_code让蓝图知道有一个verify_code的模块 1from . import verify_code 2.运行程序 1python manage.py runserver 3.在浏览器中输入http://127.0.0.1:5000/api/v1.0/image_codes/123，成功显示出验证码图片 4.查看程序运行日志 5.此时查看redis数据库中，会发现出现了一个image_code_123的键，获取该键的值就是图片验证码的文本值，说明我们写的后端接口没问题 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85706012","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（三）","slug":"Flask项目之手机端租房网站的实战开发（三）","date":"2019-11-03T06:29:09.631Z","updated":"2019-11-03T07:02:07.574Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（三）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（三）/","excerpt":"","text":"一丶关于在项目中循环导入的问题1.在上一篇中创建api_1_0蓝图下的demo.py视图函数文件中，肯定会用到导入数据库db的，那么就会出现flask项目循环导包的问题，当启动项目时，会提示cannot import name db，这个提示就是代表循环导入包的问题 2.针对flask项目出现此问题的解决方法 step1 分析导包流程，首先在manage.py启动文件中，程序从上往下执行，一开始就从ihome包下导入数据库连接对象db，然后进入到ihome\\init.py文件中，同理执行到从ihome导入蓝图目录api_1_0时，即进入api_1_0\\init.py文件中，执行到导入相对路径下demo文件时，回到demo.py文件中，在该文件中从ihome包下导入db时，就会发现此时在ihome\\init.py文件中，并还没有执行到创建数据库db对象，所以程序执行到这一步时，就会提示以上错误 step2 解决方法，选择推迟导入，修改代码在什么时候需导入api_1_0时，我们就在什么后导入即可，发现在create_app方法中在注册蓝图的时候才需要导入api_1_0，所以将导入代码，放到此处即可 123# 注册蓝图from ihome import api_1_0app.register_blueprint(api_1_0.api, url_prefix=\"/api/v1.0\") step3 再次启动项目，就不会提示cannot import name db 了，成功解决flask项目中循环导入包的问题 3.一个完整的项目工程还需要在核心目录下创建项目所需的目录，用来分别存放包和库的，所以需在ihome目录下创建utils目录用来存放项目所需的工具包以及工具函数等，然后再创建一个libs目录用来存放第三方的库，不是通过pip install 安装的库，而是源码安装的库，这样才是完整的实战工程项目 二丶日志功能实现1.一个正常的网站包括软件等，都会有日志来记录历史操作信息等，在公司中一般会将存放日志目录与工程目录隔离开，这里为了方便演示，即将日志目录和工程目录放到一起，在项目根目录创建logs目录，用来存放日志文件 2.因为flask框架没有去提供日志这一块的库以及工具，所以我们就是用python记录日志标准库logging来进行日志记录保存 step1 在ihome/init文件中导入logging库 1import logging step2 并配置日志信息以及设置日志等级 step3 配置后日志信息后，需要在api_1_0/demo视图函数中进行记录日志，有两种方法，第一种是直接在demo文件中使用logging标准库模块，第二种是使用flask 框架中的全局上下文current_app对象，为什么能使用current_app对象，因为这个对象把logging模块中的logger塞到了这个对象中了 step4 启动项目，在浏览器输入http://127.0.0.1:5000/api/v1.0/index测试日志是否成记录并写入到logs目录下的log文件中 成功在logs目录下创建log日志文件，并将日志信息写入到该文件中 注： 在开发环境develop中配置了DEBUG=True调试模式下，会导致我们配置的日志等级，不生效，flask会强制忽略到我们配置的日志信息 三丶项目数据库设计1.分析项目所需要的表 step1 用户表User，先从注册界面来说，需要哪些字段(user_id，作为主键，手机号mobile，用户名name，密码password，存放头像的路径avatar_url，用户真实姓名real_name，真实身份证号real_id_card，验证码图片存到redis数据库即可) step2 房子表House，字段(house_id，作为主键，user_id，与用户表主键id保持一致，作为外键关联哪个用户的房子，一个用户有多套房子一对多关系，房子标题title，房子所在区域area_name，通过创建的Area表所以这里将area_name改为area_id通过外键来查询即可)思考：当查询房屋表中某个区域的数据时，select distinct area_name from house并去重，当数据很少的时候可以这样进行查询，随着时间推移导致数据达到几千万时，那么通过这样的方式查询数据，时间就会很长，不利于用户体验，所以这里需再创建一个区域表Area来解决查询时间过长的问题 step3 区域表Area，字段(area_id，作为主键，name区域名，price价格，image_url1,image_url2…)，Area表对于House表也是一对多关系，一个区域多个房子思考：在第四步我们将图片链接地址存到Area表中，那么今后如果用户上传图片扩大为10张，那么就需要改表结构，这样不是明智的选择，所以另建一个House_Image表来存储用户上传的房屋图片 step4 房屋图片表House_Image，字段(image_id，作为主键，url图片地址，house_id外键)，房子House表对于图片地址House_Image表一对多关系，一个房子有多张图片思考：分析需求，发现只有房屋详情时才会查询多张图片，而在查询列表和主页图片时，只需要一张，那么我们在房子表House中需添加一个index_image_url字段，这样做的目的是减少关联查询，在数据库中以空间换时间的理念来减少查询时间 step5 房屋配套设施表Facility，字段(facility_id，作为主键，name设施名字)思考：设施表Facility与房屋表House是多对多关系，一个设施如冰箱可以在多个不同房子中拥有，一个房子同时也可以拥有多个设备设施如电视，空调，wifi等，那么存储多对多关系的表数据，就需要创建一个中间表 step6 创建中间表House_Facility表，字段(id，作为主键，外键house_id和facility_id) step7 客户订单表Order，字段(order_id，作为主键，外键user_id哪个用户和house_id哪个房子，create_time订单创建时间，start_date入住日期，end_date离开日期，price房屋单价，amount合计金额，days入住天数，status订单状态，comment评价) 思考1：之所以要在Order订单表中创建price字段是考虑到比如房东在第二天需要将房屋价格上涨或者下降，保证用户是按实时价格进行计算的，加入amount不仅是为了前端，重要的是为了后期运营人员进行统计方便，节省统计的开销问题：关于房东拒绝订单是否填写拒绝原因，设定是必须填写拒绝原因，那么是需要在Order 表中添加一个字段么？分析：因为一旦填写拒绝原因那么就不存在comment评价了，所以这拒绝原因和评价两个关系为互斥关系，所以我们这里不添加拒绝原因字段，当有了评论信息那么肯定就不会出现拒绝原因，可以通过订单状态status来判断是评价还是拒绝原因思考2： 当在房源搜索房屋的时候，会出现按照最新上线，入住最多，价格高低排序，当按照入住最多排序时，那么就是相当于按照订单量最多的房屋进行排序，那么就需要在Order表中按照订单量来进行排序，首先就需要根据入住时间和区域来来进入过滤查询，还要将查询的结果安装订单量进行排序，这样查询代价就比较大了，那么同理还是使用以空间换时间的概念，在House表中添加order_count来订单量，当没下一单就在对应的order_count的值加1，回过来通过直接查询House表中的order_count字段按大小排序就能查询到订单最多的房屋了 2.在models.py中创建数据库抽象模型类 step1 定义BaseModel模型基类，用于为每个模型添加创建时间和更新时间 step2 定义User用户表 step3 定义Area城区表 step4 定义House房屋表 step5 定义Facility设施表 step6 定义HouseImage房屋图片表 step7 定义Order订单表 四丶数据库迁移 step1 初始化数据库对象db step2 执行迁移文件，结果提示No change in….. 解决：因为models.py文件对于其他文件来说，并不知道它的存在，所以只需要在视图文件demo中导入models即可 1from ihome import db, models step3 再次执行迁移 ，则显示迁移成功 step4 执行升级，将数据写入到mysql中的ihome_python数据库中 step5 以上步骤完成后，进入mysql，使用ihome_python数据库，查询数据库表成功生成 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85676643","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（二）","slug":"Flask项目之手机端租房网站的实战开发（二）","date":"2019-11-03T05:47:29.581Z","updated":"2019-11-03T10:45:19.252Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（二）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（二）/","excerpt":"","text":"一丶创建项目1.新建ihome_python项目文件夹 2.在Pycharm中打开此文件 ，并配置项目解释器(python2环境) 3.在工程目录下创建manage.py作为项目启动文件 step1 实现flask中最基本的工作 12345678910111213# coding:utf-8 from flask import Flask app = Flask(__name__) @app.route('/index')def index(): return \"index page\" if __name__ == '__main__': app.run() step2 配置mysql数据库用于存储用户数据 123456789101112class Config(object): \"\"\"配置信息\"\"\" DEBUG = True SECRET_KEY = \"cdtaogang**CSDN@uhduqw82981h\" # 连接mysql数据库 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/ihome_python\" SQLALCHEMY_TRACK_MODIFICATIONS = True app.config.from_object(Config) db = SQLAlchemy(app) step3 在本地mysql中创建ihome_python数据库 1create database ihome_python charset=utf8; step4 配置redis数据库用于保存session信息以及缓存数据（因为flask框架默认将session数据存到cookie中），所以这里需要利用flask_session这个工具包帮助我们将flask存储的session数据交给我们管理，这样就可以将session数据存到redis数据库中了 1234567891011121314151617181920class Config(object): \"\"\"配置信息\"\"\" DEBUG = True SECRET_KEY = \"cdtaogang**CSDN@uhduqw82981h\" # 连接mysql数据库 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/ihome_python\" SQLALCHEMY_TRACK_MODIFICATIONS = True # redis数据库配置 REDIS_HOST = \"127.0.0.1\" REDIS_PORT = 6379 app.config.from_object(Config) db = SQLAlchemy(app) #创建redis数据库连接对象redis_store = redis.StrictRedis(host=Config.REDIS_HOST, port=Config.REDIS_PORT) step5 配置flask_session用于我们操作session到redis数据库（说明在Config类中再次创建redis数据库连接，是因为在实际线上环境中，可能需要将session数据存到不同的服务器上） 12345678 # flask_session配置 SESSION_TYPE = \"redis\" SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) SESSION_USE_SIGNER = True # 对cookie中session_id进行隐藏处理 PERMANENT_SESSION_LIFETIME = 86400 # session数据的有效期，单位秒 # 利用flask_session， 将session数据保存到redis中Session(app) step6 开启csrf防护机制(导入flask_WTF中的CSRFProtect类) 12# 为flask补充csrf防护CSRFProtect(app) 二丶创建工程目录(拆分manage.py)1.拆分配置文件 step1 在项目根目录下创建一个config.py文件，将manage.py中的Config配置类放到该文件中 step2 工程实现后，有两种运行环境，开发测试环境以及生成环境(线上环境)，所以flask程序在运行时，就需要配置两个配置类，一个是用于开发环境，另一个用于生成环境 1234567class DevelopmentConfig(Config): \"\"\"开发环境配置信息\"\"\" DEBUG = True class ProductConfig(Config): \"\"\"生成环境配置信息\"\"\" pass step3 将app对象设计为工厂模式 step4 在config.py中创建配置映射 12345#构建配置映射关系config_map = &#123; \"develop\": DevelopmentConfig, \"product\": ProductConfig&#125; step5 导入config中的config_map，通过调用create_app方法，创建app对象，将我们需要的配置环境通过传参的方式来决定是用开发环境还是生产环境，在create_app方法中就按照指明的环境进行配置即可 step6 因最初创建的manage.py作为项目启动文件，所以我们在manage文件中只保留启动代码即可，需将其余代码抽离出去，保证manage文件中没有其他的代码，项目根目录下只需要保留启动文件manage以及config配置文件，即在项目根目录下创建一个ihome的python包，将create_app代码放到这个ihome包的init文件中即可，随后在ihome包下创建一个static目录用于存放静态文件，再创建一个models.py文件用于做数据库的迁移 step7 在manage中创建并绑定app对象的代码，放到init中，会导致无法绑定create_app方法里面的app，所以使用SQLAlchemy对象db提供的init_app方法，在create_app方法里面对db进行初始化，这样就解决了 step8 在models.py文件中导入数据库对象db 1from ihome import db step9 将manage文件中创建的redis数据库连接对象放到init文件中，需要思考是否放在create_app方法中，因为最初在manage文件中创建的redis数据库连接需要从config文件中拿去host以及port配置，所以我们在全局声明redis_store变量为None，然后在方法中通过config_map获取的环境配置类config_class，说白了也就是config中的开发类DevelopmentConfig，直接拿去类中我们配置好的r连接redis数据库的port和host step10 对于Session(app)和CSRFProtect(app)，不会用到这两个对象来进行进一步操作，只是刚开始使用这两个对象来初始化app，一个是为了我们将session数据存到redis数据库，另一个是为了开启CSRF防护机制，所以直接放到create_app类即可 12345# 利用flask_session， 将session数据保存到redis中Session(app) # 为flask补充csrf防护CSRFProtect(app) step11 创建蓝图，用于管理不同版本的视图，在ihome核心目录下创建一个api_1_0python包，代表1.0版本的蓝图，在这个蓝图下就可以创建各种各样的视图了，在api_1_0蓝图下创建一个demo.py文件，将启动文件manage中的视图函数放到里面 123@app.route('/index')def index(): return \"index page\" step12 在api_1_0包下的init文件中创建蓝图 step13 在flask项目应用文件init中注册蓝图 ，首先在init文件中通过绝对路径导入api_1_0包，再通过app应用对象中的register_blueprint方法，注册api_1_0包中的api蓝图名字，并定义url前缀地址为/api/v1.0表示1.0版本 12# 注册蓝图app.register_blueprint(api_1_0.api, url_prefix=\"/api/v1.0\") step14 在创建工程时，可能会用到数据库models文件，那么就需要使用迁移插件，从flask_script中引入脚本命令管理对象，再从flask_migrate中导入迁移执行者Migrate，迁移命令解析人员Migratecommand / 三丶以开发环境进行项目测试 step1 在Pycharm终端中，执行python manage.py runserver 默认端口，运行项目 step2 打开浏览器输入http://127.0.0.1:5000/api/v1.0/index，测试运行项目是否成功 在浏览器中成功渲染出index视图函数返回的字符串，如下图 step3 回到Pycharm终端查看程序日志，请求方式和地址以及状态码都是完全正确，代表项目设计成功 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85623829","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（一）","slug":"Flask项目之手机端租房网站的实战开发（一）","date":"2019-11-03T05:22:54.117Z","updated":"2019-11-03T05:46:27.909Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（一）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（一）/","excerpt":"","text":"一丶项目介绍 产品：关于手机移动端的租房网站 角色：在这个产品中用户包括房东与房客 功能：房东可以在这个平台发布自己的房屋，房客可以在这个平台寻找自己想要租的房子(类似短租平台) 设计模式：使用前后端分离进行项目开发(后端不再控制前端的效果展示) 前端效果展示 二丶前后端分离 前后端分离的认识 叙述：用户直接在浏览器中输入网址，不再是后端对应的动态逻辑了，而是一个静态页面从/index 变成了 index.html文本文件，对于静态资源就从提供静态资源服务器中去拿(nginx)前端页面中对于数据这块的需求必定是从后端拿去数据，后端也不需要去渲染模板，直接将前端需要的数据转换成json格式字符串返回给前端即可(通过jquery以及其他前端框架去将数据渲染到页面)具体做成什么效果，跟后端没有什么关系，前端什么时候需要数据，后端就给数据，这就是前后端分离。 优点：无论对于手机上的浏览器还是app程序向后端拿数据时，只要在后端已经定义好了接口，这个接口都是可以直接用的，体现出后端接口的复用性。 流程：用户在浏览器中输入网址的时候，需要向后端(nginx)去要网页，在这个网页中没有任何的数据，只是普通的前端呈现的样式而已，在这个网页当中的js里面，通过ajax方式向后端接口要取数据，后端接口当中给前端返回的是json字符串，前端拿到这个字符串在到ajax回调函数中，通过jquery方式把数据填充到页面上。 缺点：对于搜索引擎优化SEO不友好，无法将网页的数据通过搜索引擎搜索关键字查询此网页信息，爬虫拿取页面信息，并没有任何数据，导致在搜索引擎上排名无法靠前 三丶项目需求需求功能 主页 1.1 最多5个房屋logo图片展示，点击可跳转至房屋详情页面 1.2 提供登陆/注册入口，登陆后显示用户名，点击可跳转至个人中心 1.3 用户可以选择城区、入住时间、离开时间等条件进行搜索 1.4 城区的区域信息需动态加载 注册 2.1 用户账号默认为手机号 2.2 图片验证码正确后才能发送短信验证码 2.3 短信验证码每60秒可发送一次 2.4 每个条件出错时有相应错误提示 登陆 3.1 用手机号与密码登陆 3.2 错误时有相应提示 房屋列表页 4.1 可根据入住离开时间、区域进行筛选，并可进行排序 4.2 房屋信息分页加载 4.3 区域信息动态加载 4.4 筛选条件更新后，页面立即刷新 房屋详情页 5.1 需展示的详细信息参考设计图 5.2 提供预定入口 5.3 若是房东本人查看房屋信息时，预定入口不显示 房屋预定 6.1 由用户确定入住时间 6.2 根据用户确定的入住离开时间实时显示合计天数与总金额 我的爱家 7.1 显示个人头像、手机号、用户名（用户名未设置时为用户手机号） 7.2 提供修改个人信息的入口 7.3 提供作为房客下单的查询入口 7.4 提供成为房东所需实名认证的入口 7.5 提供作为房东发布房屋信息的入口 7.6 提供作为房东查询客户订单的入口 7.7 提供退出的入口 个人信息修改 8.1 可以修改个人头像 8.2 可以修改用户名 8.3 登陆手机号不能修改 8.4 上传头像与用户名分开保存 8.5 上传新头像后页面理解显示新头像 我的订单（房客） 9.1 按时间倒序显示订单信息 9.2 订单完成后提供评价功能 9.3 已评价的订单能看到评价信息 9.4 被拒绝的订单能看到拒单原因 实名认证10.1 实名认证只可进行一次10.2 提交认证信息后再次进入只能查看信息，不能修改10.3 认证信息包含姓名与身份证号 我的房源11.1 未实名认证的用户不能发布新房源信息，需引导到实名认证页面11.2 按时间倒序显示已经发布的房屋信息11.3 点击房屋可以进入详情页面11.4 对实名认证的用户提供发布新房屋的入口 发布新房源12.1 需要用户填写全部房屋信息12.2 房屋的文字信息与图片分开操作 客户订单（房东）13.1 按时间倒序显示用户下的订单13.2 对于新订单提供接单与拒单的功能13.3 拒单必须填写拒单原因13.4 若客户进行了订单评价，需显示 退出14.1 提供退出功能 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85613780","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"微信公众号开发之微信网页授权获取用户个人信息","slug":"微信公众号开发之微信网页授权获取用户个人信息","date":"2019-11-03T04:24:17.193Z","updated":"2019-11-03T06:27:22.702Z","comments":true,"path":"2019/11/03/微信公众号开发之微信网页授权获取用户个人信息/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/微信公众号开发之微信网页授权获取用户个人信息/","excerpt":"","text":"一丶概述 微信网页授权 如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。 现在，我们要实现一个微信内网页，通过微信访问网页时，网页会展示微信用户的个人信息。因为涉及到用户的个人信息，所以需要有用户授权才可以。当用户授权后，我们的网页服务器（开发者服务器）会拿到用户的“授权书”（code）,我们用这个code向微信服务器领取访问令牌（accecc_token）和用户的身份号码（openid)，然后凭借access_token和openid向微信服务器提取用户的个人信息。 第一步：用户同意授权，获取code 第二步：通过code换取网页授权access_token 第三步：拉取用户信息(需scope为 snsapi_userinfo) 那么，如何拿到用户的授权code呢？ 授权是由微信发起让用户进行确认，在这个过程中是微信在与用户进行交互，所以用户应该先访问微信的内容，用户确认后再由微信将用户导向到我们的网页链接地址，并携带上code参数。我们把这个过程叫做网页回调，类似于我们在程序编写时用到的回调函数，都是回调的思想。 关于网页授权回调域名的说明 1、在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；关于网页授权回调域名的说明 2、授权回调域名配置规范为全域名，比如需要网页授权的域名为：www.qq.com，配置以后此域名下面的页面http://[www.qq.com/music.html](www.qq.com/music.html) 、 http://www.qq.com/login.html 都可以进行OAuth2.0鉴权。但http://pay.qq.com 、 http://music.qq.com 、 http://qq.com无法进行OAuth2.0鉴权 3、如果公众号登录授权给了第三方开发者来进行管理，则不必做任何设置，由第三方代替公众号实现网页授权即可。 第一步：用户同意授权，获取code在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），引导关注者打开如下页面： https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 尤其注意：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问 参考链接(请在微信客户端中打开此链接体验):scope为snsapi_basehttps://open.weixin.qq.com/connect/oauth2/authorize?appid=wx520c15f417810387&amp;redirect_uri=https%3A%2F%2Fchong.qq.com%2Fphp%2Findex.php%3Fd%3D%26c%3DwxAdapter%26m%3DmobileDeal%26showwxpaytitle%3D1%26vb2ctag%3D4_2030_5_1194_60&amp;response_type=code&amp;scope=snsapi_base&amp;state=123#wechat_redirectscope为snsapi_userinfohttps://open.weixin.qq.com/connect/oauth2/authorize?appid=wxf0e81c3bee622d60&amp;redirect_uri=http%3A%2F%2Fnba.bluewebgame.com%2Foauth_response.php&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirec 尤其注意：跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。 参数说明 参数 是否必须 说明 appid 是 公众号的唯一标识 redirect_uri 是 授权后重定向的回调链接地址， 请使用 urlEncode 对链接进行处理 response_type 是 返回类型，请填写code scope 是 应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ） state 否 重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节 #wechat_redirect 是 无论直接打开还是做页面302重定向时候，必须带此参数 下图为scope等于snsapi_userinfo时的授权页面： 用户同意授权后 如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE。 code说明： code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期。 第二步：通过code换取网页授权access_token首先请注意，这里通过code换取的是一个特殊的网页授权access_token,与基础支持中的access_token（该access_token用于调用其他接口）不同。公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。 尤其注意：由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起。 请求方法 获取code后，请求以下链接获取access_token： https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 参数说明 参数 是否必须 说明 appid 是 公众号的唯一标识 secret 是 公众号的appsecret code 是 填写第一步获取的code参数 grant_type 是 填写为authorization_code 返回说明 正确时返回的JSON数据包如下： 12345&#123; \"access_token\":\"ACCESS_TOKEN\",\"expires_in\":7200,\"refresh_token\":\"REFRESH_TOKEN\",\"openid\":\"OPENID\",\"scope\":\"SCOPE\" &#125; 参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 expires_in access_token接口调用凭证超时时间，单位（秒） refresh_token 用户刷新access_token openid 用户唯一标识，请注意，在未关注公众号时，用户访问公众号的网页，也会产生一个用户和公众号唯一的OpenID scope 用户授权的作用域，使用逗号（,）分隔 错误时微信会返回JSON数据包如下（示例为Code无效错误）: 1&#123;\"errcode\":40029,\"errmsg\":\"invalid code\"&#125; 第三步：拉取用户信息(需scope为 snsapi_userinfo)如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。 请求方法 http：GET（请使用https协议） https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN 参数说明 参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 openid 用户的唯一标识 lang 返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语 返回说明 正确时返回的JSON数据包如下： 12345678910&#123; \"openid\":\" OPENID\",\" nickname\": NICKNAME,\"sex\":\"1\",\"province\":\"PROVINCE\"\"city\":\"CITY\",\"country\":\"COUNTRY\",\"headimgurl\": \"http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46\",\"privilege\":[ \"PRIVILEGE1\" \"PRIVILEGE2\" ],\"unionid\": \"o6_bmasdasdsad6_2sgVt7hMZOPfL\"&#125; 参数 描述 openid 用户的唯一标识 nickname 用户昵称 sex 用户的性别，值为1时是男性，值为2时是女性，值为0时是未知 province 用户个人资料填写的省份 city 普通用户个人资料填写的城市 country 国家，如中国为CN headimgurl 用户头像，最后一个数值代表正方形头像大小（有0、46、64、96、132数值可选，0代表640*640正方形头像），用户没有头像时该项为空。若用户更换头像，原有头像URL将失效。 privilege 用户特权信息，json 数组，如微信沃卡用户为（chinaunicom） unionid 只有在用户将公众号绑定到微信开放平台帐号后，才会出现该字段。 错误时微信会返回JSON数据包如下（示例为openid无效）: 1&#123;\"errcode\":40003,\"errmsg\":\" invalid openid \"&#125; 二丶代码实现 思路分析 首选在我们的flask程序中需要定义一个视图函数路由规则为/wechat8007/index，定义微信服务器重定向网址redirect_uri为服务器域名+/wechat8007/index（例如http://www.xxxx.com/wechat8007/index），通过访问微信提供的引导页面，让用户同意授权，然后重定向到我们定义的网址，此时微信服务器就会给我们的服务一个code，我们的服务器再通过code向微信服务器换取网页授权access_token(存取令牌)，如果网页授权作用域为snsapi_userinfo，则此时可以通过access_token和openid拉取用户信息了。 step1 同意授权，这一块不需要代码实现，只需要提供授权链接即可 step2 定义视图函数，当用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE ，在flask程序中定义一个是视图函数接口index，让用户同意授权后，去访问的视图 上一篇博客定义的wechat视图，是由微信服务器访问，现在定义的index视图为用户访问的 123@app.route(\"/wechat8007/index\")def index(): \"\"\"让用户通过微信访问的网页页面视图\"\"\" step3 刚开始还没拉去用户资料时，可直接返回一个模板 1return render_template(\"index.html\") step4 从微信服务器中获取用户的资料数据，将用户的资料数据填充到index.html模板中 1.获取code参数 1code = request.args.get(\"code\") 2.当code不存在时，返回字符串 12if not code: return u\"缺失code参数\" 3.向微信服务器发送http请求，获取access_token，在获取之前要在代码定义全局变量WECHAT_APPID以及WECHAT_APPSECRET的值，用来填充https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 微信提供获取access_token链接地址中的APPID以及SECRET和CODE的值，再通过python中的urllib2库向这个url发送请求，read方法读取文本内容获取json格式的字符串，然后使用json当中的loads方法将json格式的字符串转换为字典 1234567url = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&amp;secret=%s&amp;code=%s&amp;grant_type=authorization_code\" %(WECHAT_APPID,WECHAT_APPSECRET,code) response = urllib2.urlopen(url) # 获取响应体数据,微信返回的json数据json_str = response.read()resp_dict = json.loads(json_str) 4.提取access_token，首先对获取到的响应体数据进行判断，如果不存在，直接返回提示字符串，存在则通过get方式拿去字典中的access_token键的值以及用户编号openid的值 12345if \"errcode\" in resp_dict: return u\"获取access_token失败\" access_token = resp_dict.get(\"access_token\")open_id = resp_dict.get(\"openid\") # 用户的编号 step5 向微信服务器发送http请求，获取用户的资料数据 1234567url = \"https://api.weixin.qq.com/sns/userinfo?access_token=%s&amp;openid=%s&amp;lang=zh_CN\" %(access_token,open_id) response = urllib2.urlopen(url) # 读取微信传回的json的响应体数据user_json_str = response.read()user_dict_data = json.loads(user_json_str) step6 判断微信返回的响应体数据中是否有errorcode字段，如果存在则返回失败信息，不存在说明微信返回的json数据为正确数据，则将该数据传给index.html模板，当用户访问http://xxx/wechat8007/index地址时，会渲染出我们定义的index.html模板 12345if \"errcode\" in user_dict_data: return u\"获取用户信息失败\"else: # 将用户的资料数据填充到页面中 return render_template(\"index.html\", user=user_dict_data) step7 当前目录下创建templates模板目录，在该目录中创建index.html文件 ，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&#123;&#123;user[\"nickname\"]&#125;&#125;的个人主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img alt=\"头像\" src=\"&#123;&#123;user['headimgurl']&#125;&#125;\" width=\"60\"&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;openid&lt;/th&gt; &lt;td&gt;&#123;&#123;user[\"openid\"]&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;昵称&lt;/th&gt; &lt;td&gt;&#123;&#123;user[\"nickname\"]&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;性别&lt;/th&gt; &lt;td&gt; &#123;% if 1 == user[\"sex\"] %&#125; 男 &#123;% elif 2 == user[\"sex\"] %&#125; 女 &#123;% else %&#125; 未知 &#123;% endif %&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;省份&lt;/th&gt; &lt;td&gt;&#123;&#123;user[\"province\"]&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;城市&lt;/th&gt; &lt;td&gt;&#123;&#123;user[\"city\"]&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;国家&lt;/th&gt; &lt;td&gt;&#123;&#123;user[\"country\"]&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 三丶部署测试 step1 将代码推送到服务器上 成功推送到服务器上 step2 在服务器上进入虚拟环境，运行此程序 step3 拼接微信提供网址 https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 注：正式公众号redirect_uri地址必须为服务器的域名地址，不能是IP地址 在拼接redirect_uri时，服务器的域名为http://www.xxx.com/wechat8007/index，微信提供的授权地址http://中不可能包含一个redirect_uri为http://www.xxx.com/wechat8007/index用户同意授权后跳转的地址，所以需要对重定向地址http://www.xxx.com/wechat8007/index 进行转义 使用python urllib库中的quote方法进行转义 1234In [1]: import urllib In [2]: urllib.quote(\"http://www.xxx.com/wechat8007/index\")Out[2]: 'http%3A//www.xxx.com/wechat8007/index' 拼接好的用户访问的url地址为 step4 可以将该网址生成二维码，使用微信扫一扫，也可以在接口公众号直接发送此链接地址 使用谷歌浏览器的二维码插件，将网址生成对应的二维码(这里以百度首页网址为例) 直接在浏览器中输入此地址会提示请在微信客户端打开链接 step5 测试，在手机微信上打开此链接，出现授权登录提示，点击允许即可获取用户个人信息 点击允许后，进入如下界面 点击继续访问，则出现博主个人的微信信息了，如下图 此时查看服务器上程序运行日志 四丶完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# coding:utf-8from flask import Flask, request, render_templateimport json, urllib2 WECHAT_APPID = \"yourappid\"WECHAT_APPSECRET = \"yoursecret\" app = Flask(__name__) @app.route(\"/wechat8007/index\")def index(): code = request.args.get(\"code\") if not code: return u\"缺失code参数\" url = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&amp;secret=%s&amp;code=%s&amp;grant_type=authorization_code\" % (WECHAT_APPID, WECHAT_APPSECRET, code) response = urllib2.urlopen(url) json_str = response.read() resp_dict = json.loads(json_str) if \"errcode\" in resp_dict: return u\"获取access_token失败\" access_token = resp_dict.get(\"access_token\") open_id = resp_dict.get(\"openid\") url = \"https://api.weixin.qq.com/sns/userinfo?access_token=%s&amp;openid=%s&amp;lang=zh_CN\" % (access_token, open_id) response = urllib2.urlopen(url) user_json_str = response.read() user_dict_data = json.loads(user_json_str) if \"errcode\" in user_dict_data: return u\"获取用户信息失败\" else: return render_template(\"index.html\", user=user_dict_data) if __name__ == '__main__': app.run(port=8007, debug=True) 总结：微信公众号接口开发，根据官方提供的开发文档，进行开发，逻辑实现都很简单，多想多思考多练习，你会越来越棒的！ ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85334634","categories":[{"name":"WeChat开发","slug":"WeChat开发","permalink":"https://hellotaogang.github.io/categories/WeChat开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://hellotaogang.github.io/tags/微信公众号/"},{"name":"微信开发","slug":"微信开发","permalink":"https://hellotaogang.github.io/tags/微信开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"微信公众号开发之接收与发送消息","slug":"微信公众号开发之接收与发送消息","date":"2019-11-03T03:54:41.583Z","updated":"2019-11-03T06:26:46.502Z","comments":true,"path":"2019/11/03/微信公众号开发之接收与发送消息/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/微信公众号开发之接收与发送消息/","excerpt":"","text":"一丶概论 公众号接收与发送消息 验证URL有效性成功后即接入生效，成为开发者。如果公众号类型为服务号（订阅号只能使用普通消息接口），可以在公众平台网站中申请认证，认证成功的服务号将获得众多接口权限，以满足开发者需求。 此后用户每次向公众号发送消息、或者产生自定义菜单点击事件时，开发者填写的服务器配置URL将得到微信服务器推送过来的消息和事件，然后开发者可以依据自身业务逻辑进行响应，例如回复消息等。 用户向公众号发送消息时，公众号方收到的消息发送者是一个OpenID，是使用用户微信号加密后的结果，每个用户对每个公众号有一个唯一的OpenID。 1.接收普通消息当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上。 微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。假如服务器无法保证在五秒内处理并回复，可以直接回复空串，微信服务器不会对此作任何处理，并且不会发起重试。 各消息类型的推送使用XML数据包结构，如： 12345678&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[gh_866835093fea]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[ogdotwSc_MmEEsJs9-ABZ1QL_4r4]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1478317060&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;&lt;MsgId&gt;6349323426230210995&lt;/MsgId&gt;&lt;/xml&gt; 注意：&lt;![CDATA 与 ]]&gt; 括起来的数据不会被xml解析器解析 2.普通消息类别 文本消息 图片消息 语音消息 视频消息 小视频消息 地理位置消息 链接消息 文本消息 12345678&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt; 3. 回复的消息类型 文本消息 图片消息 语音消息 视频消息 音乐消息 图文消息 回复文本消息 1234567&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;&lt;/xml&gt; 注：开发文档可以到 https://mp.weixin.qq.com/wiki/home/index.html 进行阅读查看 二丶代码实现需求：我们现在来实现一个针对文本消息的收发程序。实现的业务逻辑，关注者发什么内容，我们就传回给什么内容。 说明：微信服务器推送消息还是往/wechat/8007，所以在之前代码上进行修改即可 1.开发步骤 step1 如何区分微信服务器发过来的是第一次的验证操作还是消息操作 验证操作为GET请求，消息操作为POST请求 1@app.route(\"/wechat8007\", methods=[\"GET\", \"POST\"]) step2 参数变更，echostr参数只是在第一次验证的时候需要，无论是POST请求还是GET请求这三种参数都必要要，因为需要验证是不是微信服务器发送过来的数据 123signature = request.args.get(\"signature\")timestamp = request.args.get(\"timestamp\")nonce = request.args.get(\"nonce\") step3 对微信服务器发送的请求进行验证判断，如果是GET请求，那么代表是第一次的验证操作，那么就需要获取echostr字段的内容，如果内容为空则抛出404，存在则返回echostr 123456if request.method == \"GET\": # 表示是第一次接入微信服务器的验证 echostr = request.args.get(\"echostr\") if not echostr: abort(404) return echostr step4 如果为POST请求，那么代表为微信服务器转发消息过来，获取请求中的data xml数据 ，数据为空抛出400 12345elif request.method == \"POST\": # 表示微信服务器转发消息过来 xml_str = request.data if not xml_str: abort(400) step5 将对获取的数据进行解析，通过xmltodict模块中的parse方法将字符串类型的xml数据，转换成字典类型的xml格式数据，因为xml数据最外层有一个标签，通过get方式获取标签里的内容，再通过get获取内容中的MsgType消息类型字段的值 123456# 对xml字符串进行解析xml_dict = xmltodict.parse(xml_str)xml_dict = xml_dict.get(\"xml\") # 提取消息类型msg_type = xml_dict.get(\"MsgType\") step6 对消息类型进行判断，如果为text文本消息，则返回文本消息，不是文本消息还是返回文本消息，这里可以拓展为(image，voice，video等等可以查看开发文档)，这里为了演示，就简单写写 12345678910111213141516171819202122 if msg_type == \"text\": # 表示发送的是文本消息 # 构造返回值，经由微信服务器回复给用户的消息内容 resp_dict = &#123; \"xml\": &#123; \"ToUserName\": xml_dict.get(\"FromUserName\"), \"FromUserName\": xml_dict.get(\"ToUserName\"), \"CreateTime\": int(time.time()), \"MsgType\": \"text\", \"Content\": \"taogang say:\" + xml_dict.get(\"Content\") &#125; &#125;else: resp_dict = &#123; \"xml\": &#123; \"ToUserName\": xml_dict.get(\"FromUserName\"), \"FromUserName\": xml_dict.get(\"ToUserName\"), \"CreateTime\": int(time.time()), \"MsgType\": \"text\", \"Content\": \"Dear I Love you so much\" &#125; &#125; step7 最后将我们构造的响应返回值通过unparse方法转换成xml格式的字符串，返回给微信服务器 1234# 将字典转换为xml字符串resp_xml_str = xmltodict.unparse(resp_dict)# 返回消息数据给微信服务器return resp_xml_str 2.部署测试 step1 将代码推送到服务器上 step2 在服务器上进入虚拟环境，运行此程序 step3 进入微信公众平台，用手机扫描测试号二维码，进行关注测试 扫码后进行关注 关注后进入此公众号，公众号则发送我们在开发步骤step 6，Dear I Love you so much 消息内容 回到服务器程序运行日志上，显示为POST请求，说明程序逻辑完全没问题 公众号测试平台用户列表将我的微信添加上去了 step4 测试，在关注的此公众中，进行消息(文本，表情，语言，图片，视频）发送，当消息类型为文本时，即返回此消息内容，如果不是都是返回文本类型，内容为Dear I Love you so much 此时的服务器代码运行日志 3.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# coding:utf-8from flask import Flask, request, abort, render_templateimport hashlibimport xmltodict, time # 常量# 微信的token令牌WECHAT_TOKEN = \"cdtaogang\" app = Flask(__name__) @app.route(\"/wechat8007\", methods=[\"GET\", \"POST\"])def wechat(): \"\"\"对接微信公众号服务器\"\"\" # 接收微信服务器发送的参数 signature = request.args.get(\"signature\") timestamp = request.args.get(\"timestamp\") nonce = request.args.get(\"nonce\") if not all([signature, timestamp, nonce]): abort(400) # 按照微信的流程进行计算签名 li = [WECHAT_TOKEN, timestamp, nonce] # 排序 li.sort() # 拼接字符串 tmp_str = ''.join(li) # 进行sha1加密, 得到正确的签名值 sign = hashlib.sha1(tmp_str).hexdigest() # 将自己计算的签名值与请求的签名参数进行对比，如果相同，则证明请求来自微信服务器 if sign != signature: # 表示请求不是微信发的 abort(403) else: # 表示是微信发送的请求 if request.method == \"GET\": # 表示是第一次接入微信服务器的验证 echostr = request.args.get(\"echostr\") if not echostr: abort(404) return echostr elif request.method == \"POST\": # 表示微信服务器转发消息过来 xml_str = request.data if not xml_str: abort(400) # 对xml字符串进行解析 xml_dict = xmltodict.parse(xml_str) xml_dict = xml_dict.get(\"xml\") # 提取消息类型 msg_type = xml_dict.get(\"MsgType\") if msg_type == \"text\": # 表示发送的是文本消息 # 构造返回值，经由微信服务器回复给用户的消息内容 resp_dict = &#123; \"xml\": &#123; \"ToUserName\": xml_dict.get(\"FromUserName\"), \"FromUserName\": xml_dict.get(\"ToUserName\"), \"CreateTime\": int(time.time()), \"MsgType\": \"text\", \"Content\": \"taogang say:\" + xml_dict.get(\"Content\") &#125; &#125; else: resp_dict = &#123; \"xml\": &#123; \"ToUserName\": xml_dict.get(\"FromUserName\"), \"FromUserName\": xml_dict.get(\"ToUserName\"), \"CreateTime\": int(time.time()), \"MsgType\": \"text\", \"Content\": \"Dear I Love you so much\" &#125; &#125; # 将字典转换为xml字符串 resp_xml_str = xmltodict.unparse(resp_dict) # 返回消息数据给微信服务器 return resp_xml_str if __name__ == '__main__': app.run(port=8007, debug=True) ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85330265","categories":[{"name":"WeChat开发","slug":"WeChat开发","permalink":"https://hellotaogang.github.io/categories/WeChat开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://hellotaogang.github.io/tags/微信公众号/"},{"name":"微信开发","slug":"微信开发","permalink":"https://hellotaogang.github.io/tags/微信开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"微信公众号之接入微信公众号服务器开发（二）","slug":"微信公众号之接入微信公众号服务器开发（二）","date":"2019-10-31T09:54:08.258Z","updated":"2019-11-03T06:27:33.776Z","comments":true,"path":"2019/10/31/微信公众号之接入微信公众号服务器开发（二）/","link":"","permalink":"https://hellotaogang.github.io/2019/10/31/微信公众号之接入微信公众号服务器开发（二）/","excerpt":"","text":"一丶叙述开发说明 Python代码实现（以Flask框架为例） 将使用公众号消息会话 客户端—-＞微信服务器—-＞nginx服务器—-＞开发者服务器 在微信服务器与开发者服务器之间搭建了nginx服务器默认为80端口(也是微信支持的端口)，跟开发者服务器属于同一个主机 在nginx服务器上配置了多个端口，方便多人进行测试，转发规则：location/wechat8007 在微信公众号测试平台接口配置url为host/wechat8007时，当微信服务器发送消息给host/wechat8007时，host为nginx服务器时，就会按照/wechat8007转发规则匹配，一旦匹配成功后，由nginx服务器转发给开发者服务器上127.0.0.1:8007进程的用户，这样可以实现多个账号共享一个80端口，并可以收到微信服务器对应用户的消息 注：在写的flask程序中视图网址也必须是/wechat8007，因为nginx在向后台转发的时候，它只是按照/wechat8007规则知道转发给谁，它会把微信用户的请求原封不动的往后去发，因为微信服务器在向我们发送请求路径就是/wechat:8007,意味着nginx再转发给我们的时候，在我们写的flask程序收到的请求里面，你会发现对应的请求路径也是/wechat8007，所以我们flask程序中的route路径也必须是/wechat8007 如果是在公司做开发的话，不涉及到多个账户使用一个80端口，所以直接把程序在开发者服务器上以80端口运行，然后在微信公众测试平台配置url为配置程序地址即可 博主之所以这样做，那是因为我还没有购买服务器（●︿●） 接入微信公众平台接入微信公众平台开发，开发者需要按照如下步骤完成： 填写服务器配置 验证服务器地址的有效性 依据接口文档实现业务逻辑 填写服务器配置登录微信公众平台官网后，在公众平台后台管理页面 - 开发者中心页，点击“修改配置”按钮，填写服务器地址（URL）、Token和EncodingAESKey，其中URL是开发者用来接收微信消息和事件的接口URL。Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥。 同时，开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。模式的选择与服务器配置在提交后都会立即生效，请开发者谨慎填写及选择。加解密方式的默认状态为明文模式，选择兼容模式和安全模式需要提前配置好相关加解密代码，详情请参考消息体签名及加解密部分的文档。 1.进入微信公众平台后，找到开发栏，进入基本配置 2.利用测试平台测试平台登录地址：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login在手机微信上进行扫码登录即可 二丶验证服务器地址的有效性开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带四个参数： 开发者通过检验signature对请求进行校验。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。 校验流程： 将token、timestamp、nonce三个参数进行字典序排序 将三个参数字符串拼接成一个字符串进行sha1加密 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 1.根据上面微信公众平台提供的开发文档进行代码编写代码实现如下 12345678910111213141516171819202122232425262728293031323334353637383940# coding:utf-8from flask import Flask, request, abortimport hashlib # 常量# 微信的token令牌WECHAT_TOKEN = \"cdtaogang\" app = Flask(__name__) @app.route(\"/wechat8007\")def wechat(): \"\"\"对接微信公众号服务器\"\"\" # 接收微信服务器发送的参数 signature = request.args.get(\"signature\") timestamp = request.args.get(\"timestamp\") nonce = request.args.get(\"nonce\") echostr = request.args.get(\"echostr\") # 校验参数 if not all([signature, timestamp, nonce, echostr]): abort(400) # 按照微信的流程进行计算签名 li = [WECHAT_TOKEN, timestamp, nonce] # 排序 li.sort() # 拼接字符串 tmp_str = ''.join(li) # 进行sha1加密, 得到正确的签名值 sign = hashlib.sha1(tmp_str).hexdigest() # 将自己计算的签名值与请求的签名参数进行对比，如果相同，则证明请求来自微信服务器 if sign != signature: # 表示请求不是微信发的 abort(403) else: return echostr if __name__ == '__main__': app.run(port=8007, debug=True) 2.测试连接开发者服务器 step1 使用ssh命令测试连接服务器 step2 使用scp命令将程序文件推送到服务器 step3 在开发者服务器上运行wechat程序 step4 回到微信公众测试平台配置接口 注意：当没有在服务器运行wechat程序时，进行提交会显示失败 此时，回头看服务器程序运行日志，微信给我发了一个以get方式请求过来的数据 大功告成！说明该服务器具有有效性…. ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85321424","categories":[{"name":"WeChat开发","slug":"WeChat开发","permalink":"https://hellotaogang.github.io/categories/WeChat开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://hellotaogang.github.io/tags/微信公众号/"},{"name":"微信开发","slug":"微信开发","permalink":"https://hellotaogang.github.io/tags/微信开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"微信公众号之接入微信公众号服务器开发（一）","slug":"微信公众号之接入微信公众号服务器开发（一）","date":"2019-10-31T02:38:05.755Z","updated":"2019-11-03T06:27:40.820Z","comments":true,"path":"2019/10/31/微信公众号之接入微信公众号服务器开发（一）/","link":"","permalink":"https://hellotaogang.github.io/2019/10/31/微信公众号之接入微信公众号服务器开发（一）/","excerpt":"","text":"一丶概述公众号与公众平台1.微信账号类型 个人号 公众号&ensp;– 订阅号&ensp;– 服务号 企业号 2.公众号微信公众号主要面向名人、政府、媒体、企业等机构推出的合作推广业务。在这里可以通过微信渠道将品牌推广给上亿的微信用户，减少宣传成本，提高品牌知名度，打造更具影响力的品牌形象。 3.公众平台微信公众平台是运营者通过公众号为微信用户提供资讯和服务的平台，而公众平台开发接口则是提供服务的基础，开发者在公众平台网站中创建公众号、获取接口权限后，可以通过阅读公众平台开发接口文档来帮助开发。 微信公众平台可以用来注册、管理公众号和企业号。 登录网址：https://mp.weixin.qq.com/ 进入上面网址，可进行登录及注册注册流程： step1 基本信息 step2 选择类型 step3 信息登记 step4 公众号信息 step5 完成注册后，进行登录，首先需使用手机进行扫码 在手机端显示此界面，确认无误后，确定即可 通过身份验证后，即可在网页端对创建的公众号进行简单配置，如下图 一些简单的功能添加以及配置(需要啥配置啥即可，简单操作这里不做详细说明了) 4.公众号与个人号的区别微信公众号和个人号是完全不同的。 微信对个人号的定位是普通用户之间的交流和通讯，微信并不鼓励和支持使用个人号进行营销推广(微信曾经大规模封杀好友过多的营销个人号）。 而公众号则完全是为品牌推广、信息推送等服务而定制的。使用公众号，可以向关注者（即粉丝)群发图文消息，粉丝在对话界面看到消息后，可以点击跳转到一个图文页面。公众号还提供关键词自动回复等基础功能，以此可以随时、自动的和粉丝进行互动。 除了这些基础功能之外，更大的区别是，微信针对公众号开放了很多程序接口。在这些接口的基础上，可以向粉丝提供更多的服务。此外，认证的服务号还可以申请微信支付。粉丝可以使用微信支付向进行付款（订购服务或购买商品）。所有这些，都是个人号不具备的。 微信公众号的注册几乎是没有门槛的。不过针对不同类型的公众号，微信提供的功能不同，资质要求也不一样。 二丶微信开发原理公众号主要通过 公众号消息会话 公众号内网页 来为用户提供服务的。 公众号消息会话 公众号是以微信用户的一个联系人形式存在的，消息会话是公众号与用户交互的基础。 公众号内网页 许多复杂的业务场景，需要通过网页形式来提供服务。 使用微信服务器提供的功能无法满足我们的需求 设想两个场景： 1.公众号的消息自动回复想做的智能一些，类似于iphone的Siri，例如粉丝发送“今天的北京天气”到公众号，回复粉丝信息时要按照特定时间特定城市给予反馈; 2.公众号内嵌的网页需要获取浏览用户的微信头像、昵称、当前定位等信息 模型分类1.无扩展应用模型1.公众号消息会话2.公众号内网页 2.有扩展应用模型1.公众号消息会话2.公众号内网页 公众号接口1.公众号消息会话目前公众号内主要有这样几类消息服务的类型，分别用于不同的场景。 群发消息 公众号可以以一定频次（订阅号为每天1次，服务号为每月4次），向用户群发消息，包括文字消息、图文消息、图片、视频、语音等。 被动回复消息 在用户给公众号发消息后，微信服务器会将消息发到开发者预先在开发者中心设置的服务器地址（开发者需要进行消息真实性验证），公众号可以在5秒内做出回复，可以回复一个消息，也可以回复命令告诉微信服务器这条消息暂不回复。被动回复消息可以设置加密（在公众平台官网的开发者中心处设置，设置后，按照消息加解密文档来进行处理。其他3种消息的调用因为是API调用而不是对请求的返回，所以不需要加解密）。 客服消息 在用户给公众号发消息后的48小时内，公众号可以给用户发送不限数量的消息，主要用于客服场景。用户的行为会触发事件推送，某些事件推送是支持公众号据此发送客服消息的，详见微信推送消息与事件说明文档。 模板消息 在需要对用户发送服务通知（如刷卡提醒、服务预约成功通知等）时，公众号可以用特定内容模板，主动向用户发送消息。 2.公众号内网页对于公众号内网页，提供以下场景接口： 网页授权获取用户基本信息 通过该接口，可以获取用户的基本信息 微信JS-SDK 是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。 3.微信开发者文档文档链接地址：https://mp.weixin.qq.com/wiki/home/index.html ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85319116","categories":[{"name":"WeChat开发","slug":"WeChat开发","permalink":"https://hellotaogang.github.io/categories/WeChat开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://hellotaogang.github.io/tags/微信公众号/"},{"name":"微信开发","slug":"微信开发","permalink":"https://hellotaogang.github.io/tags/微信开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"软件测试用例设计总结","slug":"测试笔记","date":"2019-10-18T08:44:03.237Z","updated":"2019-10-31T13:31:51.920Z","comments":true,"path":"2019/10/18/测试笔记/","link":"","permalink":"https://hellotaogang.github.io/2019/10/18/测试笔记/","excerpt":"","text":"1.测试流程需求分析—测试需求—测试计划–测试方案—测试用例—执行测试—测试报告 2.测试用例的特性 有效性：能使用，不同人使用结果一致（测试用例的能够被使用，且被不同人员使用测试结果一致） 可复用性：良好的测试用例具有重复使用的功能 易组织性：好的测试用例会分门别类地提供给测试人员参考和使用 可评估性：从测试管理的角度，测试用例的通过率和软件缺陷的数目是软件产品质量好坏的测试标准（测试计划） 可管理性：测试用例可以作为检验测试人员进度、工作量以及跟踪/管理测试人员工作效率的因素（对测试人员进行工作量和绩效考核） 3.测试用例的八大要素①测试编号②测试模块③测试标题④测试级别⑤测试环境⑥测试输入⑦测试步骤⑧预期结果 测试编号：每个测试用例都有唯一的标识号，用以区别其他测试用例例：系统测试用例的编号这样定义规则： PROJECT1-ST-001 ，命名规则是项目名称＋测试阶段类型（系统测试阶段）＋编号 测试模块：指明并简单描述本测试用例是用来测试哪些项目、子项目或软件特性的例：购物模块 测试标题：对测试用例的描述，测试用例标题应该清楚表达测试用例的用途例：“ 测试用户登录时输入错误密码时，软件的响应情况 ” 测试级别：定义测试用例的优先级别，可以粗略地分为 “ 高 ” 和 “ 低 ” 两个级别例： 核心功能 —高 界面风格 —低 测试环境：描述执行测试用例所需要的具体测试环境，包括硬件环境和软件环境例： 硬件 ——计算机的具体配置，见测试计划；软件——操作系统 linux 数据库 mysql 中间件 weblogic 测试输入：用来执行测试用例的输入要求。这些输入可能是数据、文件或具体操作例： 数据 ： 12 文件 ： D:\\baidu\\文件couture 动作 ： 单击鼠标，在键盘做按键处理 测试步骤：执行本测试用例所需的每一步操作例： 求和运算 输入加数12 输入被加数 24 点击“加法按钮” 预期结果：描述被测项目或被测特性所希望或要求达到的输出或指标例： 加法器 12+24 预期结果： 36 4.测试用例操作步骤1.设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这个过程，直至所有的有效等价类均被测试用例所覆盖 2.设计一个新的测试用例，使其仅覆盖一个无效等价类，重复这个过程，直至所有的无效等价类均被测试用例所覆盖 3.设计数据要注意 ①无效等价类在一个用例中只能出现一次 ②有效等价类在一个用例中可以出现多次4.等价类划分技巧 ①测试用例分析最好用xmind ②按等价类给出数据最好用电子表格 ③当产生意见分歧，回看需求规格说明书 5.软件测试用例方法1.输出域 覆盖所有的输出，不管输入2.输入域 覆盖所有的输入，不管输出3.异常分析法： 断电，断网的异常情况（重点关注）4.错误猜测法： 有经验的人对系统做出判断，找到肯能出现错误的地方5.探索性测试： 根据自己的测试经验，尝试性测试系统功能6.因果图7.场景法 流程有序8.状态迁移 状态无序9.正交试验 多条件组合，不予许出现负值10.判定表 多条件组合，可以出现负值11.边界值12.等价类 6.软件生存周期及其模型软件生存周期（Software life cycle）又称为软件生命期，生存期。是指从形成开发软件概念起，所开发的软件使用以后，知道失去使用价值消亡为止的整个过程。一般来说，整个生存周期包括计划（定义）、开发、运行（维护）三个时期，每个时期又划分为若干个阶段。每个阶段有明确的任务。 周期模型（典型的几种）: 瀑布模型：快速原型模型：快速原型模型允许在需求分析阶段对软件的需求进行初步而非完全的分析和定义，快速设计开发出软件系统的原型，该原型向用户展示待开发软件的全部或部分功能和性能；用户对该原型进行测试评定，给出具体改进意见以丰富细化软件需求；开发人员据此对软件进行修改完善，直至用户满意认可之后，进行软件的完整实现及测试、维护。 迭代模型：迭代包括产生产品发布（稳定、可执行的产品版本）的全部开发活动和要使用该发布必需的所有其他外围元素。在某种程度上，开发迭代是一次 完整地经过所有工作流程的过程：需求分析、设计、实施和测试工作流程。实质上，它类似小型的瀑布式项目。RUP认为，所有的阶段都可以细分为迭代。每一次 的迭代都会产生一个可以发布的产品，这个产品是最终产品的一个子集。 生命周期阶段： 软件计划与可行性分析 需求分析 软件设计 编码 软件测试 运行与维护 7.什么是软件测试？软件测试的目的与原则在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。 软件测试的目的： 测试是程序的执行过程，目的在于发现错误 一个成功的测试用例在于发现至今未发现的错误 一个成功的测试是发现了至今未发现的错误的测试 确保产品完成了它所承诺或公布的功能，并且用户可以访问到的功能都有明确的书面说明。 确保产品满足性能和效率的要求 确保产品是健壮的和适应用户环境的 软件测试的原则： 测试用例中一个必须部分是对预期输出或接过进行定义 程序员应避免测试自己编写的程序 编写软件的组织不应当测试自己编写的软件 应当彻底检查每个测试的执行结果 测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和未预料到的输入情况 检擦程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的” 应避免测试用例用后即弃，除非软件本身就是个一次性的软件 计划测试工作时不应默许假定不会发现错误 程序某部分存在更多错误的可能性，与该部分已经发现错误的数量成正比 软件测试是一项极富创造性，极具智力的挑战性的工作。 8.软件的安全性应从哪几个方面去测试软件安全性测试包括程序、数据库安全性测试。根据系统安全指标不同测试策略也不同。用户认证安全的测试要考虑问题： 明确区分系统中不同用户权限 、系统中会不会出现用户冲突 、系统会不会因用户的权限的改变造成混乱 、用户登陆密码是否是可见、可复制 、是否可以通过绝对途径登陆系统（拷贝用户登陆后的链接直接进入系统）、用户退出系统后是否删除了所有鉴权标记，是否可以使用后退键而不通过输入口令进入 系统 、系统网络安全的测试要考虑问题 、测试采取的防护措施是否正确装配好，有关系统的补丁是否打上 、模拟非授权攻击，看防护系统是否坚固 、采用成熟的网络漏洞检查工具检查系统相关漏洞（即用最专业的黑客攻击工具攻击试一下，现在最常用的是 NBSI 系列和 IPhacker IP ） 、采用各种木马检查工具检查系统木马情况 、采用各种防外挂工具检查系统各组程序的外挂漏洞. 数据库安全考虑问题： 系统数据是否机密（比如对银行系统，这一点就特别重要，一般的网站就没有太高要求）、系统数据的完整性（我刚刚结束的企业实名核查服务系统中就曾存在数据 的不完整，对于这个系统的功能实现有了障碍） 、系统数据可管理性 、系统数据的独立性 、系统数据可备份和恢复能力（数据备份是否完整，可否恢复，恢复是否可以完整） 9.什么是测试用例 什么是测试脚本 两者的关系是什么？为实施测试而向被测试系统提供的输入数据、操作或各种环境设置以及期望结果的一个特定的集合。 测试脚本是为了进行自动化测试而编写的脚本。 测试脚本的编写必须对应相应的测试用例。 10.什么是静态测试、动态测试、黑盒测试、白盒测试、α测试 β测试？静态测试是不运行程序本身而寻找程序代码中可能存在的错误或评估程序代码的过程。 动态测试是实际运行被测程序，输入相应的测试实例，检查运行结果与预期结果的差异，判定执行结果是否符合要求，从而检验程序的正确性、可靠性和有效性，并分析系统运行效率和健壮性等性能。 黑盒测试一般用来确认软件功能的正确性和可操作性,目的是检测软件的各个功能是否能得以实现,把被测试的程序当作一个黑盒,不考虑其内部结构,在知道该程序的输入和输出之间的关系或程序功能的情况下,依靠软件规格说明书来确定测试用例和推断测试结果的正确性。 白盒测试根据软件内部的逻辑结构分析来进行测试,是基于代码的测试，测试人员通过阅读程序代码或者通过使用开发工具中的单步调试来判断软件的质量，一般黑盒测试由项目经理在程序员开发中来实现。 α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。 β测试是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。 11.软件产品质量特性是什么?功能性：适应性、准确性、互操作性、依从性、安全性。 可靠性：成熟性、容错性、易恢复性。 可使用性：易理解性、易学习性、易操作性。 效率：时间特性、资源特性。 可维护性：易分析性、易变更性、稳定性、易测试性。 可移植性：适应性、易安装性、遵循性、易替换性 12.软件测试分为几个阶段 各阶段的测试策略和要求是什么?和开发过程相对应，测试过程会依次经历单元测试、集成测试、系统测试、验收测试 四个主要阶段：单元测试：单元测试是针对软件设计的最小单位––程序模块甚至代码段进行正确性检验的测试工作，通常由开发人员进行。 集成测试：集成测试是将模块按照设计要求组装起来进行测试，主要目的是发现与接口有关的问题。由于在产品提交到测试部门前，产品开发小组都要进行联合调试，因此在大部分企业中集成测试是由开发人员来完成的。 系统测试：系统测试是在集成测试通过后进行的，目的是充分运行系统，验证各子系统是否都能正常工作并完成设计的要求。它主要由测试部门进行，是测试部门最大最重要的一个测试，对产品的质量有重大的影响。 验收测试：验收测试以需求阶段的《需求规格说明书》为验收标准，测试时要求模拟实际用户的运行环境。对于实际项目可以和客户共同进行，对于产品来说就是最后一次的系统测试。测试内容为对功能模块的全面测试，尤其要进行文档测试。 单元测试测试策略：自顶向下的单元测试策略：比孤立单元测试的成本高很多，不是单元测试的一个好的选择。 自底向上的单元测试策略：比较合理的单元测试策略，但测试周期较长。 孤立的单元测试策略：最好的单元测试策略。 集成测试的测试策略：大爆炸集成：适应于一个维护型项目或被测试系统较小 自顶向下集成：适应于产品控制结构比较清晰和稳定；高层接口变化较小；底层接口未定义或经常可能被修改；产口控制组件具有较大的技术风险，需要尽早被验证；希望尽早能看到产品的系统功能行为。 自底向上集成：适应于底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。 基于进度的集成 优点：具有较高的并行度；能够有效缩短项目的开发进度。 缺点：桩和驱动工作量较大；有些接口测试不充分；有些测试重复和浪费。 系统测试的测试策略：数据和数据库完整性测试；功能测试；用户界面测试；性能评测；负载测试；强度测试；容量测试；安全性和访问控制测试；故障转移和恢复测试；配置测试；安装测试；加密测试；可用性测试；版本验证测试；文档测试 13.软件测试各个阶段通常完成什么工作？单元测试阶段：各独立单元模块在与系统地其他部分相隔离的情况下进行测试，单元测试针对每一个程序模块进行正确性校验，检查各个程序模块是否正确地实现了规定的功能。生成单元测试报告，提交缺陷报告。 集成测试阶段：集成测试是在单元测试的基础上，测试在将所有的软件单元按照概要设计规格说明的要求组装成模块、子系统或系统的过程中各部分工作是否达到或实现相应技术指标及要求的活动。该阶段生成集成测试报告，提交缺陷报告。 系统测试阶段：将通过确认测试的软件，作为整个给予计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行环境下，对计算机系统进行全面的功能覆盖。该阶段需要提交测试总结和缺陷报告。 14.测试人员在软件开发过程中的任务是什么？1、尽可能早的找出系统中的Bug； 2、避免软件开发过程中缺陷的出现； 3、衡量软件的品质，保证系统的质量； 4、关注用户的需求，并保证系统符合用户需求。 总的目标是：确保软件的质量。 15.一条软件缺陷（或者叫Bug）记录都包含了哪些内容？一条Bug记录最基本应包含： bug编号； bug严重级别，优先级； bug产生的模块； 首先要有bug摘要，阐述bug大体的内容； bug对应的版本； bug详细现象描述，包括一些截图、录像….等等； bug出现时的测试环境，产生的条件即对应操作步骤； 16.黑盒测试和白盒测试的优缺点黑盒测试的优点有：比较简单，不需要了解程序内部的代码及实现；与软件的内部实现无关； 从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题；基于软件开发文档，所以也能知道软件实现了文档中的哪些功能；在做软件自动化测试时较为方便。 黑盒测试的缺点有：不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%；自动化测试的复用性较低。 白盒测试的优点有：帮助软件测试人员增大代码的覆盖率，提高代码的质量，发现代码中隐藏的问题。 白盒测试的缺点有：程序运行会有很多不同的路径，不可能测试所有的运行路径；测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；系统庞大时，测试开销会非常大。 17.如何测试一个纸杯？功能度：用水杯装水看漏不漏；水能不能被喝到 安全性：杯子有没有毒或细菌 可靠性：杯子从不同高度落下的损坏程度 可移植性：杯子在不同的地方、温度等环境下是否都可以正常使用 兼容性：杯子是否能够容纳果汁、白水、酒精、汽油等 易用性：杯子是否烫手、是否有防滑措施、是否方便饮用 用户文档：使用手册是否对杯子的用法、限制、使用条件等有详细描述 疲劳测试：将杯子盛上水（案例一）放24小时检查泄漏时间和情况；盛上汽油（案例二）放24小时检查泄漏时间和情况等 压力测试：用根针并在针上面不断加重量，看压强多大时会穿透 18.详细的描述一个测试活动完整的过程1.项目经理通过和客户的交流，完成需求文档，由开发人员和测试人员共同完成需求文档的评审，评审的内容包括：需求描述不清楚的地方和可能有明显冲突或者无法实现的功能的地方。项目经理通过综合开发人员，测试人员以及客户的意见，完成项目计划。然后SQA(软件质量保证)进入项目，开始进行统计和跟踪。 2.开发人员根据需求文档完成需求分析文档，测试人员进行评审，评审的主要内容包括是否有遗漏或双方理解不同的地方。测试人员完成测试计划文档，测试计划包括的内容上面有描述。 3.测试人员根据修改好的需求分析文档开始写测试用例，同时开发人员完成概要设计文档，详细设计文档。此两份文档成为测试人员撰写测试用例的补充材料。 4.测试用例完成后，测试和开发需要进行评审。 5.测试人员搭建环境 6.开发人员提交第一个版本，可能存在未完成功能，需要说明。测试人员进行测试，发现BUG后提交给BugZilla。 7.开发提交第二个版本，包括Bug Fix以及增加了部分功能，测试人员进行测试。 8.重复上面的工作，一般是3-4个版本后BUG数量减少，达到出货的要求。 9.如果有客户反馈的问题，需要测试人员协助重现并重新测试。 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/96853248","categories":[{"name":"总结","slug":"总结","permalink":"https://hellotaogang.github.io/categories/总结/"}],"tags":[{"name":"测试流程","slug":"测试流程","permalink":"https://hellotaogang.github.io/tags/测试流程/"},{"name":"用例特性","slug":"用例特性","permalink":"https://hellotaogang.github.io/tags/用例特性/"},{"name":"用例要素","slug":"用例要素","permalink":"https://hellotaogang.github.io/tags/用例要素/"},{"name":"用例步骤","slug":"用例步骤","permalink":"https://hellotaogang.github.io/tags/用例步骤/"},{"name":"用例方法","slug":"用例方法","permalink":"https://hellotaogang.github.io/tags/用例方法/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"文章加密测试","slug":"第一篇博客","date":"2019-10-09T13:41:11.000Z","updated":"2019-10-31T13:08:03.330Z","comments":true,"path":"2019/10/09/第一篇博客/","link":"","permalink":"https://hellotaogang.github.io/2019/10/09/第一篇博客/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('别搞了，你破解不了的'); const txt = document.getElementById('enc_content').innerHTML; // alert(txt,\"1\") // alert(pwd,\"2\") // alert(onError,\"3\") let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); if(plaintext == \"\"){ document.getElementById(\"enc_pwd_input\").value=\"\"; document.getElementById(\"enc_error\").innerHTML = \"密码错误!\"; return } // alert(plaintext) } catch(err) { if(onError) { // alert(onError,\"4\") // alert(err,\"5\") onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX186WqIJXjIA/Fdju241k9/es+QPkjQSeVogOhYrSqAL2VGXBzFyoSbz5nyXugEI3m+DshzH0ggRSVZYrsrtGopPWEdC7l5Rhce3G0JM1IyYaPBVjyuM7poqkdLkfFMlhSUFr4DnG++U0GODWCBmjRMzFBdludWFDUjPxqtyWQOc4ASdn/F8aWq4 var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"密码错误!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[],"tags":[],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}}]}