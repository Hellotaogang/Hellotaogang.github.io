{"meta":{"title":"TG'S BLOG","subtitle":null,"description":null,"author":"cdtaogang","url":"https://hellotaogang.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-14T03:33:22.648Z","updated":"2019-11-14T03:33:22.648Z","comments":true,"path":"404.html","permalink":"https://hellotaogang.github.io/404.html","excerpt":"","text":"wow~这个页面被外星人抢走了~ 您可以去首页 或 下方评论"},{"title":"所有分类","date":"2019-10-13T13:04:34.003Z","updated":"2019-10-13T13:04:34.003Z","comments":true,"path":"categories/index.html","permalink":"https://hellotaogang.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-10-14T05:23:33.279Z","updated":"2019-10-14T05:23:33.279Z","comments":true,"path":"archives/index.html","permalink":"https://hellotaogang.github.io/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-10-13T13:02:11.746Z","updated":"2019-10-13T13:02:11.746Z","comments":true,"path":"tags/index.html","permalink":"https://hellotaogang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python接口自动化测试框架实战开发（二）","slug":"Python接口自动化测试框架实战开发（二）","date":"2019-11-16T10:15:05.180Z","updated":"2019-11-16T11:58:17.082Z","comments":true,"path":"2019/11/16/Python接口自动化测试框架实战开发（二）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/16/Python接口自动化测试框架实战开发（二）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 七丶接口自动化框架设计到开发 八丶持续集成 九丶获取cookie及请求处理","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 七丶接口自动化框架设计到开发 八丶持续集成 九丶获取cookie及请求处理 七丶接口自动化框架设计到开发14.数据依赖问题从设计思路开始 说明：博主之前的测试的app不存在数据依赖的接口，所以博主这里下载了苏宁易购，用其下单以及支付两个接口来说明接口数据依赖 在苏宁易购上选择一款手机，点击立即购买后选择购买的内存以及颜色后，点击确定跳转到订单页面，如下图所示 通过fiddler抓取下单的接口，该接口返回的数据中可以看出cart2No=620200000207514372，该商品的订单编号以及customerNo=7157450907客户编号 在订单页面，点击提交订单，抓取提交订单接口，该接口post请求data数据中的cart2No参数的值，该值就是服务器返回下单接口的数据，这就是所谓的接口数据依赖，需要说明的是，提交订单的接口服务器返回的响应为errorMessage=销售火爆，请稍后再试(E234)，博主测试其他的商品都是提示该错误信息，说明苏定的app此时不能进行购买商品 博主整理了一下整个下单和支付的接口已经请求数据和响应数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 下单request_url = &quot;https://shopping.suning.com/app/addcart/private/quickBuy.do&quot;request_data = &#123; &quot;data&quot;:&#123;&quot;cartHeadInfo&quot;: &#123;&quot;userFlag&quot;:&quot;0&quot;,&quot;directFlag&quot;:&quot;1&quot;,&quot;operationChannel&quot;:&quot;50&quot;, &quot;operationTerminal&quot;:&quot;01&quot;,&quot;operationEquipment&quot;:&quot;02&quot;,&quot;operationUser&quot;:&quot;&quot;, &quot;token&quot;:&quot;0706172998861561345578681_3989FF3858C23E2FE49FB96928935FC51BC2D7E2B00145D19087E1232123D1E2F6AEA7E5A1D95F2B9BC731F5FA0F0B48&quot;, &quot;detect&quot;:&quot;mmds_a_._920c68ed-4fcc-440e-a717-28b23d2a26fd_._YQQQ**1_PaaX*C****4*n**1_Paa0*C**1-D*n******2_*****oy****1_PbTSXH*1J54.o*******1XH**1LD.o*o1_PaA7XH****k.o******Pv****Pdy****1_P0DZcc**iU4Mq**1_P0DZcc**1-DMq**1_PcB_c2**lm4M9**1_PcB_c2**1-DM9******MS****OHy****1_Pc9*ce**GH4YZ**1_Pc9*ce**1kDYZ**1_Pc9*ce**Iq4YZ**1_Pc9*ce**17DYZ**1_Pc9*cH**DU4Yn**1_Pc9*cH**1CDYn**1_Pc9*cc**3m4Yn**1_Pc9*cc**P3DYn**1_Pc9*cd**X0441**1_Pc9*cd**1AD41**1_Pc9*cm**3R44Z**1_Pc9*cZ**1-D4Z**1_Pc9*cZ**Pa44Z**1_Pc9*cZ**1oD4Z*******1cZ**1p44Z**1_Pc9*cZ**ReD4Z**1_Pc9*cZ**1m44Z**1_Pc9*cZ**1lD4Z**1_Pc9*cm**1X44Z**1_Pc9*cm**1eD4Z**1_Pc9*ck**1l44Z**1_Pc9*ck**1lD4Z**1_Pc9*ck**Px44Z**1_Pc9*ck****D4Z**1_Pc9*cL**9m4Y_**1_Pc9*cL**1kDY_*******1cL**1S4Y_**1_Pc9*cL**RkD41**1_Pc9*cJ**18441**1_Pc9*cJ**1iD41**1_Pc9*cJ**1m441**1_Pc9*cJ**1kD41**1_Pc9*ch*1Sx441**1_Pc9*ch**1aD41**1_P0jS*yPUup4*4**1_P0jS*y**1_D*4******Pv*****ty****1_P0DZch*1WE4Ob**1_P0DZch**1xDOb**1_PcB_c0**fx4M0**1_PcB_c0**1oDM0******MS****3Sy********Pv***J*Ey********2_****ixy****1_PbTS*y**UZ4*d**1_PaPK*y**1XD*d******2N*****By****1_PaPi*v**KZ4*n**1_PaPi*v**POD*n******RA*****hy****1_PcVIcd**qr449*******1cd**POD49**1_PbZJM1**if4YK**1_PavoM1**PXDYK******.p****13y****1_PcjG2E*EhR42N*******12E**1oD2N******Pv****POy****1_PaaX*5*.xf4*j**1_Paa0*5**1CD*j******.p*****qy****1_PcjG2a**uo42x*******12a**PeD2x******Pv****1zy****1_P0DZcc**C84O4**1_P0DZcc**P*DO4**1_PcB_cc*P9m42a**1_PcB_cc**P3D2aQQQNvJjJhSpefQQQMMceTs**aYcXDfPGXDsuXcYGMXuCaebCQQQMDYaPPYKtBQQQMDMYuQQQMQQQP*sPYDCXXPDsaQQQMQPQMf46724f27b81204df0356ffa5666c5ec&quot;,&quot;dfpToken&quot;:&quot;TFItvV179MauUij2SsWqz0b18&quot;,&quot;operationStoreCode&quot;:&quot;&quot;,&quot;provinceCode&quot;:&quot;020&quot;,&quot;cityCode&quot;:&quot;021&quot;,&quot;districtCode&quot;:&quot;02111&quot;,&quot;logContent&quot;:&quot;&quot;&#125;, &quot;immediateBuyItems&quot;:[&#123;&quot;itemHeadInfo&quot;:&#123;&quot;itemNo&quot;:&quot;1&quot;,&quot;activityType&quot;:&quot;01&quot;,&quot;activityId&quot;:&quot;&quot;&#125;, &quot;mainCmmdtyInfo&quot;:&#123;&quot;basicInfo&quot;:&#123;&quot;itemNo&quot;:&quot;1&quot;,&quot;cmmdtyCode&quot;:&quot;000000010985369117&quot;,&quot;shopCode&quot;:&quot;0000000000&quot;,&quot;shopAddCode&quot;:&quot;0030001790&quot;,&quot;shopName&quot;:&quot;苏宁自营&quot;,&quot;overSeasFlag&quot;:&quot;&quot;,&quot;cmmdtyQty&quot;:&quot;1&quot;,&quot;serviceStoreCode&quot;:&quot;&quot;,&quot;serviceStoreName&quot;:&quot;&quot;,&quot;commodityType&quot;:&quot;&quot;,&quot;carShopSerWay&quot;:&quot;&quot;&#125;&#125;&#125;], &quot;supportYB&quot;:&quot;1&quot;,&quot;publishDate&quot;:&quot;20190508&quot; &#125;&#125;response_data = &#123;&quot;api&quot;:&quot;ccf.cart1.quickbuy&quot;,&quot;code&quot;:&quot;1&quot;,&quot;data&quot;:&#123;&quot;errorInfos&quot;:[],&quot;result&quot;:&#123;&quot;cart2No&quot;:&quot;620200000207521425&quot;,&quot;customerNo&quot;:&quot;7157450907&quot;,&quot;isSuccess&quot;:&quot;Y&quot;,&quot;reserve&quot;:&quot;&quot;,&quot;safeDps&quot;:&quot;0&quot;,&quot;showRecommend&quot;:&quot;1&quot;&#125;&#125;,&quot;msg&quot;:&quot;&quot;,&quot;v&quot;:&quot;1.0&quot;&#125; cart2No = response_data[&quot;data&quot;][&quot;result&quot;][&quot;cart2No&quot;] # 支付request_url = &quot;https://shopping.suning.com/app/V2/private/confirmOrder.do&quot;request_data = &#123;&quot;cart2No&quot;:cart2No,&quot;salesPerson&quot;:&quot;&quot;,&quot;channelType&quot;:02,&quot;terminalVersion&quot;:MOBILE|02|01|7.7.3|11007,&quot;terminalModel&quot;:HUAWEI|DUK-AL20,&quot;orderMemoJson&quot;:[],&quot;saleChannel&quot;:000000011116457666|9264|121.492479|31.247221|00|06|;000000011039772482|9264|121.492479|31.247221|00|06|,&quot;showGift&quot;:1,&quot;cipher&quot;:&quot;&quot;, &quot;detect&quot;:&quot;mmds_a_._920c68ed-4fcc-440e-a717-28b23d2a26fd_._YQQQ**1_Pc9*cd****DY5**1_Pc9*cd**jx4Y5**1_Pc9*cd**PODY5**1_Pc9*cd**9T4Y5**1_Pc9*cd**PMDY5**1_Pc9*cd**X04Y5**1_Pc9*cd**PeDY5**1_Pc9*cd**4q4Y5**1_Pc9*cd**PkDY5**1_Pc9*cd**Dm4Y5**1_Pc9*cd**PkDY5**1_Pc9*cd**E34Y5**1_Pc9*cd**PlDY5**1_P0jS*y*SjM4*X**1_P0jS*y**1ND*X******Pv*****ty****1_P0DZcH*11i42u**1_P0DZcH**1_D2u**1_PcB_cD**mY42A**1_PcB_cD**1oD2A******MS****Muy****1_P0jS*_**pG4*m**1_P0jS*_**1SD*m******Pv*****qy****1_P0DZci*3bJ4MK**1_P0DZci**1-DMK**1_PcB_c**YjB4RB**1_PcB_c***1oDRB******MS****MPy****1_Pc9*ct*1To4YC**1_Pc9*ct**1CDYC**1_P0jS*C1sPt4*J**1_P0jS*C**1CD*J******Pv*****yy****1_PaaX*C**E-4*n**1_Paa0*C**1-D*n******2_*****oy****1_PbTSXH*1J54.o*******1XH**1LD.o*o1_PaA7XH****k.o******Pv****Pdy****1_P0DZcc**iU4Mq**1_P0DZcc**1-DMq**1_PcB_c2**lm4M9**1_PcB_c2**1-DM9******MS****OHy****1_Pc9*ce**GH4YZ**1_Pc9*ce**1kDYZ**1_Pc9*ce**Iq4YZ**1_Pc9*ce**17DYZ**1_Pc9*cH**DU4Yn**1_Pc9*cH**1CDYn**1_Pc9*cc**3m4Yn**1_Pc9*cc**P3DYn**1_Pc9*cd**X0441**1_Pc9*cd**1AD41**1_Pc9*cm**3R44Z**1_Pc9*cZ**1-D4Z**1_Pc9*cZ**Pa44Z**1_Pc9*cZ**1oD4Z*******1cZ**1p44Z**1_Pc9*cZ**ReD4Z**1_Pc9*cZ**1m44Z**1_Pc9*cZ**1lD4Z**1_Pc9*cm**1X44Z**1_Pc9*cm**1eD4Z**1_Pc9*ck**1l44Z**1_Pc9*ck**1lD4Z**1_Pc9*ck**Px44Z**1_Pc9*ck****D4Z**1_Pc9*cL**9m4Y_**1_Pc9*cL**1kDY_*******1cL**1S4Y_**1_Pc9*cL**RkD41**1_Pc9*cJ**18441**1_Pc9*cJ**1iD41**1_Pc9*cJ**1m441**1_Pc9*cJ**1kD41**1_Pc9*ch*1Sx441**1_Pc9*ch**1aD41QQQNvJjJhSpefQQQMMceTs**aYcXDfPGXDsuXcYGMXuCaebCQQQsaCMDCXuDYQQQMDMYuQQQMQQQP*sPYDCMMusCuQQQMQPQM73a04a9cdb50e2faa2bf8d79252434e3&quot;,&quot;dfpToken&quot;:&quot;TFItvV179MauUij2SsWqz0b18&quot;,&quot;deviceNo&quot;:&quot;868334782216554&quot;,&quot;specDesc&quot;:[&#123;&quot;itemNo&quot;:&quot;620200000344251973&quot;,&quot;pictureLink&quot;:&quot;\\/\\/imgservice.suning.cn\\/uimg1\\/b2c\\/image\\/5lHDNQYOPSu5tQWQt9JdHA.jpg&quot;,&quot;specInfos&quot;:[&#123;&quot;specTypeName&quot;:&quot;颜色&quot;,&quot;specContent&quot;:&quot;秘境黑&quot;&#125;,&#123;&quot;specTypeName&quot;:&quot;规格&quot;,&quot;specContent&quot;:&quot;6GB+64GB&quot;&#125;]&#125;],&quot;splitFlag&quot;:01,&quot;publishDate&quot;: 20190508,&#125; response_data = &#123;&quot;api&quot;:&quot;ccf.cart2.submitOrder&quot;,&quot;code&quot;:&quot;1&quot;,&quot;data&quot;:&#123;&quot;cardInfoss&quot;:[],&quot;cartHeadInfo&quot;:&#123;&quot;alipayWakeFlag&quot;:&quot;1&quot;,&quot;cart2No&quot;:&quot;&quot;,&quot;customerNo&quot;:&quot;&quot;,&quot;dfpTokenStatus&quot;:&quot;&quot;,&quot;isSuccess&quot;:&quot;N&quot;,&quot;miniCartRouteSwitch&quot;:&quot;&quot;,&quot;payStatus&quot;:&quot;&quot;,&quot;toastTime&quot;:&quot;5&quot;&#125;,&quot;errorInfos&quot;:[&#123;&quot;cmmdtyPrice&quot;:&quot;&quot;,&quot;dareType&quot;:&quot;&quot;,&quot;earlyPrice&quot;:&quot;&quot;,&quot;errorCode&quot;:&quot;CSC-71-0002&quot;,&quot;errorMessage&quot;:&quot;销售火爆，请稍后再试(E234)&quot;,&quot;itemNo&quot;:&quot;0&quot;,&quot;itemType&quot;:&quot;0&quot;,&quot;needImageCode&quot;:&quot;&quot;,&quot;ticket&quot;:&quot;&quot;&#125;],&quot;orderItems&quot;:[],&quot;voucherInfoss&quot;:[]&#125;,&quot;msg&quot;:&quot;&quot;,&quot;v&quot;:&quot;1.0&quot;&#125; 接下来博主就需要将框架最开始的基础信息进行变更，在excel表中中添加一列header数据，因为订单先关的接口需要传递header来验证登录状态 就需要在data_conf.py文件中进行添加获取该列的索引值 1234567891011121314151617class global_var: id = '0' # id module = '1' # 模块 url = '2' # url run = '3' # 是否运行 request_type = '4' # 请求类型 request_header = '5' # 是否携带header case_depend = '6' # case依赖 response_data_depend = '7' # 依赖的返回数据 data_depend = '8' # 数据依赖 request_header_data = '9' # header值 request_data = '10' # 请求数据 expect_result = '11' # 预期结果 reality_result = '12' # 实际结果 def get_request_header_data(): return global_var.request_header_data 在data_get.py数据获取模块中需要添加两个方法来分别获取excel表header列的数据以及操作获取json表中的键为header值的请求数据data和请求头数据header 123456789101112131415def get_request_header_data(self, x): \"\"\"获取excel表中的header的数据\"\"\" y = int(data_conf.get_request_header_data()) header_data = self.op_excel.get_cell_value(x, y) # print(\"header_data\", header_data) if header_data == '': return None return header_data def get_data_for_header(self, x): \"\"\"通过在excel表中获取的关键字数据到json表中获取对应的数据\"\"\" op_header = operationJson() header_data = op_header.get_key_words(self.get_request_header_data(x)) # print(\"header_data\", header_data) return header_data 还需要修改启动文件中的header的获取调用方法 1234567891011121314151617for row_count in range(1, row_counts): # print(row_count) 1,2,3,4 url = self.data.get_request_url(row_count) # y行不变遍历获取x列的请求地址 method = self.data.get_request_method(row_count) # y行不变遍历获取x列的请求方式 is_run = self.data.get_is_run(row_count) # y行不变遍历获取x列的是否运行 data = self.data.get_data_for_json(row_count) # y行不变遍历获取x列的请求数据，这里面时三次调用，依次分别是get_data_for_json丶get_key_words丶get_request_data # header = self.data.get_is_header(row_count) #行不变遍历获取x列获取header header = self.data.get_data_for_header(row_count) module = self.data.get_module_name(row_count) #行不变遍历获取x列获取模块名 expect = self.data.get_expect_data(row_count) #行不变遍历获取x列获取预期结果 print(\"模块名:\", module) print('请求地址:', url) print('请求方式:', method) print('是否运行:', is_run) print('请求数据:', data) print('请求头:', header) print('预期结果:', expect) 在json文档中增加excel表中的cart_data请求数据以及cart_header数据 最后运行启动文件run_test查看获取excel文档以及json文档数据是否正确 整体测试接口，首先在excel表中填写预期结果 因为该接口与之前接口不属于一个服务器，所以返回的响应数据不一样，所以需要修改common_util模块中修改判断 123456789101112131415# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/21 18:43'import json class CommonUtil(object): def is_contains(self, expect, reality): flag = None reality = json.loads(reality) expect = json.loads(expect) if expect['isSuccess'] == reality['data']['result']['isSuccess']: flag = True else: flag = False return flag 运行启动测试文件，结果为测试成功，并将数据实际结果数据成功写入到excel实际结果列中 15.数据依赖问题方法封装之通过case_id获取case数据 在excel测试数据中case依赖丶依赖的返回数据丶数据依赖这三个字段是根据当前的接口的请求数据中是否需要从其他接口的响应中获取，根据上一步中的分析，进行如下填写 服务器给下单接口返回的响应数据中的cartNo与支付接口请求数据中的cartNo一致，具体看图就明白了，首先查看服务器给下单接口返回的响应数据 再查看支付接口向服务器发送的请求数据 在op_excel.py中定义如下方法，根据传入的case_id值来获取excel表字段的行数据 1234567891011121314151617181920212223242526272829303132333435def get_x_values(self, case_id): \"\"\"通过获取到的x坐标num值来获取到对应的内容\"\"\" x_num = self.get_x_nums(case_id) x_datas = self.get_x_data(x_num) print(x_datas) return x_datas def get_x_nums(self, case_id): \"\"\"根据传入的case_id的值来获取在表格x坐标的数值x=num\"\"\" num = 0 x_datas = self.get_y_data() for x_data in x_datas: if case_id in x_data: return num num += 1 def get_x_data(self, x=None): \"\"\"获取表格某一行所有数据\"\"\" tables = self.data if x is not None: x_data = tables.row_values(x) else: x_data = tables.row_values(1) # print(x_data) return x_data def get_y_data(self, y=None): \"\"\"获取表格某一列数据\"\"\" if y is not None: y_data = self.data.col_values(y) else: y_data = self.data.col_values(0) # print(y_data) return y_data 调用以上方法测试获取case_id为suning-02所在的行所有数据 16.数据依赖问题之根据规则提取响应数据 在data目录下新建一个handle_data_dependent.py文件用于处理数据依赖，说白了就是获取到传入的case_id所在的行的所有数据，再从该数据中将数据依赖字段cart2No的值提取出来即可，需要说明的一点是，之前博主测试使用的是看书吧app接口所以没有去调用base/run_method模块中的run_main方法向接口发送数据，而是直接在方法中使用requests模块进行数据的发送 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/24 17:07'from utils.op_excel import operationExcelfrom data.data_get import getDataimport requests, json class HandleData(object): def __init__(self, case_id): self.case_id = case_id self.op_excel = operationExcel() self.data = getData() def get_case_line_data(self): \"\"\"获取case所在行数据\"\"\" x_datas = self.op_excel.get_x_values(self.case_id) # ['suning-01', '下单', 'https://shopping.suning.com/app/addcart/private/quickBuy.do', 'yes', 'post', 'yes', '', '', '', 'cart_header', 'cart_data', '&#123;\"isSuccess\":\"Y\"&#125;', 'pass'] return x_datas def run_dependent_case(self): \"\"\"执行获取case所在的整行数据\"\"\" # run = RunMain() x = self.op_excel.get_x_nums(self.case_id) request_header = self.data.get_data_for_header(x) request_data = self.data.get_data_for_json(x) request_url = self.data.get_request_url(x) request_method = self.data.get_request_method(x) is_run = self.data.get_is_run(x) module = self.data.get_module_name(x) expect = self.data.get_expect_data(x) if is_run: res = requests.post(url=request_url, data=request_data, headers=request_header, verify=False) print(res.text) print(json.loads(res.text)['data']['result']['cart2No']) HandleData(\"suning-01\").run_dependent_case() 运行以上代码，手动传入case_id以及依赖数据的key，成功的提取出数据依赖字段数据 对上一部中的返回的响应数据进行关键字数据的提取，将提取代码进行封装，首先是调用data_get模块中的get_dependent_key方法获取依赖的返回数据中的key，也就是excel表中的value值，然后再调用run_dependent_case方法获取返回的响应数据，通过依赖的返回数据中的key，来提取响应数据中的value值，这里需要安装jsonpath_rw，通过其parse方法来定义path规则，通过该规则找到返回的响应数据中的key的数据集，通过列表生成式将第0个元素进行返回 1234567def get_data_for_key(self, x): \"\"\"获取依赖返回数据中的key\"\"\" dependent_data = self.data.get_dependent_key(x) response_data = self.run_dependent_case() json_rule = parse(dependent_data) madle = json_rule.find(response_data) return [m.value for m in madle][0] 在excel表中依赖返回数据中添加的返回响应的关键字必须是以这种格式进行层级关系的填写 17.数据依赖问题之依赖结构构建 在启动文件中run_test模块中，在run方法for循环中，首先需要获取excel表中的data_dependent数据依赖字段的值，然后再获取到case依赖的值，要获取case依赖的值，还需要到data_get模块中定义以下方法进行获取 12345678def get_case_dependent(self, x): \"\"\"获取case依赖的值\"\"\" y = int(data_conf.get_case_depend()) case_dependent = self.op_excel.get_cell_value(x, y) if case_dependent == '': return None else: return case_dependent 回到run_test模块中的for循环中进行获取，判断当excel表中的数据依赖字段的值不为空是，则通过实例化HandleData，并调用类中的核心方法get_data_for_key，在该核心方法中又调用run_dependent_case向接口发送请求数据，并将服务器返回的数据返回回来，在get_data_for_key中使用jsonpath_rw中的parse方法进行建立path规则，最终提取到我们想要的返回数据中的cart2No键的值，进行打印测试 123456789101112131415161718192021def run(self): res = None row_counts = self.data.get_case_lines() # 获取excel表格行数 # print(row_counts) 5 for row_count in range(1, row_counts): # print(row_count) 1,2,3,4 url = self.data.get_request_url(row_count) # y行不变遍历获取x列的请求地址 method = self.data.get_request_method(row_count) # y行不变遍历获取x列的请求方式 is_run = self.data.get_is_run(row_count) # y行不变遍历获取x列的是否运行 data = self.data.get_data_for_json(row_count) # y行不变遍历获取x列的请求数据，这里面时三次调用，依次分别是get_data_for_json丶get_key_words丶get_request_data # header = self.data.get_is_header(row_count) #行不变遍历获取x列获取header header = self.data.get_data_for_header(row_count) module = self.data.get_module_name(row_count) #行不变遍历获取x列获取模块名 expect = self.data.get_expect_data(row_count) #行不变遍历获取x列获取预期结果 data_dependent = self.data.get_data_dependent(row_count) # 数据依赖 case_dependent = self.data.get_case_dependent(row_count) # case依赖 if data_dependent != None: # 当数据依赖不为空时，则实例化handle_data_dependent模块中的HandleData类，并调用类中的get_data_for_key方法将需要的cart2No数据获取到 self.hd = HandleData(case_dependent) dependent_response_data = self.hd.get_data_for_key(row_count) print(dependent_response_data) 将不需要的打印数据进行注释掉后，运行启动文件成功打印出dependent_response_data数据，即就是服务器响应数据中的cart2No键的值 为了进一步的测试，需要在excel表中填写下单接口的请求数据json的key值，博主这里命令为cart_data2 然后在json文件中，需要定义名为cart_data2的json数据，请留意请求数据中的cart2No得值，因为在接下来的测试代码中会自动的去跟新cart2No的值 经过测试成功打印出接口数据依赖的key的值，说明在excel表中填写的依赖返回数据的格式是没问题的成功的被jsonpath_rw进行匹配并获取出，接下来则需要将获取到的cart2No的值赋给请求数据data中的cart2No键的值，而cart2No键就是通过get_data_dependent方法获取到excel表中数据依赖字段的值，最后通过requests模块post请求向目标接口发送请求数据 重点：大家看到这里应该也没啥不明白的吧，如果有请不要着急，博主把整个实现过程讲一下，代码写到这里其实分为两个部分，第一个部分就是获取case_id也就是存在依赖字段的case中的case依赖的值，根据该值来获取其在excel表中的x坐标列，因为y坐标是固定的，所以就可以获取依赖的case的所有行数据，紧接着就可以发送接口数据获的服务器返回的响应数据了，然后在对服务器返回的响应数据中通过jsonpath_rw模块中的方法提取我们想要的cart2No字段的值；第二部分就是在启动文件run_test模块中首先去获取依赖的数据以及case依赖数据，根据依赖数据不为空时去调用第一部分的核心代码来获取cart2No得值，然后将这个值赋值给请求数据data，也就是excel表中cart_data2键的值，可能有些人有点晕，为啥在run_test启动文件中只向存在依赖关系的case发送请求呢，那是因为做了判断了；为了演示出两个部分发送的请求所需的参数以及对应在excel表中的字段数据，博主在handle_data_dependent模块中也进行了打印 现在运行run_test启动文件，查看结果完全没问题，之前特意说明了json文件中的cart_data2的数据中的cart2No的值，现在运行代码后，将下单接口返回的响应数据中的cart2No的值赋给请求数据data，所以这里打印出来的请求数据的值的cart2No键的值与下单接口的响应数据中的值一致，需要说明的是支付的接口是测试失败，返回的响应数据中的错误信息为”errorMessage”:”销售火爆，请稍后再试(E234)” 因为在APP购买中也是提示此错误，这是其接口关闭或者不能在app苏宁易购中购买 18.数据依赖问题之流程实施 上一步中已经成功的提取cart2No得值以及向支付接口发送数据，现在则需要判断返回的响应数据中的isSuccess字段的值是否为Y，并将最终的测试结果写入到excel表实际结果字段中去，那么首先需要在excel表中填写预测结果 从下单和支付两个接口返回的响应数据中看出isSuccess字段存在不一样的层级，所以在common_util模块中需要添加支付接口返回响应数据的字典层级判断来获取正确为的isSuccess字段的值，因为苏宁易购app这边cookie需要经常更换，所以博主添加了异常处理 12345678910111213141516171819202122232425# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/21 18:43'import json class CommonUtil(object): def is_contains(self, expect, reality): flag = None try: reality = json.loads(reality) except Exception as e: print(\"Cookie已过期，请及时更新!!!\") return expect = json.loads(expect) if 'result' in reality['data']: if expect['isSuccess'] == reality['data']['result']['isSuccess']: flag = True else: flag = False else: if expect['isSuccess'] == reality['data']['cartHeadInfo']['isSuccess']: flag = True else: flag = False return flag 因为博主这里想要两个接口的测试结果并将数据写入到excel实际结果中去，所以需要分别在handle_data_dependent模块以及run_test模块中进行调用common_util模块中的is_contains，并根据返回的结果将数据写入到excel实际结果字段中去 run_test模块中 handle_data_dependent模块中 测试前首先需要关闭excel表，然后运行代码成功将正确的测试数据结果写入到excel对应字段中 19.case运行结果统计 博主在handle_data_dependent模块中定义一个方法print_test_data用于打印出我们想要的测试数据，代码很简单就不说了 1234567891011121314151617181920212223242526272829303132class HandleData(object): def __init__(self, case_id): self.case_id = case_id self.op_excel = operationExcel() self.data = getData() self.com_util = CommonUtil() self.pass_count = [] self.fail_count = [] def print_test_data(self,url,method,module,is_run,data,header,expect,res,x): \"\"\"打印测试数据\"\"\" print(\"模块名:\", module) print('请求地址:', url) print('请求方式:', method) print('是否运行:', is_run) print('请求数据:', data) print('请求头:', header) print('预期结果:', expect) print(res.text) if self.com_util.is_contains(expect, res.text): print(\"测试通过\") print(\"*\" * 60 + \"分割线\" + \"*\" * 60) self.data.write_reality_data(x, 'pass') self.pass_count.append(x) else: print(\"测试失败\") print(\"*\" * 60 + \"分割线\" + \"*\" * 60) self.data.write_reality_data(x, 'fail') self.fail_count.append(x) return self.pass_count, self.fail_count 然后在run_dependent_case方法中去调用以上定义的打印测试数据的方法 以及在run_test模块中调用print_test_data方法，并接收返回值，最后打印出统计的case测试结果数据 运行启动文件run_test，成功打印出case成功失败以及测试case总量数 20.构建发送邮件服务 说明：博主这里使用163邮箱POP3/SMTP服务向qq邮箱发送邮件 首先需要进入163个人邮箱中，开启POP3/SMTP服务 然后开启客户端授权密码并进行设置，改授权密码需要记住，用于第三方也就是我们代码中需要填写的password 紧接着在项目utils工具包下创建send_email.py文件，在该文件中编写代码登录连接163邮箱的POP3/SMTP服务向目标邮箱发送指定主题以及内容的邮件 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/25 18:05'import smtplibfrom email.mime.text import MIMEText class SendEmail(object): global send_user global pwd global email_host def send_mail(self,user_list,content,sub): \"\"\" :param user_list: 收件人列表 :param content: 邮件内容 :param sub: 主题 :return: \"\"\" send_user = \"cdtaogang@163.com\" password = \"设置的授权码\" email_host = \"smtp.163.com\" sender_msg = \"cdtaogang\"+\"&lt;\"+send_user+\"&gt;\" message = MIMEText(content, _subtype='plain', _charset='utf-8') message['Subject'] = sub message['From'] = sender_msg message['To'] = \";\".join(user_list) server = smtplib.SMTP() server.connect(email_host) server.login(send_user,password) server.sendmail(sender_msg,user_list,message.as_string()) server.close() if __name__ == '__main__': user_list = ['2384005622@qq.com'] sub = \"测试邮件\" content = \"这是用来测试的邮件!!!\" SendEmail().send_mail(user_list,content,sub) 然后运行以上代码，登录2384005622@qq.com邮箱，查看是否收到邮件，并核实邮件内容和主题是否与设置的一致 21.结果统计+报告通知 首先在send_email模块中定义send_main方法，该方法用于自动化测试结果的统计 1234567891011def send_main(self, pass_num, fail_num): pass_num = float(pass_num) fail_num = float(fail_num) count_nums = pass_num + fail_num # 计算通过率 pass_result = \"%.2f%%\" %(pass_num/count_nums*100) fail_result = \"%.2f%%\" %(fail_num/count_nums*100) user_list = ['2384005622@qq.com'] sub = \"接口自动化测试报告\" content = \"本次自动化测试一共运行的接口数为:%d个, 通过个数为:%d个, 失败个数为:%d个, 通过率为:%s, 失败率为:%s\" %(count_nums,pass_num,fail_num,pass_result,fail_result) print(content) 调用send_main方法，测试打印的content内容数据是否正确 然后在send_main中调用send_mail方法，将自动化测试报告发送到目标邮箱中 查看邮箱邮件，成功将自动化测试报告发送至邮箱中 最后只需要在启动文件run_test中，实例化SendEmail对象，调用其send_main方法，将pass_count和fail_count传递即可，这样就可以完成自动化邮件测试报告的发送 测试运行run_test启动文件，将测试结果报告发送至邮箱 八丶持续集成1.持续集成环境搭建 除了在编辑器中直接run运行run_test.py启动文件以外，还可以在windows cmd终端以及Pycharm Terminal终端使用python解释器直接运行，如下图所示 如上图提示找到不到base模块，明明在Pycharm中都能运行成功为啥在终端却提示找不到导入的模块呢，原因是在PyCharm中根据其的path查找路径进行查找，而在编辑器外使用终端进行运行模块时，则是从系统路径中进行查找，解决方法在run_test模块中导入sys模块，将文件所在的目录添加到sys的path路径中去，记得添加你的run_test文件所在的路径 12import syssys.path.append(\"D:/PycharmProjects/testItems\") 再次在终端执行则提示成功 查看邮箱已收到自动化测试报告邮件 下载安装Jenkins，进入其官网下载页面，如下图所示，各种版本的下载，博主这里就不下载windows版本的Jenkins，因为安装太简单，只需要一直下一步，博主下载Generic Java package (.war)版本 没有java环境的朋友就下载windows版本的，下载完成后，在java安装目录下新建Jenkins目录将jenkins.war文件拷贝进入，然后在cmd终端中执行java -jar jenkins.war，如下图所示 然后在浏览器中访问http://127.0.0.1:8080，进入以下页面 在如上页面中路径打开initialAdminPassword文件或者是在cmd运行窗口日志中查看管理员密码 在页面输入管理员密码后，进入如下页面，选择安装推荐的插件 安装插件需要等待 插件安装完成后，即进入如下页面，创建管理员用户 进入到Jenkins的管理页面，点击创建一个item，如下图所示 输入任务名字，选择一个主题风格，然后点击确定，如下图 然后对创建的任务进行配置，首先配置这个任务所在的工作区间位置也就是我们的项目启动文件的目录 构建任务的触发器，设定下一此执行任务的时间 构建运行项目的windows命令，点击保存 保存完后，到如下页面，点击Build Now立即创建，则在Build History构建历史中，生成记录，如下图所示 紧接着点击构建的#5进入控制台输出，查看输出结果成功的执行了python run_test.py 命令，成功的执行了自动化测试启动文件 查看目标邮箱成功收到邮件，说明使用Jenkins工具进行持续化集成项目成功 九丶获取cookie及请求处理1.获取cookie思路分析 如苏宁易购的提交订单接口，是需要用户登录后才能进行的操作，之前获取下单的接口都是在app中进行获取的，博主在这里登录网页版的苏宁官网，抓取下单的接口 然后退出登录，在浏览器中输入以上fiddler抓取的下单接口，服务器就会重定向到登录的接口 在登录页面，输入选择手机号验证码登录，输入手机号以及验证码，点击登录 点击登录成功后，查看fiddler抓取的接口，第一个接口未检查用户的登录状态，服务返回的json数据中的result值为True时，表示用户是已经登录成功的，那么即就会去跳转到之前下单的接口，当然访问检查登录接口时同时也会将下单targetUrl地址携带到请求参数中 重点：从fiddler抓取的接口看来，首先苏宁这边用户下单接口必须是在用户登录成功的状态才能进行的，当博主退出登录后，然后在浏览器中直接访问下单的https://reg.suning.com/smsLogin/checkLoginAccount.do?接口，此时就会触发苏宁的服务器去调用检查登录的令牌来检验用户是否已经登录，如不存在此令牌则会跳转到苏宁的登录接口进行用户登录，点击登录后则会去访问https://passport.suning.com/ids/login?接口，当登录成功后，服务器会返回一个名为 secureToken的cookie回来，并且会跳转到登录请求参数中的referenceURL地址中也就是https://passport.suning.com/ids/login?service=https://shopping.suning.com/auth?targetUrl=https%3A%2F%2Fshopping.suning.com%2Forder.do%3Fcart2No%3D620200000212045085这个地址，要想进入此下单页面则需要在请求的cookie中携带secureToken的值，不然无法进入下单页面，则会跳转到登录页面 2.模拟登录获取cookie请求订单接口 第一步：首先在电脑端退出苏宁易购的登录，然后在浏览器中输入https://shopping.suning.com/order.do?cart2No=620200000212045085，去访问下单接口，此时会跳转到登录页面，然后在登录页面输入用户名密码后，点击登录，最后回到fiddler上查看抓取的苏宁易购登录接口https://passport.suning.com/ids/login，通过查看该接口获取请求header中携带的cookie值，将其拷贝 第二步：在fiddler上获取登录接口请求中的data数据，因为是POST请求嘛所以在WebForms可以查看得到，同样的将其拷贝 第三步：模拟登录，在项目utils工具目录下，创建analog_login.py文件，在文件中使用requests模块向登录接口发送请求获取响应内容，实现模拟登录，该请求需要携带cookie并传递data数据，才能成功的实现苏宁网站的登录 第四步：运行程序，查看苏宁服务器返回的数据，对比与博主在官网登录成功后fiddler工具抓取的登录成功服务器返回的响应数据一致，表示模拟登录成功 第五步：也就是直接打印出返回的响应数据res中的cookie即可，但是苏宁这边的登录安全防护这边做的很好，毕竟是大企业嘛，所以过了一段时间运行代码服务器就会返回验证码的错误代码数据，就好比一个网站你在很短的时间内不停的登录，就会出现安全验证比如验证码就是那种极其恶心拖动验证 第六步：再次重复第一步到第四步的步骤，博主在网页上进行拖动验证通过后，通过抓包工具fiddler可以明显看出，这次登录请求的data数据中明显多了些参数，这些参数就是验证码这块的 第七步：通过很多次的登录尝试，发现请求data中的数据中的iarVerifyCode的值的过期时间很短，所以需要不停的在网页上来进行登录通过fiddler抓取登录接口请求数据中的iarVerifyCode值，这个值的过期时间只有1分钟，所以需要更换代码中的iarVerifyCode值，这样才能进行模拟登录，打印服务返回的数据中的cookie数据 第八步：然后将从https://passport.suning.com/ids/login接口中获取到的响应数据中的cookie数据作为下单接口https://shopping.suning.com/order.do?cart2No=620200000212045085的请求数据中的cookie，来访问下单页面，这样就完成了模拟登录获取cookie请求订单接口 最后一步运行程序，成功的利用登录成功服务器返回的cookie数据，成功的访问下单接口，获取下单页面数据 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/93235627","categories":[{"name":"自动化接口框架开发","slug":"自动化接口框架开发","permalink":"https://hellotaogang.github.io/categories/自动化接口框架开发/"}],"tags":[{"name":"Fiddler","slug":"Fiddler","permalink":"https://hellotaogang.github.io/tags/Fiddler/"},{"name":"Unittest","slug":"Unittest","permalink":"https://hellotaogang.github.io/tags/Unittest/"},{"name":"HTMLTestRunner","slug":"HTMLTestRunner","permalink":"https://hellotaogang.github.io/tags/HTMLTestRunner/"},{"name":"接口自动化测试","slug":"接口自动化测试","permalink":"https://hellotaogang.github.io/tags/接口自动化测试/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Python接口自动化测试框架实战开发（一）","slug":"Python接口自动化测试框架实战开发（一）","date":"2019-11-16T05:37:13.074Z","updated":"2019-11-16T10:08:50.059Z","comments":true,"path":"2019/11/16/Python接口自动化测试框架实战开发（一）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/16/Python接口自动化测试框架实战开发（一）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶叙述 二丶接口基础知识 三丶接口测试工具 四丶Fiddler的使用 五丶unittest使用 六丶mock服务入门到实战 七丶接口自动化框架设计到开发","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶叙述 二丶接口基础知识 三丶接口测试工具 四丶Fiddler的使用 五丶unittest使用 六丶mock服务入门到实战 七丶接口自动化框架设计到开发 一丶叙述1.项目介绍 整个项目分为四个部分：接口基础丶接口开发丶Unittest与接口测试结合以及接口自动化框架从设计到开发 接口基础包括：HTTP接口 / 常见接口 / 接口工具 / 接口基础知识 接口开发：通过Django来开发get/post接口 Unittest与接口测试结合：unittest应用 / 断言 / requests引入 / HTMLTestRunner / case的管理 接口自动化框架从设计到开发：如何设计框架 / 封装工具类 / 重构基类 / 错误调试 / 结果收集以及处理 / 解决数据依赖 / 结果统计及报告发送 项目整体思路：通过对接口数据文档的读写操作，来获取文档中case的所有数据，然后通过requests模块来发送请求获取的响应数据，通过返回的响应数据中的某个标志性字段的值来判断是否测试成功或者失败，最后将测试的结果数据写入到测试文档或者是html页面又或者是将结果以邮件的形式发送到指定邮箱，这是整个大框架思路，要完成这一系列自动化的测试框架，则需要有一定的python代码基础，博主这里只是粗略的叙述了思路，有很多地方就不细说了比如数据依赖等就请大家慢慢的阅读吧 2.测试报告效果预览 unittest和HTMLTestRunner结合生成报告（新版本的） unittest和HTMLTestRunner结合生成报告（经典版本的） 测试报告邮件通知 二丶接口基础知识1.什么是接口 连接前后端以及移动端，通俗来说就是前端和后端之间的桥梁，比如网站需要去调用银行丶微信及支付宝的接口来完成业务需求 2.接口的种类 外部接口和内部接口；内部接口又分为上层服务与下层服务以及同级服务 3.接口的分类 请求方式：post丶get丶delete丶put 4.为什么要做接口测试 原因：不同端的工作进度肯定是不一致的，那么就需要对最开始开发出来的接口进行测试；对于项目来说缩短项目周期，提高开发效率以及提高系统的健壮性 5.接口测试流程 需求讨论——需求评审——场景设计——用例设计——数据准备——执行 6.为什么要设计测试用例 理清思路，避免侧漏 提高测试效率 跟进测试进度 告诉领导做过 跟进重复重复性工作 7.用例设计分类 功能用例测试：测试功能是否正常丶测试功能是否按照接口文档实现 逻辑用例设计：是否存在依赖业务，例如有些操作是需要用户登录成功的状态下才能进行的操作 异常测试用例设计：参数异常以及数据异常；参数异常包括关键字参数丶参数为空丶多参数丶少参数丶错误参数，数据异常包括关键字数据丶数据为空丶长度不一致丶错误数据 安全测试用例设计：cookie丶header丶唯一识别码 三丶接口测试工具1.接口测试工具分类 抓取接口工具 httpwatch：集成于IE和Firefox浏览器中，在其他浏览器中无法使用，查看数据也比较麻烦 wireshark：只要是经过电脑的所有请求都会去抓取，导致数据量比较庞大，看数据也比较麻烦 fiddler：轻量级抓包工具，功能比较全，只会记录http请求不会像wireshark工具记录tcp和udp等请求 测试接口工具： loadrunner：不仅仅是性能测试工具，由于该工具几乎都是基于http请求，所以也可以用来测试接口 fiddler：它除了可以抓包还可以向接口发送各种请求 soapui：接口和自动化测试工具，功能也比较强大 jmeter：跟loadrunner一样不仅仅是做性能测试，也可以对接口进行测试 postman：谷歌旗下的接口测试工具 四丶Fiddler的使用1.抓取不同类型接口数据（http以及https） 查看windows本机的IP 配置fiddler 需要保证要抓取的手机与电脑保持同一网段，博主这里使用逍遥模拟器模拟安卓手机，修改手机网络 在高级选项中设置手动代理IP为windows本机IP地址，端口设置与fiddler抓取端口保持一致 再安卓手机中打开知乎app，抓取知乎app的http服务的数据 现在的移动app都是基于https请求的，所以需要在fiddler中设置https请求 然后在手机端浏览器中访问windows电脑IP+port，进行网络安全证书的下载安装 点击下面一个下载证书 然后设置密码即可 证书安装成功后，重新打开知乎app，则成功抓取https请求的数据 在知乎app中随便对一文章进行评论，抓取该app评论接口 2.数据模拟以及过滤规则 如下图进行选择要过滤的hosts类型，并在输入框添加要过滤的hosts即可 对知乎上的一篇文章进行回答后，获取https://api.zhihu.com/answers接口，查看发送的post请求数据中的content字段内容也就是博主回答的内容 然后进行数据模拟，也就是点击fiddler软件上的replay对https://api.zhihu.com/answers接口进行post请求数据的而二次发送，由于知乎这边设定对一个问题只能进行一次回答，所以知乎服务器返回的json数据提示我们失败，同时也说明对接口进行二次数据发送成功，只是规则逻辑失败 3.如何模拟接口响应数据 首先第一步，访问知乎app热榜，在fiddler软件中获取接口查看服务器响应的json格式数据，从服务器返回的json数据看出热榜标题字段名为title_area 然后选择服务器返回的数据类型为TextView，点击.View in Notepad即打开数据记事本，如下图在记事本中找到title_area字段的内容，该字段内容进行了将中文转换为一串字符串 将记事本中的title_area字段的数据修改为this is a test for cdtaogang 点击文件——另存为保存到桌面 回到fiddler中，左侧选中热榜接口，右侧选中AutoResponder，在此窗口下点击Add Rule将左侧的接口添加进去，在右侧下方导入保存在桌面的zhihu_hot.htm文件，最后点击sava保存 回到知乎app中刷新当前热榜页面，则成功返回修改的热榜标题 4.使用fiddler进行评论接口测试 对一篇文章进行评论，抓取评论接口，因为get请求的接口测试太简单，所以博主这里选择评论接口即POST请求方式 右击评论接口选择copy复制接口的url地址 右侧选择Composer，将复制的评论接口url粘贴到地址栏，并选择POST请求方式 因为评论接口涉及到用户身份验证也就是登录后才能进行评论的，所以需要将comments接口中request headers请求头中的所有请求数据以及请求数据中的TextView的值进行复制 请求头数据 请求体数据 将上面复制的请求头和请求体数据分别粘贴到如下输入框中，点击Execute执行发送，然后在左侧则出现了另一个comments接口数据 查看该comments接口，服务器返回的响应数据中与第一个comments接口一致，说明接口测试成功 五丶unittest使用1.unittest简单使用 在IDE中使用python的环境随便创建个py文件，需要注意的是该py文件的名字不能是test.py，否在运行时会出错，unittest包是python自带的不需要下载安装，代码如下 1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/17 13:10' import unittest class TestMethod(unittest.TestCase): @classmethod def setUpClass(cls): print(\"Method before class execution\") @classmethod def tearDownClass(cls): print(\"Method after class execution\") def setUp(self): print(\"------setUp------\") def tearDown(self): print(\"------tearDown------\") def test_01(self): print(\"First test method\") def test_02(self): print(\"The second test method\") if __name__ == '__main__': unittest.main() 直接run运行以上代码 2.unittest和request重构封装 说明：使用requests模块对接口url地址发送请求，通过unittest测试框架进行case测试 首先博主在逍遥安卓模拟器中下载了一个看书app，通过fiddler对app上的某一接口进行获取，之所以选择对此app进行接口测试，是因为该app的所有接口全是POST请求 在PyCharm下新建工程目录，目录下创建base包，在包下创建一个demo.py文件以及test_method.py文件，用于使用unittest框架来测试以上app接口 在demo.py文件中，使用requests get以及post方法进行了封装，主要是根据传递的参数method来对get以及post方法进行分别调用而已，具体实现如下 12345678910111213141516171819import requests class RunMain: def send_get(self,url,data): res = requests.get(url=url,data=data).json() return res def send_post(self,url,data): res = requests.post(url=url,data=data).json() return res def run_main(self,url,method,data=None): res = None if method == 'GET': res = self.send_get(url,data) else: res = self.send_post(url,data) return res 在test_method.py文件中则创建测试类以及test方法，在test方法中调用demo.py中的run_main方法，即使用requests模块向传递的接口url地址和请求方式以及请求体发送对应的请求，这里使用setUp方法则是利用其优先调用而对RunMain类进行实例化 1234567891011121314151617181920212223242526272829303132333435import unittestimport jsonimport HtmlTestRunnerfrom .demo import RunMain class TestMethod(unittest.TestCase): def setUp(self): self.run = RunMain() def test_01(self): url = 'http://api.ishugui.com/asg/portal/call/265.do' data = &#123; \"sstoken\":\"eyJleHAiOjE1Njg1MzgyNTczMzUsImlhdCI6MTU2MDc2MjI1NzMzNSwicHAiOiIxMTQwNTQ1Njg5MDYwMDQ0ODAwQHNvaHUuY29tIiwidGsiOiIwZkNYSHpjTUZzR0dFMEswbVdvUVFCNWVCanpXa0hmWiIsInYiOjB9.SDYkT9FpWrBbko6xRrESN74IXJhzkqQLtijKjGiVrqA\", \"gidinf\":\"x011060802ff0fd40695d68140002799751474c540b3\", \"ppinf\":\"2|1560762257|1561971857|bG9naW5pZDowOnx1c2VyaWQ6Mjg6MTE0MDU0NTY4OTA2MDA0NDgwMEBzb2h1LmNvbXxzZXJ2aWNldXNlOjMwOjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMHxjcnQ6MTA6MjAxOS0wNi0xN3xlbXQ6MTowfGFwcGlkOjY6MTEwNjA4fHRydXN0OjE6MXxwYXJ0bmVyaWQ6MTowfHJlbGF0aW9uOjA6fHV1aWQ6MTY6czk1YWIwNDk5NjE3YmJhNnx1aWQ6MTY6czk1YWIwNDk5NjE3YmJhNnx1bmlxbmFtZTowOnw\", \"pprdig\":\"kaKPdU0WwIdzL58CqxNz5pgMyv23P0-Y5GRnd5ufPlXIGzrk7_7TlIK5XFQiuoqAHNqGVXHCVd4cB1DIkR5yFZ_nExnSjIZbBJWYlMkrsiIjDYqWCvedZRLm8sZqS0WqA0FcKXuSn3Z0gVRus9YpEonNz5wyuWdUqxaSmzlzygY\", \"ppsmu\":\"1|1560762257|1561971857|dXNlcmlkOjI4OjExNDA1NDU2ODkwNjAwNDQ4MDBAc29odS5jb218dWlkOjA6fHV1aWQ6MDo|byWcaoPqy02s2_9GHLhZFAQ6Ov_GazMPFLrq115HiSTBS9Ijr33a55quRq2Mr1_6ZMruKEk-BYFpShUaMtwRYA\" &#125; res1 = self.run.run_main(url, \"POST\", json.dumps(data)) print(res1) def test_02(self): url = 'http://api.ishugui.com/asg/portal/call/265.do' data = &#123; &#125; res2 = self.run.run_main(url, 'POST', data) print(res2) if __name__ == '__main__': unittest.main() 运行test_method模块，查看测试接口，test_02则是错误测试 3.unittest中assert的使用 首先根据返回的结果字典dict数据中的status状态值来判断测试是否通过或者失败，逻辑很基础就不细说了 123456789101112131415161718192021222324252627282930313233343536373839class TestMethod(unittest.TestCase): def setUp(self): self.run = RunMain() def test_01(self): url = 'http://api.ishugui.com/asg/portal/call/265.do' data = &#123; \"sstoken\":\"eyJleHAiOjE1Njg1MzgyNTczMzUsImlhdCI6MTU2MDc2MjI1NzMzNSwicHAiOiIxMTQwNTQ1Njg5MDYwMDQ0ODAwQHNvaHUuY29tIiwidGsiOiIwZkNYSHpjTUZzR0dFMEswbVdvUVFCNWVCanpXa0hmWiIsInYiOjB9.SDYkT9FpWrBbko6xRrESN74IXJhzkqQLtijKjGiVrqA\", \"gidinf\":\"x011060802ff0fd40695d68140002799751474c540b3\", \"ppinf\":\"2|1560762257|1561971857|bG9naW5pZDowOnx1c2VyaWQ6Mjg6MTE0MDU0NTY4OTA2MDA0NDgwMEBzb2h1LmNvbXxzZXJ2aWNldXNlOjMwOjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMHxjcnQ6MTA6MjAxOS0wNi0xN3xlbXQ6MTowfGFwcGlkOjY6MTEwNjA4fHRydXN0OjE6MXxwYXJ0bmVyaWQ6MTowfHJlbGF0aW9uOjA6fHV1aWQ6MTY6czk1YWIwNDk5NjE3YmJhNnx1aWQ6MTY6czk1YWIwNDk5NjE3YmJhNnx1bmlxbmFtZTowOnw\", \"pprdig\":\"kaKPdU0WwIdzL58CqxNz5pgMyv23P0-Y5GRnd5ufPlXIGzrk7_7TlIK5XFQiuoqAHNqGVXHCVd4cB1DIkR5yFZ_nExnSjIZbBJWYlMkrsiIjDYqWCvedZRLm8sZqS0WqA0FcKXuSn3Z0gVRus9YpEonNz5wyuWdUqxaSmzlzygY\", \"ppsmu\":\"1|1560762257|1561971857|dXNlcmlkOjI4OjExNDA1NDU2ODkwNjAwNDQ4MDBAc29odS5jb218dWlkOjA6fHV1aWQ6MDo|byWcaoPqy02s2_9GHLhZFAQ6Ov_GazMPFLrq115HiSTBS9Ijr33a55quRq2Mr1_6ZMruKEk-BYFpShUaMtwRYA\" &#125; res1 = self.run.run_main(url, \"POST\", json.dumps(data)) # print(type(res1)) # print(res1['pub']) # print(type(res1['pub'])) if res1['pub']['status'] == 0: print(\"测试通过\") else: print(\"测试失败\") print(res1) def test_02(self): url = 'http://api.ishugui.com/asg/portal/call/265.do' data = &#123; &#125; res2 = self.run.run_main(url, 'POST', data) if res2['pub']['status'] == 0: print(\"测试通过\") else: print(\"测试失败\") print(res2) if __name__ == '__main__': unittest.main() 运行以上代码，查看结果与预期一样 将if判断代码更换成unittest模块中的assert断言进行判断，这里使用assertEqual方法来判断两个值是否相等，当两个值相等则返回OK，当不相同时返回assertEqual方法msg变量自定义的值 1234567891011121314151617181920212223242526272829303132333435363738394041class TestMethod(unittest.TestCase): def setUp(self): self.run = RunMain() def test_01(self): url = 'http://api.ishugui.com/asg/portal/call/265.do' data = &#123; \"sstoken\":\"eyJleHAiOjE1Njg1MzgyNTczMzUsImlhdCI6MTU2MDc2MjI1NzMzNSwicHAiOiIxMTQwNTQ1Njg5MDYwMDQ0ODAwQHNvaHUuY29tIiwidGsiOiIwZkNYSHpjTUZzR0dFMEswbVdvUVFCNWVCanpXa0hmWiIsInYiOjB9.SDYkT9FpWrBbko6xRrESN74IXJhzkqQLtijKjGiVrqA\", \"gidinf\":\"x011060802ff0fd40695d68140002799751474c540b3\", \"ppinf\":\"2|1560762257|1561971857|bG9naW5pZDowOnx1c2VyaWQ6Mjg6MTE0MDU0NTY4OTA2MDA0NDgwMEBzb2h1LmNvbXxzZXJ2aWNldXNlOjMwOjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMHxjcnQ6MTA6MjAxOS0wNi0xN3xlbXQ6MTowfGFwcGlkOjY6MTEwNjA4fHRydXN0OjE6MXxwYXJ0bmVyaWQ6MTowfHJlbGF0aW9uOjA6fHV1aWQ6MTY6czk1YWIwNDk5NjE3YmJhNnx1aWQ6MTY6czk1YWIwNDk5NjE3YmJhNnx1bmlxbmFtZTowOnw\", \"pprdig\":\"kaKPdU0WwIdzL58CqxNz5pgMyv23P0-Y5GRnd5ufPlXIGzrk7_7TlIK5XFQiuoqAHNqGVXHCVd4cB1DIkR5yFZ_nExnSjIZbBJWYlMkrsiIjDYqWCvedZRLm8sZqS0WqA0FcKXuSn3Z0gVRus9YpEonNz5wyuWdUqxaSmzlzygY\", \"ppsmu\":\"1|1560762257|1561971857|dXNlcmlkOjI4OjExNDA1NDU2ODkwNjAwNDQ4MDBAc29odS5jb218dWlkOjA6fHV1aWQ6MDo|byWcaoPqy02s2_9GHLhZFAQ6Ov_GazMPFLrq115HiSTBS9Ijr33a55quRq2Mr1_6ZMruKEk-BYFpShUaMtwRYA\" &#125; res1 = self.run.run_main(url, \"POST\", json.dumps(data)) # print(type(res1)) # print(res1['pub']) # print(type(res1['pub'])) # if res1['pub']['status'] == 0: # print(\"测试通过\") # else: # print(\"测试失败\") self.assertEqual(res1['pub']['status'], 0, \"测试失败\") print(res1) def test_02(self): url = 'http://api.ishugui.com/asg/portal/call/265.do' data = &#123; &#125; res2 = self.run.run_main(url, 'POST', data) # if res2['pub']['status'] == 0: # print(\"测试通过\") # else: # print(\"测试失败\") self.assertEqual(res2['pub']['status'], 0, \"测试失败\") print(res2) if __name__ == '__main__': unittest.main() 测试查看结果，断言失败，测试结果如下很清晰 4.unittest中case的管理及运用 在测试一些接口时，有些接口的返回数据需要在下一个接口进行使用，所以需要定义全局变量，方便每个case都能够得着，当在test_01中定义全局变量userid，然后在test_02中进行打印 在unittest中，是按照字母数字来进行case先后执行顺序的，将test_01改为test_03后，运行代码后，会提示test_02中的userid未定义，原因是程序先去执行了test_02这个case，所以出现该提示是正常的 当在测试代码中有很多case时，我想跳过某个case，则在该case方法上定义unittest的skip方法装饰器，并需要传递此方法名作为实参进行传递 除了在if name == ‘main‘中使用unittest.main方法执行所有的case以外，还可以将要测试的case添加到unittest.TestSuite集合中执行想要执行的case，若想要全部都执行则需要一个一个的添加 5.unittest和HTMLTestRunner结合生成报告（博主这里给大家展现两种） 第一种：比较新版本的htmltestrunner报告 安装HTMLTestRunner，在https://pypi.org/project/html-testRunner/#files 网站上进行下载whl文件 然后将下载好的whl文件放在你的项目环境的Scripts目录下 最后在Terminal终端或者cmd终端中进入以上目录，执行如下命令即可 安装成功后，即在以下路径中可以找到安装的HTMLTestRunner的包了 在if name == ‘main‘中只需要调用HtmlTestRunner模块中的HtmlTestRunner类，向该类传递报告标题参数值即可，其他均默认，需要注意的时启动文件run为当前的py文件，如果是Unittests开头的启动文件，则不会运行if name == ‘main‘下的代码，只会执行unittest框架的setUp以及test开头的case代码 运行test_method.py文件，成功在base目录下创建reports目录，并在该目录下生成对应时间的测试报告 打开reports目录下生成的html测试报告，查看测试内容，与预期设定一样，test_02失败test_03成功，说明一下报告中的乱码为中文 第二种：比较经典版本的htmltestrunner报告 为了方便演示效果，博主在testItems项目目录下，创建base2的模块，将base模块下的demo.py和test_method.py文件拷贝到base2目录下并将test_method.py命令为test_method2.py免得搞混淆，然后在base2目录下新建HTMLTestRunner.py文件用于存放其源码，目录结构如下 紧接着到http://tungwaiyip.info/software/HTMLTestRunner_0_8_2/HTMLTestRunner.py 地址中将HTMLTestRunner.py的代码全选拷贝，然后粘贴到base2/HTMLTestRunner.py文件中，因为该版本的HTMLTestRunner代码是以py2进行编写的，博主的环境使用的是py3，所以需要进行修改，修改的内容如下 123456第94行， 将import StringIO修改成import io第539行，将self.outputBuffer = StringIO.StringIO()修改成self.outputBuffer = io.StringIO()第642行，将if not rmap.has_key(cls):修改成if not cls in rmap:第631行，将print &gt;&gt; sys.stderr, &apos;\\nTime Elapsed: %s&apos; % (self.stopTime-self.startTime)修改成print(sys.stderr, &apos;\\nTime Elapsed: %s&apos; % (self.stopTime-self.startTime))第766行，将uo = o.decode(&apos;latin-1&apos;)修改成uo = e第775行，将ue = e.decode(&apos;latin-1&apos;)修改成ue = e 在test_method2模块中首先需要从base2模块中去导入HTMLTestRunner文件，然后if name == ‘main‘中，需要创建一个文件源，同样是调用HTMLTestRunner模块中的HTMLTestRunner类，不同的是需要将创建的文件源传递给实例属性stream变量 运行test_method2.py，成功在上一级report目录下生成html_report.html报告文件 打开html_report.html测试报告，测试结果与代码设定一致 六丶mock服务入门到实战1.mock简介 mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法，mock是在测试过程中，对于一些不容易构造/获取的对象，创建一个mock对象来模拟对象的行为即就是模拟fiddler返回接口响应数据的一个过程。 2.mock安装 在终端使用pip进行安装即可 3.在case中通过底层函数实现mock 在test_method模块中导入mock，然后在test_03函数中通过以下代码设置返回的return_value的值为请求的data数据 12mock_data = mock.Mock(return_value=data)print(mock_data) run运行Unittests in test_method.py，打印出Mock id的值 将调用run_main方法的值设定为mock_data，即print(res1)则表示打印请求的data数据的值，因为res1的数据不再是接口返回的响应数据，则arrest断言是会提示报错的，这是正常的 4.重构封装mock服务 在base目录下创建mock_demo.py文件，构造一个mock_test方法，该方法就是将test_03方法中self.run.run_main = mock.Mock(return_value=data) 和 res1 = self.run.run_main(url, “POST”, json.dumps(data))方法的调用进行了封装成为test_02和test_03方法通用的一个方法，上一步骤中的代码mock_data = mock.Mock(return_value=data) 和self.run.run_main = mock_data，即就相当于self.run.run_main = mock.Mock(return_value=data)而已，都是python基本的调用封装基础知识，mock_demo.py中的代码如下 12345678910111213141516171819# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/20 16:26'from mock import mockimport json def mock_test(mock_method, request_data, url, method, response_data): \"\"\" :param mock_method: :param request_data: :param url: :param method: :param response_data: :return: res \"\"\" mock_method = mock.Mock(return_value=response_data) print('mock_method:', mock_method) res = mock_method(url, method, json.dumps(request_data)) return res 那么在test_03方法中，如下进行调用即可 12res1 = mock_test(self.run.run_main, data, url, &apos;POST&apos;, &apos;ssssssss&apos;)print(&apos;res1:&apos;, res1) 运行Unittests in test_method.py，查看运行结果和博主设定一样成功返回自定义的response_data数据 七丶接口自动化框架设计到开发1.如何设计一个接口自动化测试框架 根据接口地址丶接口类型丶请求数据丶预期结果来进行设计，对于需要登录后才能进行操作的接口那么则需要进行header cookie等数据的传递，自动化测试的难点就是数据依赖。 2.python操作excel获得内容 首先python操作excel，需要安装两个包，分别是xlrd和xlwt这两个库，xlrd这个库是负责读取excel数据的，而xlwt库是负责向excel写入数据的 在项目目录下创建utils工具包，在该包下创建op_excel.py文件，在该文件中通过导入xlrd包，对excel表的数据进行读取操作 3.重构操作excel函数 根据上一步骤读取excel表的内容代码后，进行了一个简单的封装，提高代码的通用性，过程相当的简单，实现代码如下 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/20 17:33'import xlrd data = xlrd.open_workbook(\"../test_data/rs.xls\")tables = data.sheets()[0] # 获取表格数据对象print(tables.nrows) # 打印表格行数print(tables.cell_value(0,0)) # 打印excel表格数据，需要传递数据所在的坐标(x,y)print(tables.cell_value(0,1))print(\"*\"*50+\"封装前后数据对比\"+\"*\"*50) class operationExcel(object): def __init__(self, file_path=\"../test_data/rs.xls\", sheet_id=0): self.file_path = file_path self.sheet_id = sheet_id self.data = self.get_data() def get_data(self): data = xlrd.open_workbook(self.file_path) tables = data.sheets()[self.sheet_id] return tables def get_rows(self): \"\"\"获取单元格的排数\"\"\" return self.data.nrows def get_cell_value(self, x=0, y=0): \"\"\"获取某个单元格的数据\"\"\" return self.data.cell_value(x, y) if __name__ == '__main__': print(operationExcel().get_rows()) print(operationExcel().get_cell_value()) print(operationExcel().get_cell_value(0,1)) 运行op_excel.py文件后，结果与封装之前代码结果一致，表示重构封装代码成功 4.学习操作json文件 自定义一个登录的json文件名为login.json，文件内容如下，存放在test_data目录下 在utils工具包下创建op_json.py文件，在文件中对login.json文件内容进行读取操作，代码如下 5.重构json工具类 将上一步操作json的代码进行封装 123456789101112131415161718192021class operationJson(object): def __init__(self, file_path=\"../test_data/login.json\"): self.file_path = file_path self.data = self.get_data() def get_data(self): with open(self.file_path) as f: data = json.load(f) return data def get_key_words(self, key=None): if key: return self.data[key] else: return self.data if __name__ == '__main__': print(operationJson().get_key_words()) print(operationJson().get_key_words(\"login\")) print(operationJson().get_key_words(\"login\")['username']) 运行op_json.py文件，结果与封装之前代码结果一致，表示重构封装代码成功 6.封装获取常量方法 首先打开excel表格，查看需要获取的字段有哪些 对excel表的字段进行获取，在项目目录下创建名为data的python包，在该包下创建data_conf.py，代码就是简单的获取对应的变量值，具体如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/21 9:29' class global_var: id = '0' # id module = '1' # 模块 url = '2' # url run = '3' # 是否运行 request_type = '4' # 请求类型 request_header = '5' # 是否携带header case_depend = '6' # case依赖 response_data_depend = '7' # 依赖的返回数据 data_depend = '8' # 数据依赖 request_data = '9' # 请求数据 expect_result = '10' # 预期结果 reality_result = '11' # 实际结果 def get_id(): return global_var.id def get_module(): return global_var.module def get_url(): return global_var.url def get_run(): return global_var.run def get_request_type(): return global_var.request_type def get_request_header(): return global_var.request_header def get_case_depend(): return global_var.case_depend def get_response_data_depend(): return global_var.response_data_depend def get_data_depend(): return global_var.data_depend def get_request_data(): return global_var.request_data def get_expect_result(): return global_var.expect_result def get_reality_result(): return global_var.reality_result 7.封装获取接口数据 在data目录下创建data_get.py文件，在该文件中对excel表数据以及json数据结合上一步封装的常量方法整合后的实现，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/21 10:01'from utils.op_excel import operationExcelfrom utils.op_json import operationJsonfrom data import data_conf class getData(object): def __init__(self): self.op_excel = operationExcel() def get_case_lines(self): \"\"\"获取表格行数\"\"\" return self.op_excel.get_rows() def get_is_run(self, x): \"\"\"获取case是否运行\"\"\" flag = None y = data_conf.get_run() run_value = self.op_excel.get_cell_value(x, y) if run_value == 'yes': flag = True else: flag = False return flag def get_is_header(self, x): \"\"\"是否携带header\"\"\" y = data_conf.get_request_header() header = self.op_excel.get_cell_value(x, y) if header == 'yes': return data_conf.get_header_value() else: return None def get_request_method(self, x): \"\"\"获取请求方式\"\"\" y = data_conf.get_request_type() request_method = self.op_excel.get_cell_value(x, y) return request_method def get_request_url(self, x): \"\"\"获取请求地址\"\"\" y = data_conf.get_url() request_url = self.op_excel.get_cell_value(x, y) return request_url def get_request_data(self, x): \"\"\"获取请求数据\"\"\" y = data_conf.get_request_data() request_data = self.op_excel.get_cell_value(x, y) if request_data == '': return None return request_data def get_data_for_json(self, x): \"\"\"通过excel中的关键字去获取json数据\"\"\" op_json = operationJson() data = op_json.get_key_words(self.get_request_data(x)) return data def get_expect_data(self, x): \"\"\"获取预期结果数据\"\"\" y = data_conf.get_expect_result() expect_data = self.op_excel.get_cell_value(x, y) if expect_data == '': return None return expect_data 8.post、get基类的封装 在base包下创建run_method.py文件，在文件中重新编写对get丶post请求方式的代码封装，具体如下 12345678910111213141516171819202122232425262728293031323334# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/21 11:19'import requests class RunMain(object): def get_main(self, url, data=None, header=None): res = None if header is not None: res = requests.get(url=url, data=data, headers=header).json() else: res = requests.get(url=url, data=data).json() return res def post_main(self, url, data, header=None): res = None if header is not None: res = requests.post(url=url, data=data, headers=header).json() else: res = requests.post(url=url, data=data).json() return res def run_main(self, url, method, data=None, header=None): res = None if method.lower() == 'post': res = self.post_main(url, data, header) elif method.lower() == 'get': res = self.get_main(url, data, header) else: return \"what ?????\" return res 9.主流程封装及错误解决调试 首先在testItems项目目录下新建一个名为main的python包，在该包下创建名为run_test的py文件，该文件为主程序启动文件，代码的逻辑就是将前面封装的方法进行了调用核心就是读取excel表的数据，通过读取到的数据，发送请求，其中包括某一些变量的判断，根据该判断然后到json数据中获取请求的数据，最后就这么的简单，代码如下 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/21 11:57'from base.run_method import RunMainfrom data.data_get import getData class RunTest(object): def __init__(self): self.runmain = RunMain() self.data = getData() def run(self): res = None row_counts = self.data.get_case_lines() # 获取excel表格行数 # print(row_counts) 5 for row_count in range(1, row_counts): # print(row_count) 1,2,3,4 url = self.data.get_request_url(row_count) # y行不变遍历获取x列的请求地址 method = self.data.get_request_method(row_count) # y行不变遍历获取x列的请求方式 is_run = self.data.get_is_run(row_count) # y行不变遍历获取x列的是否运行 data = self.data.get_data_for_json(row_count) # y行不变遍历获取x列的请求数据，这里面时三次调用，依次分别是get_data_for_json丶get_key_words丶get_request_data header = self.data.get_is_header(row_count) print('url:', url) print('method:', method) print('is_run:', is_run) print('data:', data) print('header:', header) if is_run: res = self.runmain.run_main(url,method,data,header) print(\"*\"*60+\"分割线\"+\"*\"*60) return res if __name__ == '__main__': print('res:', RunTest().run()) 运行run_test，成功的将excel以及json数据正确打印出来，返回res服务器返回结果，需要说明的是excel表中的所有数据都不是真实存在的，包括json文档数据也是，这里主要是测试整个框架的正确性读取excel以及json文档数据，并正确的发送请求获得相应数据 运行结果出现红色的内容，是由requests模块发送请求的安全请求警告，如不想显示此警告，可以在run_method.py发送请求核心代码进行禁用，禁用代码如下 重新运行run_test，安全请求警告不再显示 根据代码运行结果，对比excel表以及json数据文档内容，数据正确无误 10.返回数据格式处理以及调错 为了测试返回的接口的响应数据，博主这里在excel文档以及json文档中添加了一条数据 因为在excel文档中小说的接口不携带header所以在向接口发送请求数据核心代码块，进行了如下修改，因为在excel文档中的最后一个接口时真实的，所以只需要对最后一个接口url返回的字典类型的响应数据进行转换成json格式的数据，并按照关键字进行排序 运行run_test，在最后一个接口中成功打印出我们想要的数据 11.获取接口返回状态 在发送请求数据核心代码中，进行打印返回的状态码status_code即可，最后一个接口比较特殊，返回的响应数据中没有status_code，所以需要对返回的json数据中的status进行判断，并向其返回数据中添加我们所要的status_code的值 运行代码，当返回的状态码为404表示接口不存在，只要是存在响应数据，则status_code为200，必须说明一点的就是status_code为200不一定表示接口存在，有些大型网站会对其域名下不存在的接口返回200的错误页面显示，所以在测试文档中会体现预期结果和实际结果两项数据需要一致才能表示测试通过 12.通过预期结果判断case是否执行成功 进行接下来的测试，博主这里重新准备了另一个excel表来进行测试，需要对json文件中的数据进行添加，在excel表Book-05中的请求数据book5关键字对应的json文件的数据故意为空，可以对测试结果有一个对比 在数据获取核心类中定义了一个方法来获取excel表模块字段的数据 回过头在启动文件中获取模块名预期结果并进行打印 运行启动文件，查看运行结果 在utils目录下，创建common_util.py文件，在该文件代码中通过启动文件传递过来的数据来判断excel表预期结果数据的status状态码与res结果中的status状态码是否一致，一致表示测试通过，不一致则失败，代码如下 123456789101112131415# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/21 18:43'import json class CommonUtil(object): def is_contains(self, expect, reality): flag = None reality = json.loads(reality) expect = json.loads(expect) if expect['status'] == reality['pub']['status']: flag = True else: flag = False return flag 在启动文件中需要注释掉res响应数据，利于查看测试结果，还需要在启动文件调用is_contains方法来根据其返回值判断测试是否通过 运行启动文件，查看测试结果 13.将测试结果写入到excel中 首先在op_excel.py中定义一个方法，该方法实现读取excel的数据，并进行copy复制，然后再write方法将数据写入到坐标位置 然后在data_get.py中需要定义一个方法，在该方法中核心逻辑为获取y坐标的值 最后在启动文件中，调用data_get模块中的write_reality_data方法，并将剩余的x坐标的值以及data数据传递给最终的核心方法write_reality_result_data来完成对excel表中的实际结果数据的写入 将excel表进行关闭后，运行启动文件，再次打开excel表，实际结果数据写入正确，之所以需要关闭excel是避免提示提示错误，无法写入保存数据 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/91841130","categories":[{"name":"自动化接口框架开发","slug":"自动化接口框架开发","permalink":"https://hellotaogang.github.io/categories/自动化接口框架开发/"}],"tags":[{"name":"Fiddler","slug":"Fiddler","permalink":"https://hellotaogang.github.io/tags/Fiddler/"},{"name":"Unittest","slug":"Unittest","permalink":"https://hellotaogang.github.io/tags/Unittest/"},{"name":"HTMLTestRunner","slug":"HTMLTestRunner","permalink":"https://hellotaogang.github.io/tags/HTMLTestRunner/"},{"name":"接口自动化测试","slug":"接口自动化测试","permalink":"https://hellotaogang.github.io/tags/接口自动化测试/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django与Elasticsearch交互打造搜索引擎网站（二）","slug":"Django与Elasticsearch交互打造搜索引擎网站（二）","date":"2019-11-16T03:34:57.774Z","updated":"2019-11-16T04:12:04.188Z","comments":true,"path":"2019/11/16/Django与Elasticsearch交互打造搜索引擎网站（二）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/16/Django与Elasticsearch交互打造搜索引擎网站（二）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶Django搭建搜索网站 二丶通过scrapyd部署scrapy爬虫","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶Django搭建搜索网站 二丶通过scrapyd部署scrapy爬虫 一丶Django搭建搜索网站1.es完成搜索建议 搜索建议接口文档：https://www.elastic.co/guide/en/elasticsearch/reference/5.1/search-suggesters-completion.html 在接口文档中已经说明要使用此接口，需要添加suggest字段的映射，如果将suggest的analyzer直接设置为”ik_analyzer”在进行初始化的时候会报错，解决这个bug，则需要定义一个类并继承elasticsearch_dsl.analysis模块下的CustomAnalyzer类，并重写父类的get_analysis_definition方法，该方法只需要返回一个空字典即可解决此bug 12345678class CustomAnalyzer(_CustomAnalyzer): def get_analysis_definition(self): return &#123;&#125; ik_analyzer = CustomAnalyzer(\"ik_max_word\", filter=[\"lowercase\"])class ArticleType(DocType): suggest = Completion(analyzer=ik_analyzer) 在elasticsearch-head页面中删除之前创建的jobbole索引，重新运行es_type模块，查看新生成的jobbole索引信息中的suggest字段 2.搜索建议字段保存 在接口文档中详细说明了搜索建议查询匹配的预期文本，但没有告知我们要如何设置input的值 12345678910111213PUT music / song / 1？refresh &#123; “suggest”：[ &#123; “input”：“Nevermind”， “weight”：10 &#125;， &#123; “input”：“Nirvana”， “weight”：3 &#125; ] &#125; 在上一篇博客在使用Kibana工具时，查看分析器解析的结果是对数据进行了分词操作，那么就可以利用这个接口进行数据分词 在pipelines文件中定义一个全局方法，在这个方法需要接收两个参数，index为索引名称info_tuple为元组类型接收多个字段参数与其的权重值，在方法中遍历获取字段内容与权重值，通过链接的ArticleType实例对象analyze方法获取解析结果，再从解析结果words中获取token分词数据 1234567891011121314151617181920from elasticsearch_dsl.connections import connectionses = connections.create_connection(ArticleType._doc_type.using) def gen_suggests(index, info_tuple): #根据字符串生成搜索建议数组 used_words = set() suggests = [] for text, weight in info_tuple: if text: #调用es的analyze接口分析字符串 words = es.indices.analyze(index=index, analyzer=\"ik_max_word\", params=&#123;'filter':[\"lowercase\"]&#125;, body=text) anylyzed_words = set([r[\"token\"] for r in words[\"tokens\"] if len(r[\"token\"])&gt;1]) new_words = anylyzed_words - used_words else: new_words = set() if new_words: suggests.append(&#123;\"input\":list(new_words), \"weight\":weight&#125;) return suggests 在ElasticsearchPipeline管道类中调用save方法之前生成搜索建议词的保存，调用gen_suggests方法 1article.suggest = gen_suggests(ArticleType._doc_type.index, ((article.title,10),(article.tags, 7))) Debug测试生成搜索建议分词 刷新elasticsearch-head可视化页面jobbole索引数据浏览 3.创建Django项目 安装项目虚拟环境 在Pycharm中创建一个新的Django项目 创建完成后，项目目录结构如下 Debug测试运行项目成功 4.快速搭建搜索网站主页 在项目根目录下创建static目录，存放静态资源文件，并将模板文件拷贝到templates目录下 在项目根级urls中使用TemplateView类的as_view方法将index模板也就是主页面渲染显示 1234urlpatterns = [ url(r'admin/', admin.site.urls), url(r'^$', TemplateView.as_view(template_name=\"index.html\"), name='index'),] 在settings文件中将static目录添加配置中 123STATICFILES_DIRS = [ os.path.join(BASE_DIR, &apos;static&apos;)] 在index.html模板文件中动态获取静态资源路径 访问http://127.0.0.1:8000/地址，成功渲染出index页面 5.elasticsearch模糊查询来完成搜索关键字自动补全功能 这里需要使用fuzzy关键字也就是模糊查询来完成在搜索框输入不完整的关键字自动补全该关键字，如输入pyth则会提示补全后的python关键字，查看elasticsearch5.1.1版本提供的接口文档示例 在Kibana工具页面中使用如上接口测试自动补全 6.django实现elasticsearch的搜索建议 首先需要将es_types中python与elasticsearch_dsl交互的代码拷贝到django项目models中 1234567891011121314151617181920212223242526272829303132333435363738from django.db import models # Create your models here.from elasticsearch_dsl import DocType, Date, Nested, Boolean, analyzer,Completion, Keyword, Text, Integerfrom elasticsearch_dsl.connections import connectionsfrom elasticsearch_dsl.analysis import CustomAnalyzer as _CustomAnalyzerconnections.create_connection(hosts=[\"localhost\"]) class CustomAnalyzer(_CustomAnalyzer): def get_analysis_definition(self): return &#123;&#125; ik_analyzer = CustomAnalyzer(\"ik_max_word\", filter=[\"lowercase\"]) class ArticleType(DocType): suggest = Completion(analyzer=ik_analyzer) title = Text(analyzer=\"ik_max_word\") create_date = Date() url = Keyword() url_object_id = Keyword() cover_image_url = Keyword() cover_image_path = Keyword() praise_nums = Integer() comment_nums = Integer() fav_nums = Integer() tags = Text(analyzer=\"ik_max_word\") content = Text(analyzer=\"ik_max_word\") class Meta: index = \"jobbole\" doc_type = \"article\" if __name__ == '__main__': ArticleType.init() 需要在当前虚拟环境中安装elasticsearch_dsl 在search应用views中定义类视图get方法，返回搜索建议title字段数据 1234567891011121314151617class SearchSuggest(View): def get(self, request): key_words = request.GET.get('s', '') re_datas = [] if key_words: s = ArticleType.search() s = s.suggest('song_suggest', key_words, completion=&#123; \"field\": \"suggest\", \"fuzzy\": &#123; \"fuzziness\": 2 &#125;, \"size\": 10 &#125;) suggestions = s.execute_suggest() for match in suggestions.song_suggest[0].options: source = match._source re_datas.append(source[\"title\"]) return HttpResponse(json.dumps(re_datas), content_type=\"application/json\") 在index模板文件中定义js代码，通过ajax异步get请求方式向接口发送请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script type=\"text/javascript\"&gt; var suggest_url = \"&#123;% url \"suggest\" %&#125;\" var search_url = '/search' $('.searchList').on('click', '.searchItem', function()&#123; $('.searchList .searchItem').removeClass('current'); $(this).addClass('current'); &#125;); function removeByValue(arr, val) &#123; for(var i=0; i&lt;arr.length; i++) &#123; if(arr[i] == val) &#123; arr.splice(i, 1); break; &#125; &#125; &#125; // 搜索建议 $(function()&#123; $('.searchInput').bind(' input propertychange ',function()&#123; var searchText = $(this).val(); var tmpHtml = \"\" $.ajax(&#123; cache: false, type: 'get', dataType:'json', url:suggest_url+\"?s=\"+searchText+\"&amp;s_type=\"+$(\".searchItem.current\").attr('data-type'), async: true, success: function(data) &#123; for (var i=0;i&lt;data.length;i++)&#123; tmpHtml += '&lt;li&gt;&lt;a href=\"'+search_url+'?q='+data[i]+'\"&gt;'+data[i]+'&lt;/a&gt;&lt;/li&gt;' &#125; $(\".dataList\").html(\"\") $(\".dataList\").append(tmpHtml); if (data.length == 0)&#123; $('.dataList').hide() &#125;else &#123; $('.dataList').show() &#125; &#125; &#125;); &#125; ); &#125;) hideElement($('.dataList'), $('.searchInput')); &lt;/script&gt; 为了方便测试搜索建议提示，博主运行AirticSpider项目疯狂爬取伯乐在线网站的文章数据并写入到elasticsearch jobbole索引文档数据中 在elasticsearch-head页面中数据概览中jobbole索引的docs数据量为2783 重启运行django项目，强制刷新index页面，输入搜索关键字，成功加载出搜索建议以及自动补全关键字 7.django实现elasticsearch的搜索功能 在页面输入搜索关键字后点击搜索按钮，即跳转到相关相关文章的列表页，在文章标题部分的关键字应该显示为高亮状态，即所以根据官网提供的接口文档，在Kibana工具页面中进行测试 在应用search/views中使用如下代码测试如上接口是否成功获取对匹配的字段内容进行高亮处理 1234567891011121314151617181920212223client = Elasticsearch(hosts=[\"127.0.0.1\"])response = client.search( index=\"jobbole\", body=&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"python\", \"fields\": [\"tags\", \"title\", \"content\"] &#125; &#125;, \"from\": 0, \"size\": 10, \"highlight\": &#123; \"pre_tags\": ['&lt;span class=\"keyWord\"&gt;'], \"post_tags\": ['&lt;/span&gt;'], \"fields\": &#123; \"title\": &#123;&#125;, \"content\": &#123;&#125;, &#125; &#125; &#125;)total_nums = response[\"hits\"][\"total\"] Debug断点测试如上代码，成功获取到Kibana工具中接口测试获取到python关键字的_shards和hits数据 通过上面的代码可以获取到匹配关键字的数据，现在就将这些数据保存到一个数组中，再传递到result.html模板中进行显示，首先需要获取用户输入的搜索关键字到elasticsearch索引jobbole中匹配所有的相关的文章标签标题以及内容，并对相关文章的标题和内容匹配的搜索内容进行高亮系显示，最后是获取hits字典中的数据数据并保存到hit_list字典中传递到模板result中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class SearchView(View): \"\"\"搜索功能\"\"\" def get(self, request): key_words = request.GET.get(\"q\", \"\") response = client.search( index=\"jobbole\", body=&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": key_words, \"fields\": [\"tags\", \"title\", \"content\"] &#125; &#125;, \"from\": 0, \"size\": 10, \"highlight\": &#123; \"pre_tags\": ['&lt;span class=\"keyWord\"&gt;'], \"post_tags\": ['&lt;/span&gt;'], \"fields\": &#123; \"title\": &#123;&#125;, \"content\": &#123;&#125;, &#125; &#125; &#125; ) total_nums = response[\"hits\"][\"total\"] hit_list = [] # 获取响应中国的hits字段数据，并保存到hit_dict字典中 for hit in response[\"hits\"][\"hits\"]: hit_dict = &#123;&#125; if \"title\" in hit[\"highlight\"]: hit_dict[\"title\"] = \"\".join(hit[\"highlight\"][\"title\"]) else: hit_dict[\"title\"] = hit[\"_source\"][\"title\"] if \"content\" in hit[\"highlight\"]: hit_dict[\"content\"] = \"\".join(hit[\"highlight\"][\"content\"])[:500] else: hit_dict[\"content\"] = hit[\"_source\"][\"content\"][:500] hit_dict[\"create_date\"] = hit[\"_source\"][\"create_date\"] hit_dict[\"url\"] = hit[\"_source\"][\"url\"] hit_dict[\"score\"] = hit[\"_score\"] hit_list.append(hit_dict) return render(request, \"result.html\", &#123;\"all_hits\":hit_list, \"key_words\": key_words&#125;) 在result模板中对后端传递的数据进行打印显示 12345678910111213141516171819202122232425262728293031&lt;div class=\"resultList\"&gt; &#123;% for hit in all_hits %&#125; &lt;div class=\"resultItem\"&gt; &lt;div class=\"itemHead\"&gt; &lt;a href=\"&#123;&#123; hit.url &#125;&#125;\" target=\"_blank\" class=\"title\"&gt;&#123;% autoescape off %&#125;&#123;&#123; hit.title &#125;&#125;&#123;% endautoescape %&#125;&lt;/a&gt; &lt;span class=\"divsion\"&gt;-&lt;/span&gt; &lt;span class=\"fileType\"&gt; &lt;span class=\"label\"&gt;来源：&lt;/span&gt; &lt;span class=\"value\"&gt;伯乐在线&lt;/span&gt; &lt;/span&gt; &lt;span class=\"dependValue\"&gt; &lt;span class=\"label\"&gt;得分：&lt;/span&gt; &lt;span class=\"value\"&gt;&#123;&#123; hit.score &#125;&#125;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"itemBody\"&gt; &#123;% autoescape off %&#125;&#123;&#123; hit.content &#125;&#125;&#123;% endautoescape %&#125; &lt;/div&gt; &lt;div class=\"itemFoot\"&gt; &lt;span class=\"info\"&gt; &lt;label&gt;网站：&lt;/label&gt; &lt;span class=\"value\"&gt;伯乐在线&lt;/span&gt; &lt;/span&gt; &lt;span class=\"info\"&gt; &lt;label&gt;发布时间：&lt;/label&gt; &lt;span class=\"value\"&gt;2017-04-23&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 在根级urls中配置路由 1url(r'^search/$',SearchView.as_view(), name='search') 还需要在主页模板index中定义search_url的链接地址使用反向解析进行定义，然后就是定义搜索方法完成页面的跳转 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var search_url = \"&#123;% url 'search' %&#125;\"&lt;script&gt; var searchArr; //定义一个search的，判断浏览器有无数据存储（搜索历史） if(localStorage.search)&#123; //如果有，转换成 数组的形式存放到searchArr的数组里（localStorage以字符串的形式存储，所以要把它转换成数组的形式） searchArr= localStorage.search.split(\",\") &#125;else&#123; //如果没有，则定义searchArr为一个空的数组 searchArr = []; &#125; //把存储的数据显示出来作为搜索历史 MapSearchArr(); function add_search()&#123; var val = $(\".searchInput\").val(); if (val.length&gt;=2)&#123; //点击搜索按钮时，去重 KillRepeat(val); //去重后把数组存储到浏览器localStorage localStorage.search = searchArr; //然后再把搜索内容显示出来 MapSearchArr(); &#125; window.location.href=search_url+'?q='+val+\"&amp;s_type=\"+$(\".searchItem.current\").attr('data-type') &#125; function MapSearchArr()&#123; var tmpHtml = \"\"; var arrLen = 0 if (searchArr.length &gt;= 5)&#123; arrLen = 5 &#125;else &#123; arrLen = searchArr.length &#125; for (var i=0;i&lt;arrLen;i++)&#123; tmpHtml += '&lt;a href=\"'+search_url+'?q='+searchArr[i]+'\"&gt;'+searchArr[i]+'&lt;/a&gt;' &#125; $(\".mysearch .all-search\").html(tmpHtml); &#125; //去重 function KillRepeat(val)&#123; var kill = 0; for (var i=0;i&lt;searchArr.length;i++)&#123; if(val===searchArr[i])&#123; kill ++; &#125; &#125; if(kill&lt;1)&#123; searchArr.unshift(val); &#125;else &#123; removeByValue(searchArr, val) searchArr.unshift(val) &#125; &#125;&lt;/script&gt; 重新启动项目，在主页进行搜索功能测试，点击输入python时的自动补全提示跳转到搜索结果列表页面 直接在搜索框输入python点击搜索按钮，跳转到搜索结果列表页，并在主页我的搜索项中显示用户搜索历史 在搜索结果页面中也就是result页面，同样有搜索框，该搜索框除了会将主页搜索的关键字设置结果页面input value中外，还应该向首页搜索框一样具备搜索功能，这里需要重点说明一点，当在搜索结果页对搜索与主页一样的内容时，点击搜索功能按钮则不会触发页面搜索；在结构页面的搜索功能与主页搜索功能一样，即在result模板中定义js函数，当用户点击搜索时激活此input的onclick属性调用add_search函数，向后端接口SearchView发送请求数据，完成搜索功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;script&gt; var search_url = \"&#123;% url 'search' %&#125;\"; var searchArr; //定义一个search的，判断浏览器有无数据存储（搜索历史） if(localStorage.search)&#123; //如果有，转换成 数组的形式存放到searchArr的数组里（localStorage以字符串的形式存储，所以要把它转换成数组的形式） searchArr= localStorage.search.split(\",\") &#125;else&#123; //如果没有，则定义searchArr为一个空的数组 searchArr = []; &#125; //把存储的数据显示出来作为搜索历史 MapSearchArr(); function add_search()&#123; &#123;#alert(search_url);#&#125; var val = $(\".searchInput\").val(); &#123;#alert(val);#&#125; if (val.length&gt;=2)&#123; //点击搜索按钮时，去重 KillRepeat(val); //去重后把数组存储到浏览器localStorage localStorage.search = searchArr; //然后再把搜索内容显示出来 MapSearchArr(); &#125; &#123;#alert(111);#&#125; &#123;#window.location.href=search_url+'?q='+val+\"&amp;s_type=\"+$(\".searchItem.current\").attr('data-type');#&#125; setTimeout(function () &#123; window.location.href=search_url+'?q='+val+\"&amp;s_type=\"+$(\".searchItem.current\").attr('data-type'); &#125;,100) &#125; function MapSearchArr()&#123; var tmpHtml = \"\"; var arrLen = 0 if (searchArr.length &gt;= 5)&#123; arrLen = 5 &#125;else &#123; arrLen = searchArr.length &#125; for (var i=0;i&lt;arrLen;i++)&#123; tmpHtml += '&lt;a href=\"'+search_url+'?q='+searchArr[i]+'\"&gt;'+searchArr[i]+'&lt;/a&gt;' &#125; $(\".mysearch .all-search\").html(tmpHtml); &#125; //去重 function KillRepeat(val)&#123; var kill = 0; for (var i=0;i&lt;searchArr.length;i++)&#123; if(val===searchArr[i])&#123; kill ++; &#125; &#125; if(kill&lt;1)&#123; searchArr.unshift(val); &#125;else &#123; removeByValue(searchArr, val) searchArr.unshift(val) &#125; &#125;&lt;/script&gt; 在result模板中根据后端接口返回的数据，进行页面字段数据的打印 12345678910111213141516171819202122232425262728293031&lt;div class=\"resultList\"&gt; &#123;% for hit in all_hits %&#125; &lt;div class=\"resultItem\"&gt; &lt;div class=\"itemHead\"&gt; &lt;a href=\"&#123;&#123; hit.url &#125;&#125;\" target=\"_blank\" class=\"title\"&gt;&#123;% autoescape off %&#125;&#123;&#123; hit.title &#125;&#125;&#123;% endautoescape %&#125;&lt;/a&gt; &lt;span class=\"divsion\"&gt;-&lt;/span&gt; &lt;span class=\"fileType\"&gt; &lt;span class=\"label\"&gt;来源：&lt;/span&gt; &lt;span class=\"value\"&gt;伯乐在线&lt;/span&gt; &lt;/span&gt; &lt;span class=\"dependValue\"&gt; &lt;span class=\"label\"&gt;得分：&lt;/span&gt; &lt;span class=\"value\"&gt;&#123;&#123; hit.score &#125;&#125;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"itemBody\"&gt; &#123;% autoescape off %&#125;&#123;&#123; hit.content &#125;&#125;&#123;% endautoescape %&#125; &lt;/div&gt; &lt;div class=\"itemFoot\"&gt; &lt;span class=\"info\"&gt; &lt;label&gt;网站：&lt;/label&gt; &lt;span class=\"value\"&gt;伯乐在线&lt;/span&gt; &lt;/span&gt; &lt;span class=\"info\"&gt; &lt;label&gt;发布时间：&lt;/label&gt; &lt;span class=\"value\"&gt;&#123;&#123; hit.create_date &#125;&#125;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 测试在搜索结构页面进行字段搜索 8.django实现搜索结果分页 使用js完成数据的分页显示，首先在result模板中定义分页js代码函数，来完成页面标签div类选择器pagination的分页数据填充 12345678910111213var key_words = \"&#123;&#123; key_words &#125;&#125;\" //分页 $(\".pagination\").pagination(&#123;&#123; total_nums|add:'-1' &#125;&#125;, &#123; current_page :&#123;&#123; page|add:'-1' &#125;&#125;, //当前页码 items_per_page :10, display_msg :true, callback :pageselectCallback &#125;); function pageselectCallback(page_id, jq) &#123; var pageid = page_id +Number(1); &#123;#alert(pageid)#&#125; window.location.href=search_url+'?q='+key_words+'&amp;p='+pageid &#125; 在上面定义的js代码中需要在后端接口中获取total_nums总页数以及page当前页的值并传递给result模板中 123456page = request.GET.get(&quot;p&quot;, &quot;1&quot;)total_nums = response[&quot;hits&quot;][&quot;total&quot;]if(page%10) &gt;0: page_nums = int(total_nums/10)+1else: page_nums = int(total_nums/10) 测试搜索结果页result.html分页功能 在搜索结果页面搜索框下会显示对搜索字段数据的数据量页码数以及搜索用时时间，总页面数page_nums以及数据量total_nums在进行分页数据显示时已经在视图中进行获取并传递给模板了，现在只需要在视图中通过执行代码段时记录当前时间，执行搜索代码后再获取结束搜索的时间，进行减法操作即可获取搜索时间 123456789101112131415161718192021222324start_time = datetime.now()response = client.search( index=&quot;jobbole&quot;, body=&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: key_words, &quot;fields&quot;: [&quot;tags&quot;, &quot;title&quot;, &quot;content&quot;] &#125; &#125;, &quot;from&quot;: (page-1)*10, &quot;size&quot;: 10, &quot;highlight&quot;: &#123; &quot;pre_tags&quot;: [&apos;&lt;span class=&quot;keyWord&quot;&gt;&apos;], &quot;post_tags&quot;: [&apos;&lt;/span&gt;&apos;], &quot;fields&quot;: &#123; &quot;title&quot;: &#123;&#125;, &quot;content&quot;: &#123;&#125;, &#125; &#125; &#125;)end_time = datetime.now()last_seconds = (end_time-start_time).total_seconds() 在模板中进行数据填坑 1&lt;span class=&quot;info&quot;&gt;找到约&amp;nbsp;&lt;span class=&quot;totalResult&quot;&gt;&#123;&#123; total_nums &#125;&#125;&lt;/span&gt;&amp;nbsp;条结果(用时&lt;span class=&quot;time&quot;&gt;&#123;&#123; last_seconds &#125;&#125;&lt;/span&gt;秒)，共约&lt;span class=&quot;totalPage&quot;&gt;&#123;&#123; page_nums &#125;&#125;&lt;/span&gt;页&lt;/span&gt; 测试搜索华为，则成功显示搜索信息 9.搜索记录、热门搜索功能实现 在搜索结果页面左侧显示伯乐在线网站条目数据，该数据是通过scrapy爬取并写入到jobbole索引doc库中获取的数据，因此数据是随时变化的，所以需要将该数据保存到redis数据，这样读写效率就比较高了 首先需要在ArticleSpider伯乐在线爬虫项目环境中安装redis 在ArticleSpider项目pipelines/ElasticsearchPipeline管道类中使用redis incr方法往本地redis数据库0中保存名为jobbole的key并加1操作，当向es中保存一条数据时，则在redis数据库0中使jobbole_count的值+1，这样就可以统计伯乐在线网站文章数目 为了测试是否向我们预期那样每当执行redis_cli.incr(“jobbole_count”)代码时jobbole_count的值进行+1操作，在项目目录下新建一个test.py文件，测试代码如下 123456789# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/5 12:48' import redisredis_cli = redis.StrictRedis() redis_cli.incr(\"jobbole_count\") 通过run运行test.py成功后，查看redis 0数据库的数据，测试成功 回到LcvSearch django项目中在views视图中，获取redis数据库中的jobbole_count的值然后传递到模板中，在LcvSearch 环境中同样也需要安装redis，这个就不在演示了 1jobbole_count = redis_cli.get(\"jobbole_count\") 在模板中找到对应的标签字段打印jobbole_count的值即可 1234&lt;li&gt; &lt;span class=\"name\"&gt;伯乐在线&lt;/span&gt; &lt;span class=\"unit\"&gt;(&#123;&#123; jobbole_count &#125;&#125;)&lt;/span&gt;&lt;/li&gt; 刷新页面，则成功显示出保存到redis数据的jobbole的值，需要说明的是，因为没有运行ArticleSpider爬虫项目即当然不会执行ElasticsearchPipeline管道类中的代码，所以页面上显示的伯乐在线网站的数目为1 为了好看博主打算花一段时间重新爬取伯乐在线网站的文章数据 爬取一定时间后，不断刷新页面，伯乐在线网站的数据条目在不断的增加，因为爬虫项目同时在不停的爬取并写入的es中 在主页和搜索结果页面都会有我的搜索记录以及热门搜索排行显示，我的搜索实现过程就是当点击搜索按钮时会调用js中的add_search函数，在函数中获取input输入框中的关键字然后在函数中调用KillRepeat函数并将获取的关键字传递到该函数中，在KillRepeat函数中如果出现该关键字出现在我的搜索列表中，则会去删除列表中的该关键字也就是去重操作，然后将搜索的关键字保存到浏览器的localStorage缓存中，最后再调用MapSearchArr函数将搜索内容显示出来，之前在主页面已经通过js代码实现了我的搜索功能数据显示，所以现在重点是做热门搜索功能，在search模板中定义与index模板中相同的js代码即可，这个就不细说了 热门搜索功能数据显示，实现逻辑需要将热门搜索的关键字通过redis的zincrby命令将关键字keyword保存到redis数据库search_keywords_set键中并设定其increment增量值为1，再通过redis的zrangebyscore命令获取min 和 max 可以是 -inf 和 +inf区间分值的数据，具体的命令文档可以访问http://redisdoc.com/redis官方文档进行查阅 在views视图中编写以下代码即可，上面已经说明代码的作用 12redis_cli.zincrby(\"search_keywords_set\", 1, key_words)hot_search = redis_cli.zrangebyscore(\"search_keywords_set\", \"-inf\", \"+inf\", start=0, num=5) 在result模板中遍历打印显示出热门搜索关键字 12345678&lt;div class=\"hotSearch\"&gt; &lt;h6&gt;热门搜索&lt;/h6&gt; &lt;ul class=\"historyList\"&gt; &#123;% for search_word in hot_search %&#125; &lt;li&gt;&lt;a href=\"/search?q=&#123;&#123; search_word &#125;&#125;\"&gt;&#123;&#123; search_word &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/div&gt; 强制刷新搜索结果页面，成功显示出热门搜索关键词 在主页面，搜索框下的热门搜索也需要进行数据设置获取，之前显示主页面使用django提供的view，这里因为要向首页模板中传递redis数据库中的search_keywords_set键的数据，所以需要定义主页类视图IndexView get方法来渲染模板以及向模板传递数据 12345class IndexView(View): \"\"\"主页\"\"\" def get(self, request): hot_search = redis_cli.zrangebyscore(\"search_keywords_set\", \"-inf\", \"+inf\", start=0, num=5) return render(request, \"index.html\", &#123;\"hot_search\":hot_search&#125;) 然后在index模板中进行打印热门数据 123456&lt;p class=\"history\"&gt; &lt;label&gt;热门搜索：&lt;/label&gt; &#123;% for search_words in hot_search %&#125; &lt;a href=\"/search?q=&#123;&#123; search_words &#125;&#125;\"&gt;&#123;&#123; search_words &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125;&lt;/p&gt; 强制刷新主页，成功显示热门搜索关键词 二丶通过scrapyd部署scrapy爬虫1.在ArticleSpider项目的虚拟环境中安装scrapyd scrapyd的参考文档：https://scrapyd.readthedocs.io/en/stable/ 在scrapy_py3虚拟环境中安装scrapyd 安装scrapyd后，启动运行scrapyd命令成功，当访问http://127.0.0.1:6800/后点击进入jobs后，则出现如下错误 回到控制台查看运行报错日志，发现是全是指向twisted包的错误，博主猜想是twisted版本与scrapyd版本不兼容问题，于是回退安装twisted==18.9.0版本 安装twisted==18.9.0版本 重新刷新页面则不再报错，问题解决 启动scrapyd命令说白了可就是运行其服务器，运行成功后会在其目录下创建dbs目录，因为博主是在scrapy_p3虚拟环境中使用pip安装的scrapyd包，所以需要在d盘也就是博主的项目盘下创建test目录在test目录下创建scrapyd目录，然后在Terminal命令终端中进入创建好的scrapyd目录，执行scrapyd命令后，成功生成了dbs目录 2.安装及配置scrapyd客户端 安装scrapy-client包 在ArticleSpider爬虫项目下的scrapy.cfg配置文件中打开注释掉的url，并对deploy定义一个任意名称 123456[settings]default = ArticleSpider.settings [deploy:cdtaogang]url = http://localhost:6800/project = ArticleSpider 在虚拟环境scrapy_py3/Scripts目录下可以看到安装scrapyd-client包后生成的scrapyd-deploy文件，这个文件在linux系统中可以直接执行scrapyd-deploy命令，但是在windows中该文件并没有后缀名，所以无法执行scrapyd-deploy命令，这是一个巨坑；要想在windows中执行scrapyd-deploy命令，则需要在scrapy_py3/Scripts目录下新建一个scrapyd-deploy.bat批处理文件，并编写该文件如下内容；第一个路径为虚拟环境中使用的python解释器路径，第二个为scrapyd-deploy路径 123@echo off &quot;D:\\scrapy_py3\\Scripts\\python.exe&quot; &quot;D:\\scrapy_py3\\Scripts\\scrapyd-deploy&quot; %1 %2 %3 %4 %5 %6 %7 %8 %9 测试运行scrapyd-deploy -l命令打印出ArticleSpider项目scrapy.cfg配置数据，即配置scrapyd-client成功 在正式部署项目之前，需要执行scrapy list命令，确保能够打印出scrapy项目的name名称 3.项目部署 在ArticleSpider项目settings配置文件中还需要将ArticleSpider项目目录添加进来 123import sysBASE_DIR = os.path.dirname(os.path.abspath(os.path.dirname(__file__)))sys.path.insert(0, os.path.join(BASE_DIR, 'ArticleSpider')) 在Terminal终端中执行scrapyd-deploy cdtaogang -p ArticleSpider命令，参数就是之前的配置信息这个不多说，这个命令就相当于打包文件的意思 然后在test/scrapyd目录中生成了eggs/ArticleSpider目录下的1559740467.egg文件 使用scrapyd-deploy cdtaogang -p ArticleSpider命令将项目打包上传到服务器后，但是并没有运行，需要根据文档API说明执行文档中的curl命令 curl命令windows本身是没有的，但博主以前写项目的时候，安装过windows版本的curl命令程序，安装过Anaconda时也会默认安装curl命令，还有一种方法就是在windows中安装cmder程序，启动该程序可以执行curl命令 执行curl http://localhost:6800/daemonstatus.json命令可以查看scrapyd的状态 根据scrapyd文档上执行curl http://localhost:6800/schedule.json -d project=myproject -d spider=somespider命令来启动scrapy项目 启动ArticleSpider项目下的jobbole爬虫应用成功后，回到scrapyd服务器页面http://127.0.0.1:6800/jobs进行强制刷新后，则运行成功，因为页面不是自动刷新的，从下图可以看见运行时间，随时刷新页面这个时间都是在变化的，客户端运行结束后，就会显示finish的时间 演示以上博主所说的爬虫启动一直运行，而页面是需要手动刷新的 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/90763712","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://hellotaogang.github.io/tags/ElasticSearch/"},{"name":"Python Scrapy分布式爬虫","slug":"Python-Scrapy分布式爬虫","permalink":"https://hellotaogang.github.io/tags/Python-Scrapy分布式爬虫/"},{"name":"数据抓取","slug":"数据抓取","permalink":"https://hellotaogang.github.io/tags/数据抓取/"},{"name":"Django 网站搭建","slug":"Django-网站搭建","permalink":"https://hellotaogang.github.io/tags/Django-网站搭建/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django与Elasticsearch交互打造搜索引擎网站（一）","slug":"Django与Elasticsearch交互打造搜索引擎网站（一）","date":"2019-11-16T01:59:20.678Z","updated":"2019-11-16T03:37:16.570Z","comments":true,"path":"2019/11/16/Django与Elasticsearch交互打造搜索引擎网站（一）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/16/Django与Elasticsearch交互打造搜索引擎网站（一）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶叙述 二丶elasticsearch-rtf的安装与测试 三丶elasticsearch-head插件以及kibana的安装 四丶elasticsearch搜索引擎的使用 五丶使用scrapy爬取知名技术文章网站 六丶将scrapy爬取到的数据写入到elasticsearch中","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶叙述 二丶elasticsearch-rtf的安装与测试 三丶elasticsearch-head插件以及kibana的安装 四丶elasticsearch搜索引擎的使用 五丶使用scrapy爬取知名技术文章网站 六丶将scrapy爬取到的数据写入到elasticsearch中 一丶叙述1.项目介绍 通过scrapy爬取伯乐在线网站的全部文章数据通过elasticsearch_dsl工具将数据写入到elasticsearch中；再使用django开发一个搜索网站并且与elasticsearch进行数据交互来打造出一个高大上的搜索引擎网站。 2.项目展示 搜索引擎网站首页页面展示，当输入不完整的关键字时，会自动补全以及会显示出搜索建议 搜索结果页面显示，会对搜索的内容进行分词处理，并且在文章列表中会对分词后的字段进行高亮标红显示 动态效果展示，点击在搜索框输入python时的自动补全提示内容跳转到搜索结果列表页面 动态效果展示，直接在搜索框输入python后点击搜索按钮，跳转到搜索结果列表页，并在主页我的搜索项中显示搜索历史 在搜索结果页面同样有个搜索框，同样跟主页一样进行关键字搜索 3.什么是ElasticSearch ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 我们建立一个网站或应用程序，并要添加搜索功能，但是想要完成搜索工作的创建是非常困难的。我们希望搜索解决方案要运行速度快，我们希望能有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用JSON通过HTTP来索引数据，我们希望我们的搜索服务器始终可用，我们希望能够从一台开始并扩展到数百台，我们要实时搜索，我们要简单的多租户，我们希望建立一个云的解决方案。因此我们利用Elasticsearch来解决所有这些问题及可能出现的更多其它问题。 4.什么是Elasticsearch-RTF RTF是Ready To Fly的缩写，在航模里面，表示无需自己组装零件即可直接上手即飞的航空模型，Elasticsearch-RTF是针对中文的一个发行版，即使用最新稳定的elasticsearch版本，并且帮你下载测试好对应的插件，如中文分词插件等，目的是让你可以下载下来就可以直接的使用（虽然es已经很简单了，但是很多新手还是需要去花时间去找配置，中间的过程其实很痛苦），当然等你对这些都熟悉了之后，你完全可以自己去diy了，跟linux的众多发行版是一个意思。 二丶elasticsearch-rtf的安装与测试1.安装elasticsearch-rtf 在github上搜索elasticsearch-rtf，选择第一个点击进入如下页面下载即可 将下载好的elasticsearch-5.1.1.zip包，进行解压，需要注意的是解压的目录名称不能带中文，否则运行elasticsearch则会报错 因为elasticsearch是由java进行开发的，所以要运行elasticsearch则需要先安装java jdk8+；因为博主以前就安装过，所以这里不进行演示，网上有很多教程，安装完jdk后，在cmd窗口输入java -version则显示出安装成功后的jdk版本信息 在cmd中进入解压的elasticsearch文件bin目录下，执行elasticsearch.bat批处理文件 2.测试 在浏览器中访问上图日志中的ip及端口http://127.0.0.1:9200/，成功则出现如下页面 三丶elasticsearch-head插件以及kibana的安装1.elasticsearch-head插件安装 在github上搜索elasticsearch-head，选择第一个点击进入如下页面下载即可 博主这里直接使用git命令将elassearch-head下载下来，也可以直接在如上页面点击download进行下载 cd进入elassearch-head目录后，使用npm命令进行安装，需要注意的是npm命令就好比python中的pip一样，要想使用npm命令则需要下载安装windows版本的Node.js，安装Node.js成功后就可以直接使用npm命令了 运行elasticsearch-head插件，运行成功后，访问http://localhost:9100/页面 在elasticsearch-head插件页面无法连接http://127.0.0.1:9200/地址，如上图显示集群健康值:未连接，需要在elasticsearch解压文件config目录下elasticsearch.yml配置文件添加如下配置 1234http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;http.cors.allow-methods: OPTIONS, HEAD, GET, POST, PUT, DELETEhttp.cors.allow-headers: &quot;X-Requested-With, Content-Type, Content-Length, X-User&quot; 重启elasticsearch，回到http://localhost:9100/elasticsearch-head插件页面测试连接http://127.0.0.1:9200/接口，点击右上角的信息菜单选择信息则看到访问http://127.0.0.1:9200/接口所显示内容 2.kibana的安装 下载与elastsearch一致版本的kibana，否则会出错 下载成功后进行解压，然后打开cmd窗口进入解压文件bin目录下，执行kibana.bat批处理文件 在浏览器访问日志中监听的ip端口http://localhost:5601/ 四丶elasticsearch搜索引擎的使用说明：什么是Kibana：Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示；举例说明就好比mysql数据库的工具navicat一样 1.elasticsearch基本的索引和文档CRUD操作 启动Kibana服务 在浏览器中访问http://127.0.0.1:5601则进行Kibana可视化页面，在页面中选择Dev-Tools可以创建索引以及对查询索引的配置 如上图创建lagou索引后，回到elasticsearch-head工具页面，刷新后则出现创建的lagou索引 修改lagou索引配置 获取所有的索引信息 向索引中保存文档（向数据库添加表数据），注重说明一下可以将索引看做成数据库，type看作成数据表下的表后面跟着表的id，即PUT lagou/job/1，当添加数据时不指明id则也能添加成功能，系统会默认将id生成一个uuid的值 回到elasticsearch-head页面，点击数据浏览选择lagou就能看到在Kibana中添加的数据信息 获取lagou下的job表数据 获取lagou下的job表某个字段以及多个字段的数据，需要注意的是,后面不能留空格 修改lagou下的job表id为1数据，也是使用PUT进行修改，这种修改时覆盖式的修改 使用POST修改lagou下的job表id为1的数据 删除lagou/job表下id为1的所有数据 删除lagou索引 2.elasticsearch的mget和bulk批量操作 在使用mget查询之前需要添加些查询数据 12345678910111213141516PUT testdb/job1/1&#123; &quot;title&quot;:&quot;test_job1_1&quot;&#125;PUT testdb/job1/2&#123; &quot;title&quot;:&quot;test_job1_2&quot;&#125;PUT testdb/job2/1&#123; &quot;title&quot;:&quot;test_job2_1&quot;&#125;PUT testdb/job2/2&#123; &quot;title&quot;:&quot;test_job2_2&quot;&#125; 查看添加后的索引数据信息 使用mget查询多个条件数据 当index一致时，就可以进行如下查询 12345678910111213GET testdb/_mget&#123; &quot;docs&quot;:[ &#123; &quot;_type&quot;:&quot;job1&quot;, &quot;_id&quot;:1 &#125;, &#123; &quot;_type&quot;:&quot;job2&quot;, &quot;_id&quot;:2 &#125; ]&#125; 以此类推当index和type相同都是job1时只有id不同的情况下，可以进行如下查询 使用bulk批量操作，添加lagou索引并在其下创建job1和job2两个type以及对应的id 3.elasticsearch的mapping映射管理 说明：关于elasticsearch的mapping的概念可以百度进行了解 为了方便演示创建索引的映射，博主需要将之前创建的索引全部删除 创建索引映射 向创建好的索引映射中插入数据 获取索引下的mapping 获取集群下的所有mapping 4.elasticsearch的简单查询 删除lagou索引，然后创建新的lagou索引并添加映射 向索引中添加查询数据 使用match匹配查询title字段包含python开发的数据，在创建索引映射时title字段使用的是ik_max_word，该工具会对此字段不管大小写都会转换成小写并且会对title字段进行中英文分词处理，所以在使用match进行匹配查询时，就会查询到如下两条数据 而使用term进行查询时，会根据传入的title的值也就是python开发进行全局匹配不会进行分词处理，通俗来说在数据title字段内容必须不多不少是”python开发”才能查询到数据，所以如下没有查询到数据 使用terms进行查询，对满足数组中的任何内容的title字段数据就会查询出来 控制查询数据返回数量，实际匹配出两条数据，但form从0开始取只往后取一个，即结果只显示出一条数据 使用match_all查询所有数据 使用match_phrase查询，会将查询的内容进行分词，slop表示的是分词之间的长度，也就是说python和总监之间的长度，要满足该长度内才能查询出数据 multi_match查询，指定在title和desc字段中查询包含python的数据 指定返回title以及company_name字段数据 通过sort把结果排序 range范围查询comments大于等于1000小于等于2000的数据，boost表示权重 使用range对时间范围进行查询 5.elasticsearch的bool组合查询 说明 bool组合查询包括：must丶should丶must_not丶filter来完成 bool组合查询的格式如下 123456bool:&#123; &quot;must&quot;:[], &quot;should&quot;:[], &quot;must_not&quot;:[], &quot;filter&quot;:[]&#125; 删除之前的索引，重新创建测试数据 从查询到的所有数据中筛选出salary为2000的数据 使用ik_max_word查看分析器解析的结果 使用ik_smart查看分析器解析结果 组合过滤查询薪资等于2000或者工作为Python的数据并且满足薪水不为3000的数据 嵌套查询工作为python或者工作为django并且工资为3000的数据 过滤空和非空数据，首先创建测试数据 查询tags字段不为null的数据 整个在Kibana中的操作命令如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513# 创建lagou索引PUT lagou&#123; &quot;settings&quot;: &#123; &quot;index&quot;:&#123; &quot;number_of_shards&quot;:5, &quot;number_of_replicas&quot;:1 &#125; &#125;&#125;# 获取lagou的配置GET lagou/_settings# 获取所有索引的配置GET _all/_settings# 获取kibana和lagou索引配置GET .kibana,lagou/_settings# 修改lagou索引的配置,shards一旦设置了值就无法修改PUT lagou/_settings&#123; &quot;number_of_replicas&quot;: &quot;3&quot;&#125;# 获取所有的索引信息GET _all# 向索引中保存文档PUT lagou/job/1&#123; &quot;title&quot;:&quot;Python分布式爬虫打造搜索引擎&quot;, &quot;min_salary&quot;:15000, &quot;city&quot;:&quot;成都&quot;, &quot;company&quot;:&#123; &quot;name&quot;:&quot;百度&quot;, &quot;company_add&quot;:&quot;天府软件园&quot; &#125;, &quot;publish_date&quot;:&quot;2019-06-01&quot;, &quot;comments&quot;:20&#125;# 获取lagou下的job表数据GET lagou/job/1# 获取lagou下的job表某个字段的数据GET lagou/job/1?_source=title# 获取lagou下的job表多个字段的数据GET lagou/job/1?_source=title,city#使用PUT修改lagou下的job表id为1的数据PUT lagou/job/1&#123; &quot;title&quot;:&quot;Python分布式爬虫打造搜索引擎&quot;, &quot;min_salary&quot;:20000, &quot;city&quot;:&quot;成都&quot;, &quot;company&quot;:&#123; &quot;name&quot;:&quot;百度&quot;, &quot;company_add&quot;:&quot;天府软件园&quot; &#125;, &quot;publish_date&quot;:&quot;2019-06-01&quot;, &quot;comments&quot;:20&#125;# 使用POST修改lagou下的job表id为1的数据POST lagou/job/1/_update&#123; &quot;doc&quot;: &#123; &quot;comments&quot;:50 &#125;&#125; # 删除lagou/job表下id为1的所有数据DELETE lagou/job/1# 删除lagou索引 DELETE lagou PUT testdb/job1/1&#123; &quot;title&quot;:&quot;test_job1_1&quot;&#125;PUT testdb/job1/2&#123; &quot;title&quot;:&quot;test_job1_2&quot;&#125;PUT testdb/job2/1&#123; &quot;title&quot;:&quot;test_job2_1&quot;&#125;PUT testdb/job2/2&#123; &quot;title&quot;:&quot;test_job2_2&quot;&#125; # 使用mget查询多个条件数据GET _mget&#123; &quot;docs&quot;:[ &#123; &quot;_index&quot;:&quot;testdb&quot;, &quot;_type&quot;:&quot;job1&quot;, &quot;_id&quot;:1 &#125;, &#123; &quot;_index&quot;:&quot;testdb&quot;, &quot;_type&quot;:&quot;job2&quot;, &quot;_id&quot;:2 &#125; ]&#125;# 当index一致时，就可以进行如下查询GET testdb/_mget&#123; &quot;docs&quot;:[ &#123; &quot;_type&quot;:&quot;job1&quot;, &quot;_id&quot;:1 &#125;, &#123; &quot;_type&quot;:&quot;job2&quot;, &quot;_id&quot;:2 &#125; ]&#125;# 当index和type相同都是job1时只有id不同GET testdb/job1/_mget&#123; &quot;docs&quot;:[ &#123; &quot;_id&quot;:1 &#125;, &#123; &quot;_id&quot;:2 &#125; ]&#125; # 使用bulk批量操作POST _bulk&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;lagou&quot;, &quot;_type&quot;:&quot;job1&quot;, &quot;_id&quot;:1&#125;&#125;&#123;&quot;title&quot;:&quot;Python分布式爬虫打造搜索引擎&quot;, &quot;min_salary&quot;:16000,&quot;city&quot;:&quot;成都&quot;,&quot;comany&quot;:&#123;&quot;name&quot;:&quot;百度&quot;,&quot;company_addr&quot;:&quot;天府软件A园&quot;&#125;,&quot;publish_date&quot;:&quot;2019-06-01&quot;,&quot;comments&quot;:15&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;lagou&quot;, &quot;_type&quot;:&quot;job2&quot;, &quot;_id&quot;:2&#125;&#125;&#123;&quot;title&quot;:&quot;Django Web开发&quot;, &quot;min_salary&quot;:20000,&quot;city&quot;:&quot;成都&quot;,&quot;comany&quot;:&#123;&quot;name&quot;:&quot;腾讯&quot;,&quot;company_addr&quot;:&quot;天府软件B园&quot;&#125;,&quot;publish_date&quot;:&quot;2019-05-20&quot;,&quot;comments&quot;:30&#125; # 创建索引映射 PUT lagou&#123; &quot;mappings&quot;: &#123; &quot;job&quot;:&#123; &quot;properties&quot;: &#123; &quot;title&quot;:&#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;min_salary&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;city&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;company&quot;:&#123; &quot;properties&quot;: &#123; &quot;name&quot;:&#123; &quot;type&quot;:&quot;text&quot; &#125;, &quot;company_addr&quot;:&#123; &quot;type&quot;:&quot;text&quot; &#125;, &quot;employee_count&quot;:&#123; &quot;type&quot;:&quot;integer&quot; &#125; &#125; &#125;, &quot;publish_date&quot;:&#123; &quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd&quot; &#125;, &quot;comments&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125; &#125; &#125; &#125;&#125; # 向索引插入数据PUT lagou/job/1&#123; &quot;title&quot;:&quot;Python分布式爬虫打造搜索引擎&quot;, &quot;min_salary&quot;:20000, &quot;city&quot;:&quot;成都&quot;, &quot;company&quot;:&#123; &quot;name&quot;:&quot;百度&quot;, &quot;company_add&quot;:&quot;天府软件园&quot;, &quot;employee&quot;:200 &#125;, &quot;publish_date&quot;:&quot;2019-06-01&quot;, &quot;comments&quot;:20&#125; # 获取索引下的mappingGET lagou/_mapping # 获取集群下的所有mappingGET _all/_mapping # 添加映射PUT lagou&#123; &quot;mappings&quot;: &#123; &quot;job&quot;:&#123; &quot;properties&quot;: &#123; &quot;title&quot;:&#123; &quot;store&quot;: true, &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;company_name&quot;:&#123; &quot;store&quot;: true, &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;desc&quot;:&#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;comments&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;add_time&quot;:&#123; &quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd&quot; &#125; &#125; &#125; &#125;&#125;# 向索引中添加查询数据POST lagou/job/&#123; &quot;title&quot;:&quot;Django Web开发工程师&quot;, &quot;company_name&quot;:&quot;阿里巴巴网络技术有限公司&quot;, &quot;desc&quot;:&quot;精通Python&quot;, &quot;comments&quot;:1200, &quot;add_time&quot;:&quot;2019-02-14&quot;&#125;POST lagou/job/&#123; &quot;title&quot;:&quot;数据挖掘工程师&quot;, &quot;company_name&quot;:&quot;百度在线网络技术有限公司&quot;, &quot;desc&quot;:&quot;10年工作经验&quot;, &quot;comments&quot;:1000, &quot;add_time&quot;:&quot;2019-03-16&quot;&#125;POST lagou/job/&#123; &quot;title&quot;:&quot;Python人工智能技术总监&quot;, &quot;company_name&quot;:&quot;华为技术有限公司&quot;, &quot;desc&quot;:&quot;能分析和解决疑难问题&quot;, &quot;comments&quot;:3000, &quot;add_time&quot;:&quot;2019-06-18&quot;&#125; # 使用match查询GET lagou/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;python开发&quot; &#125; &#125;&#125; # 使用term查询GET lagou/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;title&quot;: &quot;python开发&quot; &#125; &#125;&#125; # 使用terms查询GET lagou/_search&#123; &quot;query&quot;: &#123; &quot;terms&quot;: &#123; &quot;title&quot;: [&quot;智能&quot;, &quot;挖掘&quot;, &quot;web&quot;] &#125; &#125;&#125; # 控制查询数据返回数量GET lagou/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;工程师&quot; &#125; &#125;, &quot;from&quot;: 0, &quot;size&quot;: 1&#125; # match_all查询所有数据GET lagou/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; # match_phrase查询GET lagou/_search&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;title&quot;:&#123; &quot;query&quot;: &quot;python总监&quot;, &quot;slop&quot;:6 &#125; &#125; &#125;&#125;# multi_match查询,指定在title和desc字段中查询#包含python的数据GET lagou/_search&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;python&quot;, &quot;fields&quot;: [&quot;title&quot;, &quot;desc&quot;] &#125; &#125;&#125;# 指定返回的哪些字段数据GET lagou/_search&#123; &quot;stored_fields&quot;: [&quot;title&quot;, &quot;company_name&quot;], &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;pythona&quot; &#125; &#125;&#125;# 通过sort把结果排序GET lagou/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;comments&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125; ]&#125;# range范围查询GET lagou/_search&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;comments&quot;: &#123; &quot;gte&quot;: 1000, &quot;lte&quot;: 2000, &quot;boost&quot;: 1 &#125; &#125; &#125;&#125; # 使用range对时间范围进行查询GET lagou/_search&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;add_time&quot;: &#123; &quot;gte&quot;: &quot;2019-01-01&quot;, &quot;lte&quot;: &quot;now&quot; &#125; &#125; &#125;&#125; # bool查询 #bool:&#123;# &quot;must&quot;:[],# &quot;should&quot;:[],# &quot;must_not&quot;:[],# &quot;filter&quot;:[]#&#125;# 建立测试数据POST lagou/testjob/_bulk&#123;&quot;index&quot;:&#123;&quot;_id&quot;:1&#125;&#125;&#123;&quot;salary&quot;:1000, &quot;title&quot;:&quot;Python&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:2&#125;&#125;&#123;&quot;salary&quot;:2000, &quot;title&quot;:&quot;Django&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:3&#125;&#125;&#123;&quot;salary&quot;:3000, &quot;title&quot;:&quot;Flask&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:4&#125;&#125;&#123;&quot;salary&quot;:4000, &quot;title&quot;:&quot;Scrapy&quot;&#125; # 从查询到的所有数据中筛选出salary为2000的数据# 对应数据库查询语句为# select * from testjob where salary=2000;GET lagou/testjob/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123;&quot;match_all&quot;: &#123;&#125;&#125; ], &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;salary&quot;: &quot;2000&quot; &#125; &#125; &#125; &#125;&#125;# 查看分析器解析的结果GET _analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;Python Web开发工程师&quot;&#125;# 查看分析器解析的结果GET _analyze&#123; &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;Python Web开发工程师&quot;&#125; # 组合过滤查询薪资等于2000或者工作为Python的数据并且满足薪水不为3000的数据# select * from testjob where (salary=2000 or title=&quot;Python&quot;) and (salary !=3000); GET lagou/testjob/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;should&quot;: [ &#123;&quot;term&quot;: &#123; &quot;salary&quot;: &#123; &quot;value&quot;: &quot;2000&quot; &#125; &#125;&#125;, &#123;&quot;term&quot;: &#123; &quot;title&quot;: &#123; &quot;value&quot;: &quot;python&quot; &#125; &#125;&#125; ], &quot;must_not&quot;: [ &#123;&quot;term&quot;: &#123; &quot;salary&quot;: &#123; &quot;value&quot;: &quot;3000&quot; &#125; &#125;&#125; ] &#125; &#125;&#125; # 嵌套查询工作为python或者工作为django并且工资为3000的数据# select * from testjob where title=&quot;python&quot; or (title=&quot;django&quot; and salary=3000) GET lagou/testjob/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;should&quot;: [ &#123;&quot;term&quot;: &#123; &quot;title&quot;: &#123; &quot;value&quot;: &quot;python&quot; &#125; &#125;&#125;, &#123;&quot;bool&quot;: &#123; &quot;must&quot;: [ &#123;&quot;term&quot;: &#123; &quot;title&quot;: &#123; &quot;value&quot;: &quot;django&quot; &#125; &#125;&#125;, &#123;&quot;term&quot;: &#123; &quot;salary&quot;: &#123; &quot;value&quot;: &quot;3000&quot; &#125; &#125;&#125; ] &#125;&#125; ] &#125; &#125;&#125;# 过滤空和非空数据，首先创建测试数据POST lagou/testjob2/_bulk&#123;&quot;index&quot;:&#123;&quot;_id&quot;:1&#125;&#125;&#123;&quot;tags&quot;:[&quot;search&quot;]&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:2&#125;&#125;&#123;&quot;tags&quot;:[&quot;search&quot;, &quot;python&quot;]&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:3&#125;&#125;&#123;&quot;other_field&quot;:[&quot;some data&quot;]&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:4&#125;&#125;&#123;&quot;tags&quot;:null&#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:5&#125;&#125;&#123;&quot;tags&quot;:[&quot;search&quot;, null]&#125; # 查询tags字段不为null的数据# select tags from testjob2 where tags is not null;GET lagou/testjob2/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;filter&quot;: &#123; &quot;exists&quot;: &#123; &quot;field&quot;: &quot;tags&quot; &#125; &#125; &#125; &#125;&#125; 五丶使用scrapy爬取知名技术文章网站1.创建爬虫项目虚拟环境 2.进入虚拟环境安装scrapy以及requests 3.创建scrapy项目 在cmd终端中执行scrapy startproject ArticleSpider即创建scrapy 爬虫项目ArticleSpider 在Pycharm中打开ArticleSpider项目 创建jobbole爬虫文件 即在项目spider目录下生成jobbole.py文件 4.运行scrapy项目测试是否能够运行成功 在终端执行scrapy crawl jobbole命令，结果报错了 对于windows系统而言报这个错是正常的，使用pip命令安装pypiwin32包即可 安装成功后再次运行则启动scrapy成功 5.爬取伯乐在线网站的某篇文章 在网站全部文章分类中爬取该篇文章 博主这里使用xpath来匹配要爬取的文章的标题丶发布时间丶标签丶文章内容丶点赞数丶收藏数以及评论数 因为Pycharm未提供scrapy模板，要想使用Debug进行断点测试，需要在项目根目录下创建main.py文件，文件代码如下，也就是执行爬虫的命令scrapy crawl jobbole 1234567from scrapy.cmdline import executeimport sysimport os sys.path.append(os.path.dirname(os.path.abspath(__file__)))execute([\"scrapy\", \"crawl\", \"jobbole\"]) 在jobbole.py文件parse方法中使用xpath匹配获取标题丶发布时间丶标签丶文章内容丶点赞数丶收藏数以及评论数数据 123456789101112131415161718192021222324252627def parse(self, response): # 标题 title = response.xpath(\"//div[@class='entry-header']/h1/text()\").extract()[0] # 发表时间 create_date = response.xpath(\"//p[@class='entry-meta-hide-on-mobile']/text()\").extract()[0].strip().replace(\" ·\", \"\") # 点赞数 praise_num = response.xpath(\"//h10/text()\").extract()[0] # 收藏数 fav_nums = response.xpath(\"//span[contains(@class, 'bookmark-btn')]/text()\").extract()[0] # 使用re正则匹配获取收藏数 match_re = re.match(\".*(\\d+).*\", fav_nums) if match_re: fav_nums = match_re.group(1) # 评论数 comment_nums = response.xpath(\"//span[contains(@class, 'hide-on-480')]/text()\").extract()[0] # 使用re正则匹配获取评论数 match_re = re.match(\".*(\\d+).*\", comment_nums) if match_re: comment_nums = match_re.group(1) # 文章内容 content = response.xpath(\"//div[@class='entry']\").extract()[0] # 获取文章的tag标签 tag_list = response.xpath(\"//p[@class='entry-meta-hide-on-mobile']/a/text()\").extract() # 使用列表生成式过滤评论标签 tag_list = [element for element in tag_list if not element.strip().endswith('评论')] tags = ','.join(tag_list) pass 因为是爬取某一篇文章，所以在jobbole.py中的start_urls需要修改成要爬取的文章地址 1start_urls = [&apos;http://blog.jobbole.com/114690/&apos;] Debug运行main.py文件，断点测试获取数据成功且正确 6.爬取伯乐在线网站中的所有文章 首先在http://blog.jobbole.com/all-posts/ 伯乐在线网站所有文章页面使用xpath 谷歌插件来获取页面中的20篇文章的url地址 在Terminal终端中通过scrapy shell 命令测试获取所有文章页面的数据，并使用xpath来获取页面中文章url地址，命令为scrapy shell http://blog.jobbole.com/all-posts/ 当获取到列表页中20篇文章的url后，当scrapy进行页面数据下载后，需要回调给parse_detail方法进行页面字段的提取操作，这是第一步，第二步就是获取列表下一页的页面数据在parse函数中只要next_url提取存在，则会将此页面数据交给parse函数进行处理依次类推重复循环直到news_url不存在 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class JobboleSpider(scrapy.Spider): name = 'jobbole' allowed_domains = ['blog.jobbole.com'] start_urls = ['http://blog.jobbole.com/all-posts/'] def parse(self, response): \"\"\" 1.获取所有文章列表页中文章的url并交给解析函数对具体字段进行解析 2.获取列表页下一页的url地址并交给scrapy进行页面数据下载，下载完后交给parse函数进行字段获取 :param response: :return: \"\"\" # 1.获取列表页中所有文章url post_urls = response.xpath(\"//div[@class='post floated-thumb']/div[@class='post-thumb']/a/@href\").extract() for post_url in post_urls: # 为了防止有些文章链接不带域名前缀，所以需要对对链接地址进行域名凭借，需使用urllib提供的parse工具中的urljoin方法 # 使用scrapy提供的Request类，将获取的文章内容通过callback回调函数交给parse_detail方法对页面内容字段进行获取 yield Request(url=parse.urljoin(response.url, post_url), callback=self.parse_detail) # 2.获取列表页下一页的url地址并交给scrapy进行页面数据下载 next_url = response.xpath(\"//a[@class='next page-numbers']/@href\").extract_first(\"\") if next_url: yield Request(url=parse.urljoin(response.url, next_url), callback=self.parse) def parse_detail(self, response): \"\"\"获取文章详情页中的字段数据\"\"\" # 标题 title = response.xpath(\"//div[@class='entry-header']/h1/text()\").extract()[0] # 发表时间 create_date = response.xpath(\"//p[@class='entry-meta-hide-on-mobile']/text()\").extract()[0].strip().replace(\" ·\", \"\") # 点赞数 praise_num = response.xpath(\"//h10/text()\").extract()[0] # 收藏数 fav_nums = response.xpath(\"//span[contains(@class, 'bookmark-btn')]/text()\").extract()[0] # 使用re正则匹配获取收藏数 match_re = re.match(\".*(\\d+).*\", fav_nums) if match_re: fav_nums = match_re.group(1) # 评论数 comment_nums = response.xpath(\"//span[contains(@class, 'hide-on-480')]/text()\").extract()[0] # 使用re正则匹配获取评论数 match_re = re.match(\".*(\\d+).*\", comment_nums) if match_re: comment_nums = match_re.group(1) # 文章内容 content = response.xpath(\"//div[@class='entry']\").extract()[0] # 获取文章的tag标签 tag_list = response.xpath(\"//p[@class='entry-meta-hide-on-mobile']/a/text()\").extract() # 使用列表生成式过滤评论标签 tag_list = [element for element in tag_list if not element.strip().endswith('评论')] tags = ','.join(tag_list) Debug测试是否成功爬取文章指定字段数据 在上图中红框提取的评论数显示的不是数字而是评论，访问该篇文章，发现该文章并没有评论 回到代码中对评论数和收藏数正则匹配不成功时需要进行逻辑判断，不存在默认为0 1234567891011match_re = re.match(\".*(\\d+).*\", fav_nums)if match_re: fav_nums = int(match_re.group(1))else: fav_nums = 0 match_re = re.match(\".*(\\d+).*\", comment_nums)if match_re: comment_nums = int(match_re.group(1))else: comment_nums = 0 再次测试则显示评论数为0 7.将爬取的数据保存到本地项目中 分析：除了需要提取文章详情里面的字段内容外，在文章列表页中每篇文章的封面图的URL地址也是需要进行提取的 因为文章的链接地址与封面图片地址都在a标签节点之下，所以需要修改之前的代码获取a节点列表，再通过遍历获取每一个a节点，在根据a节点来匹配获取文章地址以及封面图地址 在parse_detail方法中获取response中meta字典属性中cover_image_url的值 在items文件中定义数据模型 123456789101112class JobBoleArticleItem(scrapy.Item): title = scrapy.Field() create_date = scrapy.Field() url = scrapy.Field() url_object_id = scrapy.Field() cover_image_url = scrapy.Field() cover_image_path = scrapy.Field() praise_nums = scrapy.Field() comment_nums = scrapy.Field() fav_nums = scrapy.Field() tags = scrapy.Field() content = scrapy.Field() 在jobbole文件parse_detail方法中将提取的数据保存到items对应字段中 123456789101112# 将提取到的字段数据传递给items中article = JobBoleArticleItem()article[&apos;title&apos;] = titlearticle[&apos;create_date&apos;] = create_datearticle[&apos;url&apos;] = response.urlarticle[&apos;cover_image_url&apos;] = cover_image_urlarticle[&apos;praise_nums&apos;] = praise_numsarticle[&apos;comment_nums&apos;] = comment_numsarticle[&apos;fav_nums&apos;] = fav_numsarticle[&apos;tags&apos;] = tagsarticle[&apos;content&apos;] = contentyield article 在settings中配置使用pipelines数据管道文件 123ITEM_PIPELINES = &#123; 'ArticleSpider.pipelines.ArticlespiderPipeline': 300,&#125; Debug测试在pipelines中获取item数据 需要将封面图片下载到项目根目录下的images目录下，首先需要在根目录下新建images目录，用于存放下载的封面图；然后需要在settings中pipeline配置中添加scrapy提供的图片下载的管道类ImagesPipeline；紧接着需要settings中指定items中的cover_image_url字段为图片下载地址，最后一步就是settings中指定图片下载后保存的目录路径images 直接run运行main.py文件启动scrapy爬虫项目，结果提示如下错误 因为PIL属于pillow包下的模块，所以安装pillow即可 重新run运行项目，结果又报错了，原因是使用scrapy的ImagesPipeline类，会将settings中配置的IMAGES_URLS_FIELD的值也就是封面图地址数据当作列表数据，但在代码中设置的article[‘cover_image_url’]的值不是列表数据，所以就出现如下异常错误 即在parse_detail函数中将提取的cover_image_url变量修改列表数据即可 1article[&apos;cover_image_url&apos;] = [cover_image_url] 重新启动项目，则成功下载文章封面图到images目录下 在下载图片的时候也需要将图片保存的路径保存起来，需要继承scrapy提供的ImagesPipeline类，并重新父类的item_completed方法在方法中将遍历获取的图片路径保存到items中cover_image_path字段中，首先需要在pipelines文件中定义ArticleImagePipeline类完成逻辑 1234567class ArticleImagePipeline(ImagesPipeline): def item_completed(self, results, item, info): if \"cover_image_url\" in item: for ok, value in results: image_file_path = value[\"path\"] item[\"cover_image_path\"] = image_file_path return item 紧接着在settings中修改管道文件配置为上面定义的管道类 12345ITEM_PIPELINES = &#123; &apos;ArticleSpider.pipelines.ArticlespiderPipeline&apos;: 300, # &apos;scrapy.pipelines.images.ImagesPipeline&apos;: 1, &apos;ArticleSpider.pipelines.ArticleImagePipeline&apos;: 1,&#125; Debug断点测试在执行ArticlespiderPipeline管道类中时是否获取到cover_image_path图片存放路径，说明因为在以上settings中配置的继承scrapy的ImagesPipeline类的管道类ArticleImagePipeline的优先级为1，所以程序在执行管道文件时是先将image_file_path的值也就是图片路径保存到item实例对象的cover_image_path字段中的 接下来在items字段中只差url_object_id的值了，这个值是将response.url也就是文章的地址通过hashlib库中的md5对象的update方法将文章url转换成唯一且长度一致的值，在项目目录下创建utils包并在该包下创建common.py文件，文件代码如下 123456789101112import hashlib def get_md5(url): if isinstance(url, str): url = url.encode(\"utf-8\") m = hashlib.md5() m.update(url) return m.hexdigest() if __name__ == \"__main__\": print (get_md5(\"http://jobbole.com\")) 执行以上代码，则将http://jobbole.com转换成唯一标识符 在parse_detail函数中设置url_object_id的值 1article['url_object_id'] = get_md5(response.url) Debug测试items中是否存在url_object_id的值 将文章详情页中提取的字段数据保存到本地，需要在pipelines文件中定义管道类将item数据保存到本地文件中 12345678910class JsonWithEncodingPipeline(object): #自定义json文件的导出 def __init__(self): self.file = codecs.open('article.json', 'w', encoding=\"utf-8\") def process_item(self, item, spider): lines = json.dumps(dict(item), ensure_ascii=False) + \"\\n\" self.file.write(lines) return item def spider_closed(self, spider): self.file.close() 在settings中配置以上管道文件 123456ITEM_PIPELINES = &#123; &apos;ArticleSpider.pipelines.JsonWithEncodingPipeline&apos;:2, # &apos;ArticleSpider.pipelines.ArticlespiderPipeline&apos;: 300, # &apos;scrapy.pipelines.images.ImagesPipeline&apos;: 1, &apos;ArticleSpider.pipelines.ArticleImagePipeline&apos;: 1,&#125; 运行项目，在下项目根目录成功创建article.json文件，并将爬取到的字段数据写入到文件中 还有一种方法就是使用scrapy提供的JsonItemExporter类实例对象的exporting方法将item数据写入到文件对象中 1234567891011121314class JsonExporterPipleline(object): #调用scrapy提供的json export导出json文件 def __init__(self): self.file = open('articleexport.json', 'wb') self.exporter = JsonItemExporter(self.file, encoding=\"utf-8\", ensure_ascii=False) self.exporter.start_exporting() def close_spider(self, spider): self.exporter.finish_exporting() self.file.close() def process_item(self, item, spider): self.exporter.export_item(item) return item 在settings配置文件中配置以上管道类 1234567ITEM_PIPELINES = &#123; &apos;ArticleSpider.pipelines.JsonExporterPipleline&apos;:2, # &apos;ArticleSpider.pipelines.JsonWithEncodingPipeline&apos;:2, # &apos;ArticleSpider.pipelines.ArticlespiderPipeline&apos;: 300, # &apos;scrapy.pipelines.images.ImagesPipeline&apos;: 1, &apos;ArticleSpider.pipelines.ArticleImagePipeline&apos;: 1,&#125; 运行项目，在下项目根目录成功创建articleexport.json文件，并将爬取到的字段数据写入到文件中 8.将爬取的数据保存到数据库中 在mysql数据库中创建数据库以及表 需要在parse_detail方法中对create_date字段数据转换成date格式的数据 1234try: create_date = datetime.datetime.strptime(create_date, \"%Y/%m/%d\").date()except Exception as e: create_date = datetime.datetime.now().date() 安装mysqlclient驱动包 在管道文件中编写存储数据到mysql的管道类 12345678910class MysqlPipeline(object): #采用同步的机制写入mysql def __init__(self): self.conn = MySQLdb.connect('localhost', 'root', 'mysql', 'article_spider', charset=\"utf8\", use_unicode=True) self.cursor = self.conn.cursor() def process_item(self, item, spider): insert_sql = \"\"\"insert into article(url_object_id, title, url, create_date, fav_nums)VALUES (%s, %s, %s, %s, %s)\"\"\" self.cursor.execute(insert_sql, (item[\"url_object_id\"], item[\"title\"], item[\"url\"], item[\"create_date\"], item[\"fav_nums\"])) self.conn.commit() 在settings中配置以上管道类，为了演示将数据保存到mysql数据库所以博主这里将图片管道文件注释掉了 12345678ITEM_PIPELINES = &#123; &apos;ArticleSpider.pipelines.JsonExporterPipleline&apos;:2, # &apos;ArticleSpider.pipelines.JsonWithEncodingPipeline&apos;:2, # &apos;ArticleSpider.pipelines.ArticlespiderPipeline&apos;: 300, # &apos;scrapy.pipelines.images.ImagesPipeline&apos;: 1, # &apos;ArticleSpider.pipelines.ArticleImagePipeline&apos;: 1, &apos;ArticleSpider.pipelines.MysqlPipeline&apos;: 1,&#125; Debug断点测试是否将要保存到数据库的字段数据成功保存到数据库 使用Navicat工具打开article表数据 退出Debug模式直接run运行后，在Navicat工具中查看爬取的字段数据，由于文章太多所以只爬取一定时间的文字字段数据 当爬取的数据量比较大时，可以使用异步方式将数据写入到数据库中，首先需要在pipelines文件中定义MysqlTwistedPipeline类，逻辑代码如下 123456789101112131415161718192021222324252627282930class MysqlTwistedPipeline(object): def __init__(self, dbpool): self.dbpool = dbpool @classmethod def from_settings(cls, settings): dbparms = dict( host = settings[\"MYSQL_HOST\"], db = settings[\"MYSQL_DBNAME\"], user = settings[\"MYSQL_USER\"], passwd = settings[\"MYSQL_PASSWORD\"], charset='utf8', cursorclass=MySQLdb.cursors.DictCursor, use_unicode=True, ) dbpool = adbapi.ConnectionPool(\"MySQLdb\", **dbparms) return cls(dbpool) def process_item(self, item, spider): # 使用twisted将mysql插入变成异步执行 query = self.dbpool.runInteraction(self.do_insert, item) query.addErrback(self.handle_error, item, spider) # 处理异常 def handle_error(self, failure, item, spider): # 处理异步插入的异常 print(failure) def do_insert(self, cursor, item): insert_sql = \"\"\"insert into article(url_object_id, title, url, create_date, fav_nums)VALUES (%s, %s, %s, %s, %s)\"\"\" cursor.execute(insert_sql, (item[\"url_object_id\"], item[\"title\"], item[\"url\"], item[\"create_date\"], item[\"fav_nums\"])) 在settings配置文件中配置连接mysql数据库的配置项 1234MYSQL_HOST = &quot;localhost&quot;MYSQL_DBNAME = &quot;article_spider&quot;MYSQL_USER = &quot;root&quot;MYSQL_PASSWORD = &quot;mysql&quot; 在settings中配置定义异步写入数据库数据的管道类 123456789ITEM_PIPELINES = &#123; # &apos;ArticleSpider.pipelines.JsonExporterPipleline&apos;:2, &apos;ArticleSpider.pipelines.JsonWithEncodingPipeline&apos;:2, # &apos;ArticleSpider.pipelines.ArticlespiderPipeline&apos;: 300, # &apos;scrapy.pipelines.images.ImagesPipeline&apos;: 1, # &apos;ArticleSpider.pipelines.ArticleImagePipeline&apos;: 1, # &apos;ArticleSpider.pipelines.MysqlPipeline&apos;: 1, &apos;ArticleSpider.pipelines.MysqlTwistedPipeline&apos;: 1,&#125; 六丶将scrapy爬取到的数据写入到elasticsearch中重点：因为博主使用的Elasticsearch版本为5.1.1，所以在安装elasticsearch-dsl工具的版本应该在5.0.0,&lt;6.0.0之间，最新的elasticsearch-dsl版本为7.0，该最新版本与前面版本做了一些修改所涉及的代码以及用法都不一样，参考github上的文档即可https://github.com/elastic/elasticsearch-dsl-py 1234567891011# Elasticsearch 7.xelasticsearch-dsl&gt;=7.0.0,&lt;8.0.0 # Elasticsearch 6.xelasticsearch-dsl&gt;=6.0.0,&lt;7.0.0 # Elasticsearch 5.xelasticsearch-dsl&gt;=5.0.0,&lt;6.0.0 # Elasticsearch 2.xelasticsearch-dsl&gt;=2.0.0,&lt;3.0.0 安装elasticsearch-dsl 在项目models下创建es_types.py文件，在文件中创建索引mapping 123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/6/2 12:45'from elasticsearch_dsl import DocType, Date, Nested, Boolean, analyzer,Completion, Keyword, Text, Integerfrom elasticsearch_dsl.connections import connectionsconnections.create_connection(hosts=[\"localhost\"]) class ArticleType(DocType): title = Text(analyzer=\"ik_max_word\") create_date = Date() url = Keyword() url_object_id = Keyword() cover_image_url = Keyword() cover_image_path = Keyword() praise_nums = Integer() comment_nums = Integer() fav_nums = Integer() tags = Text(analyzer=\"ik_max_word\") content = Text(analyzer=\"ik_max_word\") class Meta: index = \"jobbole\" doc_type = \"article\" if __name__ == '__main__': ArticleType.init() 运行es_types.py文件 回到elasticsearch-head可视化页面，成功生成jobbole索引 在pipelines文件中定义管道类ElasticsearchPipeline将数据写入到es中 12345678910111213141516171819class ElasticsearchPipeline(object): # 将数据写入到es中 def process_item(self, item, spider): article = ArticleType() article.title = item['title'] article.create_date = item['create_date'] article.url = item['url'] article.meta.id = item['url_object_id'] article.cover_image_url = item['cover_image_url'] if \"cover_image_path\" in item: article.cover_image_path = item['cover_image_path'] article.praise_nums = item['praise_nums'] article.comment_nums = item['comment_nums'] article.fav_nums = item['fav_nums'] article.tags = item['tags'] article.content = remove_tags(item['content']) article.save() return item Debug断点测试没有任何报错 在elasticsearch-head页面中查看jobbole索引的doc数据，成功将爬取的数据写入到es中 在Kibana页面中对jobbole索引doc内容的tags标签进行匹配搜索，是否能够搜索出来此篇文章内容 退出Debug，运行项目一段时间，爬取大量数据并写入到es中 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/90720889","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://hellotaogang.github.io/tags/ElasticSearch/"},{"name":"Python Scrapy分布式爬虫","slug":"Python-Scrapy分布式爬虫","permalink":"https://hellotaogang.github.io/tags/Python-Scrapy分布式爬虫/"},{"name":"数据抓取","slug":"数据抓取","permalink":"https://hellotaogang.github.io/tags/数据抓取/"},{"name":"Django 网站搭建","slug":"Django-网站搭建","permalink":"https://hellotaogang.github.io/tags/Django-网站搭建/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目于之在线教育平台网站的实战开发（完结）","slug":"Django项目于之在线教育平台网站的实战开发（完结）","date":"2019-11-15T10:44:41.918Z","updated":"2019-11-16T01:58:46.343Z","comments":true,"path":"2019/11/15/Django项目于之在线教育平台网站的实战开发（完结）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/15/Django项目于之在线教育平台网站的实战开发（完结）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶常见web攻击及防范 二丶Xadmin多种配置 三丶Xadmin插件开发（富文本编辑器） 四丶Xadmin插件开发（导出excel） 五丶项目部署上线 六丶项目总结","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶常见web攻击及防范 二丶Xadmin多种配置 三丶Xadmin插件开发（富文本编辑器） 四丶Xadmin插件开发（导出excel） 五丶项目部署上线 六丶项目总结 一丶常见web攻击及防范1.sql注入攻击与防范 ① sql注入的危害 非法读取丶篡改丶删除数据库中的数据 盗取用户的各类敏感信息，获取利益 通过修改数据库来修改网页上的内容 注入木马等 ② sql注入登录演示 定义原始方法登录视图 123456789101112131415# sql注入登录演示class UnsafeLoginView(View): \"\"\"不安全登录,使用最原始的方法进行登录\"\"\" def get(self, request): return render(request, \"login.html\") def post(self, request): user_name = request.POST.get(\"username\", \"\") pass_word = request.POST.get(\"password\", \"\") import MySQLdb conn = MySQLdb.connect(host=\"127.0.0.1\", user=\"root\", passwd=\"mysql\", db=\"mxonline\", charset=\"utf8\") cursor = conn.cursor() sql = \"select * from users_userprofile where username = '&#123;0&#125;' and password = '&#123;1&#125;' \".format(user_name, pass_word) res = cursor.execute(sql) # 获取用户所有数据 all_users = cursor.fetchall() 在根级urls中修改登录视图为上一步定义的视图 1url(r'^login/$', UnsafeLoginView.as_view(), name=\"login\"), # 登录页 Debug测试输入不存在的用户名和密码，res变量的值为0，表示未查询到结果 在登录页面，输入特殊的用户名，密码随便输入，如下图所示 Debug测试的结果是，居然查询到了数据，原因是1=1此条件为真所以肯定能查询到数据 使用以上的sql语句在数据库进行查询，同样也能查询到数据 2.xss攻击原理及防范 ① xss跨站脚本攻击(Cross Site Scripting)的危害 盗取各类用户账号，如用户网银账号丶各类管理员账号 盗窃企业重要的具有商业价值的资料 非法转账 控制受害者机器向其他网站发起攻击丶注入木马等 ② xss攻击原理 服务器对用户发送的请求地址中的name属性的值，直接做回显，并没有做任何加密处理，当黑客将请求地址中的name属性的值修改成一段js脚本，比如下图所示的获取cookie并进行alert打印，那么就会获取到用户的保存在本地的cookie ③ xss攻击流程图 以下的js脚本只是其中的一种而已，而黑客是怎么将url发送给受害者的比如邮件，QQ等等 ④ xss攻击防范 首先代码里对用户输入的地方和变量都需要仔细检查长度和对(“ &lt;” &gt;” ; ‘)等字符做过滤 避免直接在cookie中泄露用户隐私，例如email丶密码等等 通过使cookie和系统ip进行绑定来降低cookie泄露后的危险 尽量采用POST进行表单提交而不使用GET（也就是请求地址中不出现参数） 3.csrf攻击与防范 ① csrf跨站请求伪造(Cross-site request forgery)的危害 以你的名义进行邮件发送 盗取你的账号 购买商品 虚拟货币转账 ② csrf攻击原理 ③ csrf防范 表单提交时加上打印出csrf_token的值即可对跨站攻击进行有效的防范{% csrf_token %} 二丶Xadmin多种配置1.导航栏icon的修改 首先登陆Font Awesome官网，下载最新版本图标字体库以及CSS框架 在xadmin源码中查看当前使用的font-awesome的版本为4.0.3 将下载好的font-awesome-4.7.0进行解压后，替换编辑器源码中的font-awesome目录文件 在xadmin后端页面中左侧导航栏，修改用户心下的邮箱验证码图标 在xadmin源码中auth.py模块中找到UserAdmin模型类中的图标属性变量为model_icon 即在users/adminx中找到邮箱验证码的EmailVerifyRecordAdmin类，在类中添加model_icon属性，具体需要改成什么样的图标，需要在官网上找到要修改图片样式，如下图所示 然后紧接着在EmailVerifyRecordAdmin邮箱验证码注册类中执行model_icon属性为上图的样式 Ctrl+F5强制刷新xadmin后台，用户信息邮箱验证码的图标就修改成功了 2.xadmin后台表数据设定默认字段排序 比如当用户点击查看课程列表时，整个列表数据是乱序的，比如点击数 想让课程列表中的数据按照点击数的倒序进行排序，就需要在对应的注册类中添加如下ordering属性即可 12345class CourseAdmin(object): list_display = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'click_nums'] search_fields = ['name', 'desc', 'detail', 'degree', 'students'] list_filter = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students'] ordering = ['-click_nums'] 刷新页面，成功按照课程点击数倒序排列显示数据 3.xadmin后台管理中字段设置为只读 在课程数据中如点击数丶收藏认识丶学习人数应该是只读而不能进行修改编辑的 在注册类中添加readonly_fields属性指向要只读的字段 1readonly_fields = ['students', 'click_nums', 'fav_nums'] 刷新页面则，指定只读的字段则显示在页面底部 4.在xadmin后台中不显示某些字段 在注册类中添加exclude属性的值即可，需要注意的是exclude属性与readonly_fields属性时冲突的，所以需要去除readonly_fields属性中的click_nums字段 12readonly_fields = ['students', 'fav_nums']exclude = ['click_nums'] 刷新页面则，不显示点击数字段 5.增加课程时修改外键选择的样式 增加一门课程，需要通过下拉框来选择对应课程的机构，当数据庞大时，使用下拉框就没有搜索框来的方便 在organization/adminx中找到外键所指向的注册类，在该类中设置样式 1relfield_style = &apos;fk-ajax&apos; 刷新页面，在选择课程机构时则成功显示出搜索框 6.inline的使用 在xadmin后台管理中为课程添加章节信息时，不能在增加课程页面直接添加，而是需要退出课程到章节字段中去选择课程后才能添加课程的章节信息，在xadmin中也能像django admin那样去做到在一个页面直接添加外键的信息，在课程管理的adminx中需要定义一个类LessonInline，通过课程注册类中添加inlines的属性指向LessonInline对象即可达到效果 12345678910111213class LessonInline(object): model = Lesson extra = 0 class CourseAdmin(object): list_display = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'click_nums'] search_fields = ['name', 'desc', 'detail', 'degree', 'students'] list_filter = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students'] ordering = ['-click_nums'] readonly_fields = ['students', 'fav_nums'] exclude = ['click_nums'] inlines = [LessonInline] 刷洗页面，增加课程页面底部就会出现章节，点击+则可以添加该课程对应的章节信息，很是方便 需要注意的是，inline只能完成一成嵌套，不能完成多层，比如课程—章节—视频这就没法，但一个课程对应多个外键，就可以在inlines 属性中添加多个类，因为是列表类型的变量，在课程增加页面，除了添加章节还可以添加课程资源 123456789101112131415161718class LessonInline(object): model = Lesson extra = 0 class CourseResourceInline(object): model = CourseResource extra = 0 class CourseAdmin(object): list_display = [&apos;name&apos;, &apos;desc&apos;, &apos;detail&apos;, &apos;degree&apos;, &apos;learn_times&apos;, &apos;students&apos;, &apos;click_nums&apos;] search_fields = [&apos;name&apos;, &apos;desc&apos;, &apos;detail&apos;, &apos;degree&apos;, &apos;students&apos;] list_filter = [&apos;name&apos;, &apos;desc&apos;, &apos;detail&apos;, &apos;degree&apos;, &apos;learn_times&apos;, &apos;students&apos;] ordering = [&apos;-click_nums&apos;] readonly_fields = [&apos;students&apos;, &apos;fav_nums&apos;] exclude = [&apos;click_nums&apos;] inlines = [LessonInline, CourseResourceInline] 刷新页面，在增加课程页面就可以同时添加章节信息以及课程资源数据了 7.自定义列表返回数据，同一个model注册两个管理器 在之前主页动态数据展示时，因公开课程栏中嵌套了轮播图，就需要在课程所在的模型类Course添加is_banner是否轮播字段 如果想在课程管理中产生另一个表数据，这个表数据只显示轮播的课程数据那么就需要在courses/models中创建一个轮播课程模型类，这个类必须继承Course，只需要在类中编写Meta类并定义名称即可 12345class BannerCourse(Course): class Meta: verbose_name = \"轮播课程\" verbose_name_plural = verbose_name proxy = True 将上面定义的模型类，在courses/adminx中进行导入注册 12345678910class BannerCourseAdmin(object): list_display = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'click_nums'] search_fields = ['name', 'desc', 'detail', 'degree', 'students'] list_filter = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students'] ordering = ['-click_nums'] readonly_fields = ['students', 'fav_nums'] exclude = ['click_nums'] inlines = [LessonInline, CourseResourceInline] xadmin.site.register(BannerCourse, BannerCourseAdmin) 强制刷新页面后，在课程管理导航栏下成功创建一个轮播课程表数据，这个数据说白了跟课程的数据一模一样只是名称变了 如何让轮播课程表中数据只显示轮播的课程，在轮播课程对应的注册类中定义一个方法，该方法用于对父类Course模型类中的is_banner字段进行过滤，将过滤后的数据进行返回即可，为什么可以对is_banner字段进行过滤，因为BannerCourseAdmin与BannerCourse进行注册关联，并且BannerCourse这个模型类又继承Course模型类，即可以对is_banner字段进行过滤处理了 12345678910111213class BannerCourseAdmin(object): list_display = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'click_nums'] search_fields = ['name', 'desc', 'detail', 'degree', 'students'] list_filter = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students'] ordering = ['-click_nums'] readonly_fields = ['students', 'fav_nums'] exclude = ['click_nums'] inlines = [LessonInline, CourseResourceInline] def queryset(self): qs = super(BannerCourseAdmin, self).queryset() qs = qs.filter(is_banner=True) return qs 刷新页面查看轮播课程数据，则成功只显示轮播的课程数据 既然在轮播课程中只显示轮播课程数据，那么在课程中也应当只显示出不轮播的课程数据，跟上面同理在CourseAdmin注册类中定义queryset方法，只需要修改父类名以及将filter方法中的条件改成False即可 12345678910111213class CourseAdmin(object): list_display = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'click_nums'] search_fields = ['name', 'desc', 'detail', 'degree', 'students'] list_filter = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students'] ordering = ['-click_nums'] readonly_fields = ['students', 'fav_nums'] exclude = ['click_nums'] inlines = [LessonInline, CourseResourceInline] def queryset(self): qs = super(CourseAdmin, self).queryset() qs = qs.filter(is_banner=False) return qs 查看课程下的数据，只有13条，总共课程16条数据，轮播课程3条，所以数据筛选正确 8.list_editable属性 在课程注册类CourseAdmin中添加list_editable属性，这个属性可以在列表中对设定的字段直接进行编辑，而不需要点击进入课程详情中进行编辑 1list_editable = ['name', 'degree'] 刷新课程列表页面，则指定可编辑的name字段以及degree字段则出现编辑按钮，点击按钮可直接进行编辑保存了 9.在课程列表中显示对应课程的章节数 之前在页面模板中为了显示课程的章节数，在Course模型类中定义了get_zj_nums方法，用于获取课程的章节数，short_description方法是用于在xadmin后台显示的字段名称 1234def get_zj_nums(self): #获取课程章节数 return self.lesson_set.all().count()get_zj_nums.short_description = \"章节数\" 在课程注册类CourseAdmin中list_display属性中添加该方法名，对应django来说判断该字段为方法名时，则会去调用此方法 1list_display = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'click_nums', \"get_zj_nums\"] 刷新课程列表页，则成功显示出课程对应的章节数 10.在课程列表字段添加跳转按钮，指定跳转的链接地址 在Course模型类中定义go_to方法，具体如下，说明一下make_safe方法是让链接地址安全不进行转义操作 1234def go_to(self): from django.utils.safestring import mark_safe return mark_safe(\"&lt;a href='http://www.baidu.com'&gt;跳转&lt;/a&gt;\")go_to.short_description = \"跳转\" 在注册类CourseAdmin中将以上方法名添加到list_display属性中 1list_display = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'click_nums', \"get_zj_nums\", \"go_to\"] 测试显示跳转字段并进行目标地址的跳转 11.页面定时刷新插件 xadmin提供了此功能，在RefreshPlugin类中refresh_times为空列表，表示未进行设置刷新时间 在CourseAdmin中添加refresh_times属性，并设定其值为3秒或5秒刷新条件 1refresh_times = [3, 5] 测试自动刷新，选择3秒进行刷新测试，请注意链接地址的自动刷新 12.在保存课程的时候统计课程机构的课程数 在CourseAdmin注册类中重写父类的save_models方法，当对课程进行修改或者增加时都会对数据进行保存，那么就会去调用重写的save_models方法，就可以在这个方法中查询获取对应的课程机构的课程数 12345678def save_models(self): # 在保存课程的时候统计课程机构的课程数 obj = self.new_obj obj.save() if obj.course_org is not None: course_org = obj.course_org course_org.course_nums = Course.objects.filter(course_org=course_org).count() course_org.save() 在课程机构中查看第一条数据同济大学的课程数，这里显示为0 Debug 断点测试，在课程中对Mysql主从复制课程所属的课程机构修改成同济大学，后点击保存 Debug断点测试完成后，查看课程机构中同济大学的课程数 三丶Xadmin插件开发（富文本编辑器）说明： django ueditor富文本编辑器的集成 1.Xadmin插件制作官方中文文档 https://xadmin.readthedocs.io/en/docs-chinese/make_plugin.html 2.DjangoUeditor源码文档 https://github.com/zhangfisher/DjangoUeditor 3.DjangoUeditor使用 安装DjangoUeditor 在INSTALL_APPS里面增加DjangoUeditor 1234567INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, ......., ......., &quot;pure_pagination&quot;, &quot;DjangoUeditor&quot;] 配置urls 1url(r'^ueditor/',include('DjangoUeditor.urls' )), 在需要使用富文本编辑器的模型类中导入UEditorField类，项目中Course模型类中的课程详情字段是需要使用富文本的，所以对detail字段进行如下修改 说明：UEditorField继承自models.TextField,因此你可以直接将model里面定义的models.TextField直接改成UEditorField即可 12detail = UEditorField(verbose_name=u\"课程详情\",width=600, height=300, imagePath=\"courses/ueditor/\", filePath=\"courses/ueditor/\", default='') 在xadmin/plugins目录下创建ueditor.py文件，在文件中进行如下编写 1234567891011121314151617181920212223242526272829303132333435363738import xadminfrom xadmin.views import BaseAdminPlugin, CreateAdminView, ModelFormAdminView, UpdateAdminViewfrom DjangoUeditor.models import UEditorFieldfrom DjangoUeditor.widgets import UEditorWidgetfrom django.conf import settings class XadminUEditorWidget(UEditorWidget): def __init__(self,**kwargs): self.ueditor_options=kwargs self.Media.js = None super(XadminUEditorWidget,self).__init__(kwargs) class UeditorPlugin(BaseAdminPlugin): def get_field_style(self, attrs, db_field, style, **kwargs): if style == 'ueditor': if isinstance(db_field, UEditorField): widget = db_field.formfield().widget param = &#123;&#125; param.update(widget.ueditor_settings) param.update(widget.attrs) return &#123;'widget': XadminUEditorWidget(**param)&#125; return attrs def block_extrahead(self, context, nodes): js = '&lt;script type=\"text/javascript\" src=\"%s\"&gt;&lt;/script&gt;' % (settings.STATIC_URL + \"ueditor/ueditor.config.js\") #自己的静态目录 js += '&lt;script type=\"text/javascript\" src=\"%s\"&gt;&lt;/script&gt;' % (settings.STATIC_URL + \"ueditor/ueditor.all.min.js\") #自己的静态目录 nodes.append(js) xadmin.site.register_plugin(UeditorPlugin, UpdateAdminView)xadmin.site.register_plugin(UeditorPlugin, CreateAdminView)在xadmin/plugins目录下的__init__.py文件中，将ueditor插件注册进去PLUGINS = ( 'actions', '.......', 'ueditor',) 4.错误修正 说明：DjangoUeditor是基于Python 2.7的进行开发的，博主这里的开发环境为python3，所以需要对DjangoUeditor安装包下的models.py丶settings.py丶widgets.py丶commands.py丶urls.py丶views.py进行修改 models.py 12# from widgets import UEditorWidget,AdminUEditorWidgetfrom .widgets import UEditorWidget, AdminUEditorWidget settings.py 1234567更新配置：从用户配置文件settings.py重新读入配置UEDITOR_SETTINGS,覆盖默认def UpdateUserSettings(): UserSettings=getattr(gSettings,\"UEDITOR_SETTINGS\",&#123;&#125;).copy() # if UserSettings.has_key(\"config\"):UEditorSettings.update(UserSettings[\"config\"]) # if UserSettings.has_key(\"upload\"):UEditorUploadSettings.update(UserSettings[\"upload\"]) if UserSettings.get(\"config\"):UEditorSettings.update(UserSettings[\"config\"]) if UserSettings.get(\"upload\"):UEditorUploadSettings.update(UserSettings[\"upload\"]) widgets.py 1234# import settings as USettings# from commands import *from . import settings as USettingsfrom .commands import * commands.py 12# import settings as USettingsfrom . import settings as USettings urls.py 12345678910111213141516171819#coding:utf-8# from django import VERSION# if VERSION[0:2]&gt;(1,3):# from django.conf.urls import patterns, url# else:# from django.conf.urls.defaults import patterns, url## from views import get_ueditor_controller## urlpatterns = patterns('',# url(r'^controller/$',get_ueditor_controller)# )from .widgets import UEditorWidget, AdminUEditorWidgetfrom .views import get_ueditor_controllerfrom django.conf.urls import url urlpatterns = [ url(r'^controller/$', get_ueditor_controller),] views.py 12345678910111213141516171819# import settings as USettingsfrom . import settings as USettings #保存上传的文件def save_upload_file(PostFile,FilePath): try: f = open(FilePath, 'wb') for chunk in PostFile.chunks(): f.write(chunk) # except Exception,E: # f.close() # return u\"写入文件错误:\"+ E.message # f.close() # return u\"SUCCESS\" except Exception as E: f.close() return u\"写入文件错误:\"+ E.message f.close() return u\"SUCCESS\" 重启项目进入xadmin后台进行增加课程操作时，结果报错了 回到编辑器，查看错误位置 查看安装包DjangoUeditor中发现并没有ueditor.html，甚至连templates目录都没有 解决方法有三种：第一种就是在github上将别人修正好的适合python3的DjangoUeditor源码拷贝进行源码安装；第二种就是自己下载DjangoUeditor免安装源码放在项目extra_apps目录下；第三种就是下载DjangoUeditor源码安装，在对其下的模块进行修正 博主选择第三种，将下载好的DjangoUeditor-master.zip进行解压，将解压后的文件放在项目根目录下，具体操作如下 完成上一步后，刷新页面则成功在课程详情字段加载出富文本编辑器 添加新的课程使用富文本编辑器 查看课程列表，在刚新增的课程详情页中显示全是HTML代码 在进入课程详情后，详情页面显示出转义的内容 需要在course-detail模板中找到课程详情数据块，对数据块内容进行转义关闭 12345&lt;div class=\"tab_cont tab_cont1\"&gt; &#123;% autoescape off %&#125; &lt;p&gt;&#123;&#123; course.detail &#125;&#125;&lt;/p&gt; &#123;% endautoescape %&#125;&lt;/div&gt; 刷新页面，成功显示出在富文本编写的内容 5.总结步骤： 123456789安装1.pip install DjangoUeditor2.settings.py 中加入DjangoUeditor3.url(r&apos;ueditor/&apos;, include(&apos;DjangoUeditor.urls&apos;))4.detail = UeditorField()xadmin1.plugins中添加ueditor.py文件，在__init__中加入ueditor2.adminx中添加style_fields = &#123;&apos;detail&apos;:&apos;ueditor&apos;&#125; 四丶Xadmin插件开发（导出excel）说明：excel的导入插件开发 1.在xadmin/plugins中创建excel.py文件，拷贝如下内容 123456789101112131415161718import xadminfrom xadmin.views import BaseAdminPlugin, ListAdminViewfrom django.template import loaderfrom xadmin.plugins.utils import get_context_dict #excel 导入class ListImportExcelPlugin(BaseAdminPlugin): import_excel = False def init_request(self, *args, **kwargs): return bool(self.import_excel) def block_top_toolbar(self, context, nodes): nodes.append(loader.render_to_string(&apos;xadmin/excel/model_list.top_toolbar.import.html&apos;, context=get_context_dict(context))) xadmin.site.register_plugin(ListImportExcelPlugin, ListAdminView) 2.在xadmin/templates/xadmin目录下创建excel目录，在目录下创建model_list.top_toolbar.import.html文件，文件内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123;% load i18n %&#125;&lt;div class=&quot;btn-group export&quot;&gt; &lt;a class=&quot;dropdown-toggle btn btn-default btn-sm&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot;&gt; &lt;i class=&quot;icon-share&quot;&gt;&lt;/i&gt; 导入 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dLabel&quot;&gt; &lt;li&gt;&lt;a data-toggle=&quot;modal&quot; data-target=&quot;#export-modal-import-excel&quot;&gt;&lt;i class=&quot;icon-circle-arrow-down&quot;&gt;&lt;/i&gt; 导入 Excel&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; function fileChange(target)&#123;//检测上传文件的类型 var imgName = document.all.submit_upload.value; var ext,idx; if (imgName == &apos;&apos;)&#123; document.all.submit_upload_b.disabled=true; alert(&quot;请选择需要上传的 xls 文件!&quot;); return; &#125; else &#123; idx = imgName.lastIndexOf(&quot;.&quot;); if (idx != -1)&#123; ext = imgName.substr(idx+1).toUpperCase(); ext = ext.toLowerCase( );&#123;# alert(&quot;ext=&quot;+ext);#&#125; if (ext != &apos;xls&apos; &amp;&amp; ext != &apos;xlsx&apos;)&#123; document.all.submit_upload_b.disabled=true; alert(&quot;只能上传 .xls 类型的文件!&quot;); return; &#125; &#125; else &#123; document.all.submit_upload_b.disabled=true; alert(&quot;只能上传 .xls 类型的文件!&quot;); return; &#125; &#125; &#125; &lt;/script&gt; &lt;div id=&quot;export-modal-import-excel&quot; class=&quot;modal fade&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt; &#123;% csrf_token %&#125; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot;&gt;导入 Excel&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;input type=&quot;file&quot; οnchange=&quot;fileChange(this)&quot; name=&quot;excel&quot; id=&quot;submit_upload&quot;&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;&#123;% trans &quot;Close&quot; %&#125;&lt;/button&gt; &lt;button class=&quot;btn btn-success&quot; type=&quot;submit&quot; id=&quot;submit_upload_b&quot;&gt;&lt;i class=&quot;icon-share&quot;&gt;&lt;/i&gt; 导入&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal-dalog --&gt; &lt;/div&gt;&lt;!-- /.modal --&gt; &lt;/div&gt; 3.在courses/adminx下的CourseAdmin类中添加import_excel = True属性，并定义一个post方法，在这个方法中可以任意添加任何逻辑代码，这里就不进行逻辑代码的演示了，直接pass，但必须返回如下调用，不然会出错 1234def post(self, request, *args, **kwargs): if 'excel' in request.FILES: pass return super(CourseAdmin, self).post(request, args, kwargs) 4.在plugins/init.py中注册此插件 12345678PLUGINS = ( 'actions', 'filters', 'bookmark', 'export', 'ueditor', 'excel',) 测试刷新课程列表页，在右上角菜单栏中显示出导入按钮，因为没有写对上传excel文件操作，所以这里只能显示出此功能 五丶项目部署上线1.指定python3版本创建django_py3虚拟环境，并进入此环境 2.安装项目所需的包 3.查看当前虚拟环境下的包 4.运行项目 在终端执行python3 manage.py runserver 结果报错了，这个错无非就是安装的DjangoUeditor包中源码为python2编写的 将windows虚拟环境D:\\django_py3\\Lib\\site-packages下的DjangoUeditor包替换掉ubuntu虚拟环境django_py3/lib/python3.5/site-packages下的DjangoUeditor 再次使用命令启动项目，结果又报错了，原因是没有mxonline的数据库 5.将windows上的mxonline数据库数据传输到ubuntu中 在ubuntu中创建mxonline数据库 查看ubuntu上的IP地址 博主这里在使用Navicat软件时，不小心将mxonline数据库数据表数据清空了，所以导致博主需要花大量时间在xadmin后台进行数据的添加，所以博主先将数据库mxonline进行备份，免得再出现该情况 使用Navicat软件测试在windows上测试连接ubuntu中的mysql 在Windows上打开Navicat软件，通过该软件数据传输功能将mxonline数据库数据传输到ubuntu中的mxonline数据中 点击开始后，出现success表示成功 回到ubuntu中，重新启动项目，则启动成功 打开浏览器访问成功访问主页并显示动态数据 6.安装nginx 说明：安装过程不用演示，很简单 因博主在之前Django电商项目中已经安装过了所以这里不用安装，并且ngin.conf配置文件中的配置为Django电商项目的配置；在Django电商项目部署配置nginx时，将默认的配置文件进行了备份（nginx.conf.fefault），所以只需要指定该配置文件来启动nginx即可 在浏览器中直接输入ubuntu IP地址即默认访问80端口，则显示nginx服务启动成功页面 7.安装uwsgi 进入虚拟环境中安装uwsgi 使用uwsgi启动项目 在浏览器中输入http://192.168.4.63:8000/ 则成功加载出页面动态数据；但静态资源无法加载出来 8.nginx配置 拷贝nginx默认的配置文件到当前目录下并命名为mx_nginx.conf 编写mx_nginx.conf文件内容，具体如下 1234567891011121314151617181920server &#123; listen 80; server_name 192.168.4.63 www.mxonline.com; #charset koi8-r; #access_log logs/host.access.log main; location /static &#123; alias /home/taogang/Desktop/MxOnline/static; &#125; location /media &#123; alias /home/taogang/Desktop/MxOnline/media; &#125; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8000; &#125;&#125; 指定以上配置文件启动nginx服务器 9.将项目所用到的所有静态资源文件收集到static目录下 需要在settings配置文件中配置收集静态文件路径，之前Django电商项目也是这样的 进入项目虚拟环境，执行命令进行收集 10.创建并配置uwsgi.ini文件 在项目根目录下创建一个uwsgi.ini配置文件，编写以下内容 在配置文件settings中，设置为线上环境 123DEBUG = False ALLOWED_HOSTS = [&apos;*&apos;] 11.测试使用uwsgi启动项目 启动uwsgi 在浏览器直接访问http://192.168.4.63/ 成功加载动态数据以及静态资源文件 12.在windows中使用域名访问网站 切换到windows中，在浏览器输入http://192.168.4.63/ 成功访问ubuntu中uwsgi启动的网站，之所以能够访问是因为通过vmware虚拟机搭建的ubuntu桥接模式为同一网段ip，即可以互相ping通 接下来想要在浏览器地址栏中输入www.mxonline.com域名来访问网站主页，则需要在windows电脑hosts文件中添加如下内容，则表示输入此域名相当于访问192.168.4.63IP地址，因为没有购买域名，所以只能这样做，仅限于本地可以使用该域名访问 测试在浏览器中输入http://www.mxonline.com/ 是否成功访问主页 六丶项目总结1.数据库设计 users app model用户信息相关数据表设计 organization app model课程机构数据表设计 courses app model课程相关数据表设计 operation app model用户操作相关数据表设计 2.后台管理系统开发 xadmin安装以及model注册 xadmin全局配置 3.登录和注册以及找回密码 登录(session和cookie机制) 注册(form表单提交和图片验证码以及发送邮件) 找回密码(邮件发送) 4.课程机构 机构列表(分页和筛选以及排序) 机构详情(收藏和富文本编辑) 咨询提交(modelform验证和保存) 5.课程功能 课程列表(分页和排序) 课程详情(收藏丶章节展示丶资源展示丶评论) 6.讲师功能 讲师列表(分页和排序) 讲师详情(收藏) 7.个人中心 用户信息修改(修改密码丶头像丶邮箱丶基本信息) 我的课程 我的收藏(取消收藏) 我的消息 8.全局功能 搜索功能(公开课丶课程机构丶授课老师) 全局404和500页面配置 首页开发 点击数和收藏数修改以及退出功能 9.web攻击及防范 sql注入攻击 xss攻击 csrf攻击 10.xadmin进阶开发 userprofile注册和设置 xadmin常见功能设置 inlinemode注册和proxy代理注册 django ueditor富文本编辑器集成 excel导入插件集成 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/90243762","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目于之在线教育平台网站的实战开发（五）","slug":"Django项目于之在线教育平台网站的实战开发（五）","date":"2019-11-15T09:40:34.320Z","updated":"2019-11-15T10:42:11.616Z","comments":true,"path":"2019/11/15/Django项目于之在线教育平台网站的实战开发（五）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/15/Django项目于之在线教育平台网站的实战开发（五）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶全局搜索功能 二丶用户个人中心（个人资料） 三丶用户个人中心（我的课程） 四丶用户个人中心（我的收藏） 五丶用户个人中心（我的消息） 六丶用户个人中心（退出） 七丶 首页、全局功能细节和404以及500页面配置","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶全局搜索功能 二丶用户个人中心（个人资料） 三丶用户个人中心（我的课程） 四丶用户个人中心（我的收藏） 五丶用户个人中心（我的消息） 六丶用户个人中心（退出） 七丶 首页、全局功能细节和404以及500页面配置 一丶全局搜索功能分析：当用户在首页搜索框进行搜索时，可以选择搜索课程和机构以及讲师，默认搜索类为公开课，点击搜索调转到各个列表页面；搜索按钮点击使用js代码进行链接地址调转，当用户没有输入任何搜索内容时，则跳转到用户选择的类别下的列表页，即链接地址为http://127.0.0.1:8000/course/list/?keywords= ；其中keywords=空；反之http://127.0.0.1:8000/course/list/?keywords=python 1.公开课搜索 说明：三个类别使用同一js代码 在static/js目录下的deco-common.js文件中，编写如下js代码，以下js代码逻辑很简单，就不细说了 123456789101112131415161718192021//顶部搜索栏搜索方法function search_click()&#123; var type = $('#jsSelectOption').attr('data-value'), keywords = $('#search_keywords').val(), request_url = ''; if(keywords == \"\")&#123; request_url = \"/\"+type+\"/list?keywords=\" &#125; if(type == \"course\")&#123; request_url = \"/course/list?keywords=\"+keywords &#125;else if(type == \"teacher\")&#123; request_url = \"/org/teacher/list?keywords=\"+keywords &#125;else if(type == \"org\")&#123; request_url = \"/org/list?keywords=\"+keywords &#125; window.location.href = request_url&#125; $('#jsSearchBtn').on('click',function()&#123; search_click() &#125;); 在courses/views下的课程列表视图中，获取请求地址keywords参数的值，根据搜索的关键字到对获取到的所有课程再进行此条件的筛选，需要注意的是不仅仅对Course模型表的name字段，还需要对课程简介desc以及课程详情detail字段进行关键字匹配搜索，字段__icontains为django提供的匹配方式，contains前面加i表示不区分大小写 1234# 全局搜索功能search_keywords = request.GET.get(\"keywords\", \"\")if search_keywords: all_courses = all_courses.filter(Q(name__icontains=search_keywords)|Q(desc__icontains=search_keywords)|Q(detail__icontains=search_keywords)) Debug测试公开课类搜索python关键字 测试公开课搜索功能 2.课程机构搜索 同理在organization/views下的机构列表视图中，通过获取keywords关键字到CourseOrg机构模型表中去匹配name字段以及desc字段的数据 12345# 全局机构搜索功能search_keywords = request.GET.get(\"keywords\", \"\")if search_keywords: all_orgs = all_orgs.filter( Q(name__icontains=search_keywords) | Q(desc__icontains=search_keywords)) 测试机构搜索功能 3.课程讲师搜索 在organization/views下的讲师列表视图中，通过获取keywords关键字到Teacher讲师模型表中去匹配name字段和work_company字段以及work_position的数据 12345# 全局讲师搜索功能search_keywords = request.GET.get(\"keywords\", \"\")if search_keywords: all_teachers = all_teachers.filter( Q(name__icontains=search_keywords) | Q(work_company__icontains=search_keywords)| Q(work_position__icontains=search_keywords)) 测试课程讲师搜索功能 二丶用户个人中心（个人资料）分析：在用户个人中心一共有4个大页面，跟机构页面类似，用户个人中心页面包括个人资料（usercenter-info）丶我的课程（usercenter-mycourse）丶我的收藏包括三个页面（usercenter-fav-course丶usercenter-fav-teacher丶usercenter-fav-org）丶我的消息（usercenter-message），整个用户中心页面为6个页面 1.提取父模板文件usercenter_base.html 因个人中心所有页面的样式除了各种内容不一样，其他都一样，所以利用模板继承来解决模板内容重复性 将usercenter-info模板内容复制到userc_base父模板中，在父模板中进行不同模块的提取操作，也就是挖坑 2.显示用户信息页面 模板继承 在根级urls中将users应用下的urls包含进来 1url(r&apos;users/&apos;, include(&apos;users.urls&apos;, namespace=&quot;users&quot;)), # 用户应用users下的urls 在users/views中定义用户信息类视图，需要注意的就是此页面必须为登录后才能进行访问的页面，所以该视图需要继承于LoginRequiredMixin类，来验证用户是否登录 12345class UserInfoView(LoginRequiredMixin, View): \"\"\"用户信息页\"\"\" def get(self, request): current_page = \"info\" return render(request, \"usercenter-info.html\", &#123;\"current_page\":current_page&#125;) 在父模板中修改个人资料链接地址以及判断按钮激活状态 1&lt;li class=\"&#123;% if current_page == 'info' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'users:user_info' %&#125;\"&gt;个人资料&lt;/a&gt;&lt;/li&gt; 在浏览器中访问http://127.0.0.1:8000/users/info/ 成功进入用户信息页面 3.动态显示出用户信息页面数据 说明：因为当用户登录成功后，则request中就记录了登录成功后的用户信息user对象，所以通过该user对象即可以在模板中直接打印显示出动态数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;form class=\"clearfix\" id=\"jsAvatarForm\" enctype=\"multipart/form-data\" autocomplete=\"off\" method=\"post\" action=\"\" target='frameFile'&gt; &lt;label class=\"changearea\" for=\"avatarUp\"&gt; &lt;span id=\"avatardiv\" class=\"pic\"&gt; &lt;img width=\"100\" height=\"100\" class=\"js-img-show\" id=\"avatarShow\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; request.user.image &#125;&#125;\"/&gt; &lt;/span&gt; &lt;span class=\"fl upload-inp-box\" style=\"margin-left:70px;\"&gt; &lt;span class=\"button btn-green btn-w100\" id=\"jsAvatarBtn\"&gt;修改头像&lt;/span&gt; &lt;input type=\"file\" name=\"image\" id=\"avatarUp\" class=\"js-img-up\"/&gt; &lt;/span&gt; &lt;/label&gt;&lt;/form&gt;&lt;form class=\"perinform\" novalidate id=\"jsEditUserForm\" autocomplete=\"off\"&gt; &lt;ul class=\"right\"&gt; &lt;li&gt;昵&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;称： &lt;input type=\"text\" name=\"nick_name\" id=\"nick_name\" value=\"&#123;&#123; request.user.nick_name &#125;&#125;\" maxlength=\"10\"&gt; &lt;i class=\"error-tips\"&gt;&lt;/i&gt; &lt;/li&gt; &lt;li&gt;生&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;日： &lt;input type=\"text\" id=\"birth_day\" name=\"birday\" value=\"&#123;&#123; request.user.birday &#125;&#125;\" readonly=\"readonly\"/&gt; &lt;i class=\"error-tips\"&gt;&lt;/i&gt; &lt;/li&gt; &lt;li&gt;性&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;别： &lt;label&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;input type=\"radio\" name=\"gender\" value=\"male\" &#123;% if request.user.gender == 'male' %&#125;checked=\"checked\"&#123;% endif %&#125;&gt;男&lt;/label&gt; &lt;label&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;input type=\"radio\" name=\"gender\" value=\"female\" &#123;% if request.user.gender == 'female' %&#125;checked=\"checked\"&#123;% endif %&#125;&gt;女&lt;/label&gt; &lt;/li&gt; &lt;li class=\"p_infor_city\"&gt;地&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;址： &lt;input type=\"text\" name=\"address\" id=\"address\" placeholder=\"请输入你的地址\" value=\"&#123;&#123; request.user.address &#125;&#125;\" maxlength=\"10\"&gt; &lt;i class=\"error-tips\"&gt;&lt;/i&gt; &lt;/li&gt; &lt;li&gt;手&amp;nbsp;&amp;nbsp;机&amp;nbsp;&amp;nbsp;号： &lt;input type=\"text\" name=\"mobile\" id=\"mobile\" placeholder=\"请输入你的手机号码\" value=\"&#123;&#123; request.user.mobile &#125;&#125;\" maxlength=\"10\"&gt; &lt;/li&gt; &lt;li&gt;邮&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;箱： &lt;input class=\"borderno\" type=\"text\" name=\"email\" readonly=\"readonly\" value=\"&#123;&#123; request.user.email &#125;&#125;\"/&gt; &lt;span class=\"green changeemai_btn\"&gt;[修改]&lt;/span&gt; &lt;/li&gt; &lt;li class=\"button heibtn\"&gt; &lt;input type=\"button\" id=\"jsEditUserBtn\" value=\"保存\"&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/form&gt; 刷新页面成功显示出登录成功后的用户动态数据 4.修改用户头像 在模板文件中修改头像为form表单内容块，即所以需要在users/forms中定义上传图片的表单，使用forms.ModelForm进行完成 12345class UploadImageForm(forms.ModelForm): \"\"\"上传头像表单\"\"\" class Meta: model = UserProfile fields = [\"image\"] # 只保留想要的模型中的字段 需要注意的是，UploadImageForm表单类中指定的UserProfile模型类中的image字段名必须要与模板中form表单中修改头像所在的input标签的name属性的值必须相同 1234567891011&lt;span class=\"fl upload-inp-box\" style=\"margin-left:70px;\"&gt; &lt;span class=\"button btn-green btn-w100\" id=\"jsAvatarBtn\"&gt;修改头像&lt;/span&gt; &lt;input type=\"file\" name=\"image\" id=\"avatarUp\" class=\"js-img-up\"/&gt;&lt;/span&gt; 定义上传图片的类视图class UploadImageView(LoginRequiredMixin, View): \"\"\"修改用户头像\"\"\" def post(self, request): image_form = UploadImageForm(request.POST, request.FILES) if image_form.is_valid(): pass 定义视图的路由 1url(r'^image/upload/$', UploadImageView.as_view(), name=\"image_upload\"), # 上传用户头像 在static/js/deco-user.js中 ，定义js提交上传头像form表单代码 1234//个人资料头像$('.js-img-up').uploadPreview(&#123; Img: \".js-img-show\", Width: 94, Height: 94 ,Callback:function()&#123; $('#jsAvatarForm').submit();&#125;&#125;); Debug测试是否在image_form中生成了上传的图片数据，通过向UploadImageForm表单类中传递request.FILES对象也就是上传的图片对象，在变量image_form中就会生成cleaned_data字典对象中的image键值 即需要在视图中获取image_form对象cleaned_data字段中的image值，将该值保存到user对象的image属性中，则完成图片的修改以及保存 12345678910class UploadImageView(LoginRequiredMixin, View): \"\"\"修改用户头像\"\"\" def post(self, request): # 向表单类中传递用户修改的头像文件 image_form = UploadImageForm(request.POST, request.FILES) # 表单验证成功则将在生成的表单独享image_form中获取cleaned_data字典属性的image键的值保存到user对象的image属性中 # 即完成了用户上传保存头像的操作 if image_form.is_valid(): request.user.image = image_form.cleaned_data['image'] request.user.save() 测试修改用户头像功能 因为在上传头像图片表单类中继承的是forms.ModelForm类，所以在视图中可以定义instance属性指向当前的用户对象，即可完成上传图片操作，不需要从表单对象的cleaned_data属性中获取图片数据 12345678910class UploadImageView(LoginRequiredMixin, View): \"\"\"修改用户头像\"\"\" def post(self, request): # 向表单类中传递用户修改的头像文件 image_form = UploadImageForm(request.POST, request.FILES, instance=request.user) # 表单验证成功则将在生成的表单独享image_form中获取cleaned_data字典属性的image键的值保存到user对象的image属性中 # 即完成了用户上传保存头像的操作 if image_form.is_valid(): # request.user.image = image_form.cleaned_data['image'] request.user.save() Debug测试，成功进入save方法，并没有抛出异常，则以上方式也能完成修改头像操作 在视图中定义返回前端的响应数据 12345678910111213class UploadImageView(LoginRequiredMixin, View): \"\"\"修改用户头像\"\"\" def post(self, request): # 向表单类中传递用户修改的头像文件 image_form = UploadImageForm(request.POST, request.FILES, instance=request.user) # 表单验证成功则将在生成的表单独享image_form中获取cleaned_data字典属性的image键的值保存到user对象的image属性中 # 即完成了用户上传保存头像的操作 if image_form.is_valid(): # request.user.image = image_form.cleaned_data['image'] image_form.save(commit=True) return HttpResponse('&#123;\"status\":\"success\", \"msg\":\"修改成功\"&#125;', content_type='application/json') else: return HttpResponse('&#123;\"status\":\"fail\", \"msg\":\"修改失败\"&#125;', content_type='application/json') 修改成功则返回json格式的响应数据 5.修改用户密码 说明：之前在用户网站登录时，有个功能叫忘记密码，在忘记密码验证邮箱时成功时会在邮件中发送修改密码的链接地址，在进入密码修改页面进行密码修改，需要注意的是之前修改密码是在用户未登录的状态下进行的修改，而在用户中心进行密码修改则是用户登录成功后进行修改，所有不需要在进行逻辑编写时，不需要获取邮箱地址，其他获取参数与之前写的修改密码一致；因为用户是必须登录成功才能进入到个人中心页面，即不需要用户输入旧密码 将之前定义的ModifyPwdView类视图代码复制一份，进行如下修改 1234567891011121314151617class UpdatePwdView(LoginRequiredMixin, View): \"\"\"个人中心修改密码\"\"\" def post(self, request): modify_form = ModifyPwdForm(request.POST) if modify_form.is_valid(): pwd1 = request.POST.get(\"password1\", \"\") pwd2 = request.POST.get(\"password2\", \"\") # 当用户两次密码不一致则提示错误信息到页面，一致时则通过用户名也就是邮箱来获取用户信息user对象，设置对象中的密码为用户填写的密码 # 最后返回到登录页面 if pwd1 != pwd2: return HttpResponse('&#123;\"status\":\"fail\", \"msg\":\"两次密码不一致\"&#125;', content_type='application/json') user = request.user user.password = make_password(pwd2) user.save() return HttpResponse('&#123;\"status\":\"success\", \"msg\":\"密码修改成功\"&#125;', content_type='application/json') else: return HttpResponse(json.dumps(modify_form.errors), content_type='application/json') 定义视图的路由 1url(r'^update/pwd/$', UpdatePwdView.as_view(), name=\"update_pwd\"), # 个人中心修改密码 顺便提示一下吧，form表单的提交需要传递csrf_token，所以在usercenter_base模板中找到修改密码的form表单，添加csrf_token的值 123456789101112131415&lt;form id=\"jsResetPwdForm\" autocomplete=\"off\"&gt; &lt;div class=\"box\"&gt; &lt;span class=\"word2\"&gt;新&amp;nbsp;&amp;nbsp;密&amp;nbsp;&amp;nbsp;码&lt;/span&gt; &lt;input type=\"password\" id=\"pwd\" name=\"password1\" placeholder=\"5-20位非中文字符\"/&gt; &lt;/div&gt; &lt;div class=\"box\"&gt; &lt;span class=\"word2\"&gt;确定密码&lt;/span&gt; &lt;input type=\"password\" id=\"repwd\" name=\"password2\" placeholder=\"5-20位非中文字符\"/&gt; &lt;/div&gt; &lt;div class=\"error btns\" id=\"jsResetPwdTips\"&gt;&lt;/div&gt; &lt;div class=\"button\"&gt; &lt;input id=\"jsResetPwdBtn\" type=\"button\" value=\"提交\"/&gt; &lt;/div&gt; &#123;% csrf_token %&#125;&lt;/form&gt; 在deco-user.js中编写ajax post发送异步请求的js代码 12345678910111213141516171819202122232425262728293031//个人资料修改密码$('#jsUserResetPwd').on('click', function()&#123; Dml.fun.showDialog('#jsResetDialog', '#jsResetPwdTips');&#125;); $('#jsResetPwdBtn').click(function()&#123; $.ajax(&#123; cache: false, type: \"POST\", dataType:'json', url:\"/users/update/pwd/\", data:$('#jsResetPwdForm').serialize(), async: true, success: function(data) &#123; if(data.password1)&#123; Dml.fun.showValidateError($(\"#pwd\"), data.password1); &#125;else if(data.password2)&#123; Dml.fun.showValidateError($(\"#repwd\"), data.password2); &#125;else if(data.status == \"success\")&#123; Dml.fun.showTipsDialog(&#123; title:'提交成功', h2:'修改密码成功，请重新登录!', &#125;); Dml.fun.winReload(); &#125;else if(data.msg)&#123; Dml.fun.showValidateError($(\"#pwd\"), data.msg); Dml.fun.showValidateError($(\"#repwd\"), data.msg); &#125; &#125; &#125;);&#125;); 测试个人中心修改用户密码（输入长度不一致的以及两次密码不一致的密码） 测试个人中心修改用户密码（输入一致的密码） 6.完成网站页面顶部栏的用户信息显示 说明：只需要在所有的父模板判断用户是否登录以及打印登录后的用户信息，登录后的用户信息直接从request中去获取即可 在base.html和org_base.html以及usercenter_base.html三个模板中进行如下修改即可 12345678910111213141516171819202122232425262728&#123;% if request.user.is_authenticated %&#125; &lt;div class=\"personal\"&gt; &lt;dl class=\"user fr\"&gt; &lt;dd&gt;&#123;&#123; request.user.username &#125;&#125;&lt;img class=\"down fr\" src=\"&#123;% static 'images/top_down.png' %&#125;\"/&gt;&lt;/dd&gt; &lt;dt&gt;&lt;img width=\"20\" height=\"20\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; request.user.image &#125;&#125;\"/&gt;&lt;/dt&gt; &lt;/dl&gt; &lt;div class=\"userdetail\"&gt; &lt;dl&gt; &lt;dt&gt;&lt;img width=\"80\" height=\"80\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; request.user.image &#125;&#125;\"/&gt;&lt;/dt&gt; &lt;dd&gt; &lt;h2&gt;&#123;&#123; request.user.nick_name &#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123; request.user.username &#125;&#125;&lt;/p&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;div class=\"btn\"&gt; &lt;a class=\"personcenter fl\" href=\"&#123;% url 'users:user_info' %&#125;\"&gt;进入个人中心&lt;/a&gt; &lt;a class=\"fr\" href=\"/logout/\"&gt;退出&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;a href=\"usercenter-message.html\"&gt; &lt;div class=\"msg-num\"&gt;&lt;span id=\"MsgNum\"&gt;0&lt;/span&gt;&lt;/div&gt; &lt;/a&gt;&#123;% else %&#125; &lt;a style=\"color:white\" class=\"fr registerbtn\" href=\"&#123;% url 'register' %&#125;\"&gt;注册&lt;/a&gt; &lt;a style=\"color:white\" class=\"fr loginbtn\" href=\"&#123;% url 'login' %&#125;\"&gt;登录&lt;/a&gt;&#123;% endif %&#125; 刷新页面成功在顶部栏中显示登录成功的用户数据 7.个人中心修改邮箱 定义视图 12345678class SendEmailCodeView(LoginRequiredMixin, View): \"\"\"发送邮箱验证码\"\"\" def get(self, request): email = request.GET.get(\"email\", \"\") if UserProfile.objects.filter(email=email): return HttpResponse('&#123;\"email\":\"邮箱已存在\"&#125;', content_type='application/json') send_register_email(email, \"update_email\") return HttpResponse('&#123;\"status\":\"success\"&#125;', content_type='application/json') 定义视图路由 1url(r'^sendemail_code/$', SendEmailCodeView.as_view(), name=\"sendemail_code\"), # 邮箱验证码 在deco-user.js文件中编写发送邮件验证码js代码 1234567891011121314151617181920212223242526272829303132333435363738//修改个人中心邮箱验证码function sendCodeChangeEmail($btn)&#123; var verify = verifyDialogSubmit( [ &#123;id: '#jsChangeEmail', tips: Dml.Msg.epMail, errorTips: Dml.Msg.erMail, regName: 'email', require: true&#125; ] ); if(!verify)&#123; return; &#125; $.ajax(&#123; cache: false, type: \"get\", dataType:'json', url:\"/users/sendemail_code/\", data:$('#jsChangeEmailForm').serialize(), async: true, beforeSend:function(XMLHttpRequest)&#123; $btn.val(\"发送中...\"); $btn.attr('disabled',true); &#125;, success: function(data)&#123; if(data.email)&#123; Dml.fun.showValidateError($('#jsChangeEmail'), data.email); &#125;else if(data.status == 'success')&#123; Dml.fun.showErrorTips($('#jsChangeEmailTips'), \"邮箱验证码已发送\"); &#125;else if(data.status == 'failure')&#123; Dml.fun.showValidateError($('#jsChangeEmail'), \"邮箱验证码发送失败\"); &#125;else if(data.status == 'success')&#123; &#125; &#125;, complete: function(XMLHttpRequest)&#123; $btn.val(\"获取验证码\"); $btn.removeAttr(\"disabled\"); &#125; &#125;); &#125; Debug测试输入已存在的邮箱地址，进行发送 Debug断点测试完成后，回到页面则提示邮箱已存在 为了测试发送邮件，将之前注册时的cdtaogang@sina.com邮箱修改成taogangshow@sina.com，因为之前settings配置的是cdtaogang@sina.com邮箱的配置 测试发送邮箱验证码功能 但这个邮箱验证码过长，一般都是4位，即所以在send_register_email函数中进行判断 1234if send_type == \"update_email\": code = random_str(4)else: code = random_str(16) 重新测试发送邮箱验证码，查看验证码位数 逻辑说明：紧接着就是根据邮箱验证码完成验证，验证通过后，在数据库中修改邮箱地址，需要说明一点就是当用户发送邮箱验证码成功后，则需要在邮件中记住或复制验证码到输入框中，点击完成按钮，则进行邮箱验证码的验证，当验证通过后则表示修改邮箱地址成功 定义修改邮箱类视图 123456789101112class UpdateEmailView(LoginRequiredMixin, View): \"\"\"修改个人邮箱\"\"\" def post(self, request): email = request.POST.get(\"email\", \"\") code = request.POST.get(\"code\", \"\") exited_records = EmailVerifyRecord.objects.filter(email=email, code=code, send_type=\"update_email\") if exited_records: user = request.user user.email = email user.save() return HttpResponse('&#123;\"status\":\"success\"&#125;', content_type='application/json') return HttpResponse('&#123;\"email\":\"验证码错误\"&#125;', content_type='application/json') 定义视图路由 1url(r'^update_email/$', UpdateEmailView.as_view(), name=\"update_email\"), # 修改邮箱 在deco-user.js中定义邮箱修改js代码 1234567891011121314151617181920212223242526272829303132333435363738//个人资料邮箱修改function changeEmailSubmit($btn)&#123;var verify = verifyDialogSubmit( [ &#123;id: '#jsChangeEmail', tips: Dml.Msg.epMail, errorTips: Dml.Msg.erMail, regName: 'email', require: true&#125;, ] ); if(!verify)&#123; return; &#125; $.ajax(&#123; cache: false, type: 'post', dataType:'json', url:\"/users/update_email/ \", data:$('#jsChangeEmailForm').serialize(), async: true, beforeSend:function(XMLHttpRequest)&#123; $btn.val(\"发送中...\"); $btn.attr('disabled',true); $(\"#jsChangeEmailTips\").html(\"验证中...\").show(500); &#125;, success: function(data) &#123; if(data.email)&#123; Dml.fun.showValidateError($('#jsChangeEmail'), data.email); &#125;else if(data.status == \"success\")&#123; Dml.fun.showErrorTips($('#jsChangePhoneTips'), \"邮箱信息更新成功\"); setTimeout(function()&#123;location.reload();&#125;,1000); &#125;else&#123; Dml.fun.showValidateError($('#jsChangeEmail'), \"邮箱信息更新失败\"); &#125; &#125;, complete: function(XMLHttpRequest)&#123; $btn.val(\"完成\"); $btn.removeAttr(\"disabled\"); &#125; &#125;);&#125; Debug测试修改邮箱地址（输入不存在的验证码） Debug断点测试完成后，查看修改页面，成功显示出错误信息 测试修改邮箱功能 8.个人资料修改 因为使用post表单提交的请求方式，所以直接在UserInfoView类视图中定义post方法来完成用户个人资料的修改保存操作 12345678910111213class UserInfoView(LoginRequiredMixin, View): \"\"\"用户信息页\"\"\" def get(self, request): current_page = \"info\" return render(request, \"usercenter-info.html\", &#123;\"current_page\":current_page&#125;) def post(self, request): user_info_form = UserInfoForm(request.POST, instance=request.user) if user_info_form.is_valid(): user_info_form.save() return HttpResponse('&#123;\"status\":\"success\"&#125;', content_type='application/json') else: return HttpResponse(json.dumps(user_info_form.errors), content_type='application/json') 在deco-user.js中编写js代码来操控表单的提交操作以及提示信息展示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//保存个人资料$('#jsEditUserBtn').on('click', function()&#123; var _self = $(this), $jsEditUserForm = $('#jsEditUserForm'); verify = verifySubmit( [ &#123;id: '#nick_name', tips: Dml.Msg.epNickName, require: true&#125; ] ); if(!verify)&#123; return; &#125; $.ajax(&#123; cache: false, type: 'post', dataType:'json', url:\"/users/info/\", data:$jsEditUserForm.serialize(), async: true, beforeSend:function(XMLHttpRequest)&#123; _self.val(\"保存中...\"); _self.attr('disabled',true); &#125;, success: function(data) &#123; if(data.nick_name)&#123; _showValidateError($('#nick_name'), data.nick_name); &#125;else if(data.birday)&#123; _showValidateError($('#birth_day'), data.birday); &#125;else if(data.address)&#123; _showValidateError($('#address'), data.address); &#125;else if(data.status == \"failure\")&#123; Dml.fun.showTipsDialog(&#123; title: '保存失败', h2: data.msg &#125;); &#125;else if(data.status == \"success\")&#123; Dml.fun.showTipsDialog(&#123; title: '保存成功', h2: '个人信息修改成功！' &#125;); setTimeout(function()&#123;window.location.href = window.location.href;&#125;,1500); &#125; &#125;, complete: function(XMLHttpRequest)&#123; _self.val(\"保存\"); _self.removeAttr(\"disabled\"); &#125; &#125;);&#125;); Debug测试输入空字段表单进行修改 Debug断点测试完成后回到个人信息页面，则成功出现form表单验证的错误提示 测试个人资料修改功能 三丶用户个人中心（我的课程）1.显示我的课程页面 模板继承 定义个人资料类视图 12345class MyCourseView(LoginRequiredMixin,View): \"\"\"我的课程\"\"\" def get(self, request): current_page = \"course\" return render(request, \"usercenter-mycourse.html\", &#123;\"current_page\":current_page&#125;) 定义视图路由 1url(r'^mycourse/$', MyCourseView.as_view(), name=\"mycourse\"), # 我的课程 修改模板中我的课程链接地址以及判断链接激活状态 1&lt;li class=\"&#123;% if current_page == 'course' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'users:mycourse' %&#125;\"&gt;我的课程&lt;/a&gt;&lt;/li&gt; 测试显示我的课程页面 2.动态显示出我的课程数据 在视图中根据当前的登录成功的user对象到UserCourse模型表中查询对应usercourse对象 123456class MyCourseView(LoginRequiredMixin,View): \"\"\"我的课程\"\"\" def get(self, request): current_page = \"course\" user_courses = UserCourse.objects.filter(user=request.user) return render(request, \"usercenter-mycourse.html\", &#123;\"current_page\":current_page, \"user_courses\":user_courses&#125;) 在模板中打印页面数据 12345678910111213141516171819&lt;div class=\"group_list brief\"&gt; &#123;% for user_course in user_courses %&#125; &lt;div class=\"module1_5 box\"&gt; &lt;a href=\"&#123;% url 'course:course_detail' user_course.course.id%&#125;\"&gt; &lt;img width=\"214\" height=\"190\" class=\"scrollLoading\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; user_course.course.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;div class=\"des\"&gt; &lt;a href=\"&#123;% url 'course:course_detail' user_course.course.id%&#125;\"&gt;&lt;h2&gt;&#123;&#123; user_course.course.name &#125;&#125;&lt;/h2&gt;&lt;/a&gt; &lt;span class=\"fl\"&gt;课时：&lt;i class=\"key\"&gt;&#123;&#123; user_course.course.learn_times &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;span class=\"fr\"&gt;学习人数：&#123;&#123; user_course.course.students &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;span class=\"fl\"&gt;&#123;&#123; user_course.course.course_org.name &#125;&#125;&lt;/span&gt; &lt;span class=\"star fr notlogin\" data-favid=\"15\"&gt;&#123;&#123; user_course.course.fav_nums &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 测试显示我的课程页面动态数据 四丶用户个人中心（我的收藏）再次说明：我的收藏模块包括三个页面（课程机构丶授课教师丶公开课程） 1.我的收藏——课程机构页面 模板继承 定义视图 123456789101112class MyFavOrgView(LoginRequiredMixin,View): \"\"\"我的收藏——课程机构\"\"\" def get(self, request): current_page = \"myfav\" current_fav_page_1 = \"myfav_org\" org_list = [] fav_orgs = UserFavorite.objects.filter(user=request.user, fav_type=2) for fav_org in fav_orgs: org_id = fav_org.fav_id org = CourseOrg.objects.get(id=org_id) org_list.append(org) return render(request, \"usercenter-fav-org.html\", &#123;\"current_page\":current_page, \"current_fav_page_1\":current_fav_page_1, \"org_list\":org_list&#125;) 定义视图路由 1url(r'^myfav/org/$', MyFavOrgView.as_view(), name=\"myfav_org\"), # 我的收藏——课程机构 修改父模板我的收藏链接地址以及判断点击激活状态 1&lt;li class=\"&#123;% if current_page == 'myfav' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'users:myfav_org' %&#125;\"&gt;我的收藏&lt;/a&gt;&lt;/li&gt; 修改模板中课程机构链接地址以及判断点击激活状态，这里根据current_fav_page_1来判断我的收藏页面中的课程机构激活状态 1&lt;li class=\"&#123;% if current_fav_page_1 == 'myfav_org' %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'users:myfav_org' %&#125;\"&gt;课程机构&lt;/a&gt; &lt;/li&gt; 在模板中打印数据 1234567891011121314151617181920212223242526&lt;div class=\"messagelist\"&gt; &#123;% for org in org_list %&#125; &lt;div class=\"messages butler_list company company-fav-box\"&gt; &lt;dl class=\"des fr\"&gt; &lt;dt&gt; &lt;a href=\"&#123;% url 'org:org_home' org.id%&#125;\"&gt; &lt;img width=\"160\" height=\"90\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; org.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;/dt&gt; &lt;dd&gt; &lt;h1&gt;&lt;a href=\"&#123;% url 'org:org_home' org.id%&#125;\"&gt;&#123;&#123; org.name &#125;&#125;&lt;/a&gt;&lt;/h1&gt; &lt;div class=\"pic fl\" style=\"width:auto;\"&gt; &lt;img src=\"&#123;% static 'images/authentication.png' %&#125;\"/&gt; &lt;img src=\"&#123;% static 'images/gold.png' %&#125;\"/&gt; &lt;/div&gt; &lt;span class=\"c8 clear\"&gt;&#123;&#123; org.address &#125;&#125;&lt;/span&gt; &lt;div class=\"delete jsDeleteFav_org\" data-favid=\"1\"&gt;&lt;/div&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 测显示我的收藏——课程机构页面动态数据 测试对机构进行收藏后，查看我的收藏——课程机构页面是否成功显示出收藏的机构 2.我的收藏——授课教师页面 模板继承 逻辑跟课程机构页面一样，首先定义视图 123456789101112class MyFavTeacherView(LoginRequiredMixin,View): \"\"\"我的收藏——授课讲师\"\"\" def get(self, request): current_page = \"myfav\" current_fav_page_2 = \"myfav_teacher\" teacher_list = [] fav_teachers = UserFavorite.objects.filter(user=request.user, fav_type=3) for fav_teacher in fav_teachers: teacher_id = fav_teacher.fav_id teacher = Teacher.objects.get(id=teacher_id) teacher_list.append(teacher) return render(request, \"usercenter-fav-teacher.html\", &#123;\"current_page\":current_page, \"current_fav_page_2\":current_fav_page_2, \"teacher_list\":teacher_list&#125;) 定义视图路由 1url(r'^myfav/teacher/$', MyFavTeacherView.as_view(), name=\"myfav_teacher\"), # 我的收藏——授课教师 修改模板中的授课教师链接地址，根据current_fav_page_2变量的值来判断授课教师按钮的激活状态 1&lt;li class=\"&#123;% if current_fav_page_2 == 'myfav_teacher' %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'users:myfav_teacher' %&#125;\"&gt;授课教师 &lt;/a&gt;&lt;/li&gt; 页面需要显示出课程数，则需要在Teacher模型类中定义一个方法，来获取教师的课程数 12def get_course_nums(self): return self.course_set.all().count() 在模板中打印数据 1234567891011121314151617181920212223242526272829&lt;div class=\"messagelist\"&gt; &#123;% for teacher in teacher_list %&#125; &lt;div class=\" butler_list butler-fav-box\"&gt; &lt;dl class=\"des users\"&gt; &lt;dt&gt; &lt;a href=\"&#123;% url 'org:teacher_detail' teacher.id %&#125;\"&gt; &lt;img width=\"100\" height=\"100\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; teacher.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;/dt&gt; &lt;dd&gt; &lt;h1&gt; &lt;a href=\"&#123;% url 'org:teacher_detail' teacher.id %&#125;\"&gt; &#123;&#123; teacher.name &#125;&#125;&lt;span class=\"key\"&gt;认证教师&lt;/span&gt; &lt;/a&gt; &lt;/h1&gt; &lt;ul class=\"cont clearfix\"&gt; &lt;li class=\"time\"&gt;工作年限：&lt;span&gt;&#123;&#123; teacher.work_years &#125;&#125;年&lt;/span&gt;&lt;/li&gt; &lt;li class=\"c7\"&gt;课程数：&lt;span&gt;&#123;&#123; teacher.get_course_nums &#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"cont clearfix\"&gt; &lt;li class=\"time\"&gt;工作公司：&lt;span&gt;&#123;&#123; teacher.work_company &#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;li class=\"c7\"&gt;公司职位：&lt;span&gt;&#123;&#123; teacher.work_position &#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;div class=\"delete jsDeleteFav_teacher\" data-favid=\"1\"&gt;&lt;/div&gt; &lt;/dl&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 测试显示我的收藏——授课教师页面动态数据 测试对授课讲师进行收藏后，在个人中心我的收藏——授课教师页面，显示收藏的授课讲师 3.我的收藏——公开课程页面 模板继承 定义视图 123456789101112class MyFavCourseView(LoginRequiredMixin,View): \"\"\"我的收藏——公开课程\"\"\" def get(self, request): current_page = \"myfav\" current_fav_page_3 = \"myfav_course\" course_list = [] fav_courses = UserFavorite.objects.filter(user=request.user, fav_type=1) for fav_course in fav_courses: course_id = fav_course.fav_id course = Course.objects.get(id=course_id) course_list.append(course) return render(request, \"usercenter-fav-course.html\", &#123;\"current_page\":current_page, \"current_fav_page_3\":current_fav_page_3, \"course_list\":course_list&#125;) 定义视图路由 1url(r'^myfav/course/$', MyFavCourseView.as_view(), name=\"myfav_course\"), # 我的收藏——公开课程 修改模板中公开课程链接地址，根据current_fav_page_3变量的值来判断我的收藏——公开课程点击激活状态 1&lt;li class=\"&#123;% if current_fav_page_3 == 'myfav_course' %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'users:myfav_course' %&#125;\"&gt;公开课程&lt;/a&gt;&lt;/li&gt; 在模板中打印页面数据 123456789101112131415161718&lt;div class=\"group_list brief\"&gt; &#123;% for course in course_list %&#125; &lt;div class=\"module1_5 box\"&gt; &lt;a href=\"&#123;% url 'course:course_detail' course.id%&#125;\"&gt; &lt;img width=\"214\" height=\"190\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;div class=\"des\"&gt; &lt;a href=\"course-detail.html\"&gt;&lt;h2&gt;&#123;&#123; course.name &#125;&#125;&lt;/h2&gt;&lt;/a&gt; &lt;span class=\"fl\"&gt;时长：&lt;i class=\"key\"&gt;&#123;&#123; course.learn_times &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;span class=\"fr\"&gt;学习人数：&#123;&#123; course.students &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;span class=\"fl\"&gt;&#123;&#123; course.course_org &#125;&#125;&lt;/span&gt; &lt;span class=\"delete-group fr jsDeleteFav_course\" data-favid=\"12\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 测试显示我的收藏——公开课程页面动态数据 测试在收藏公开课，回到个人中心我的收藏——公开课程页面，查看收藏的公开课 4.我的收藏所有页面中删除功能（取消收藏） 在父模板usercenter_base模板中编写三个页面的点击事件，使用ajax post异步请求方式，向后端AddFavView视图接口发送请求完成数据库对UserFavorite模型表的数据删除操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;script type=\"text/javascript\"&gt; $('.jsDeleteFav_course').on('click', function()&#123; var _this = $(this), favid = _this.attr('data-favid'); &#123;#alert(favid);#&#125; $.ajax(&#123; cache: false, type: \"POST\", url: \"/org/add_fav/\", data: &#123; fav_type: 1, fav_id: favid, csrfmiddlewaretoken: '&#123;&#123; csrf_token &#125;&#125;' &#125;, async: true, success: function(data) &#123; Dml.fun.winReload(); &#125; &#125;); &#125;); $('.jsDeleteFav_teacher').on('click', function()&#123; var _this = $(this), favid = _this.attr('data-favid'); $.ajax(&#123; cache: false, type: \"POST\", url: \"/org/add_fav/\", data: &#123; fav_type: 3, fav_id: favid, csrfmiddlewaretoken: '&#123;&#123; csrf_token &#125;&#125;' &#125;, async: true, success: function(data) &#123; Dml.fun.winReload(); &#125; &#125;); &#125;); $('.jsDeleteFav_org').on('click', function()&#123; var _this = $(this), favid = _this.attr('data-favid'); $.ajax(&#123; cache: false, type: \"POST\", url: \"/org/add_fav/\", data: &#123; fav_type: 2, fav_id: favid, csrfmiddlewaretoken: '&#123;&#123; csrf_token &#125;&#125;' &#125;, async: true, success: function(data) &#123; Dml.fun.winReload(); &#125; &#125;); &#125;);&lt;/script&gt; 在三个页面对应的模板文件中，需要修改favid得值也就是删除按钮所在的标签中data-favid属性的值为页面模型表的id 123456&lt;!-- 课程机构 --&gt;&lt;div class=\"delete jsDeleteFav_org\" data-favid=\"&#123;&#123; org.id &#125;&#125;\"&gt;&lt;/div&gt;&lt;!-- 授课教师 --&gt;&lt;div class=\"delete jsDeleteFav_teacher\" data-favid=\"&#123;&#123; teacher.id &#125;&#125;\"&gt;&lt;/div&gt;&lt;!-- 公开课程 --&gt;&lt;span class=\"delete-group fr jsDeleteFav_course\" data-favid=\"&#123;&#123; course.id &#125;&#125;\"&gt;&lt;/span&gt; 测试我的收藏三个页面删除功能（取消收藏） 五丶用户个人中心（我的消息）1.显示我的消息页面 模板继承 定义视图 12345class MyMessageView(LoginRequiredMixin, View): \"\"\"我的消息\"\"\" def get(self, request): current_page = \"message\" return render(request, \"usercenter-message.html\", &#123;\"current_page\": current_page&#125;) 定义视图路由 1url(r'^mymessage/$', MyMessageView.as_view(), name=\"mymessage\"), # 我的消息 在父模板中修改我的消息链接地址，以及根据厚端传递的current_page的值判断点击激活状态 12345&lt;li class=\"&#123;% if current_page == 'message' %&#125;active2&#123;% endif %&#125;\"&gt; &lt;a href=\"&#123;% url 'users:mymessage' %&#125;\" style=\"position: relative;\"&gt; 我的消息 &lt;/a&gt;&lt;/li&gt; 测试显示个人中心——我的消息页面 2.动态显示我的消息页面数据 说明：当用户注册成功后，应该在模型表UserMessage添加欢迎用户注册消息 分析：除了在我的消息中显示所有的用户消息之外，在每个页面顶部会有个小喇叭按钮，该按钮会显示出用户未读的消息数量，当用户点击进入我的消息后，则小喇叭的数量为0 首先在注册视图RegisterView中向UserMessage模型表中写入欢迎注册消息 12345# 写入欢迎注册消息user_message = UserMessage()user_message.user = user_profileuser_message.message = \"欢迎注册慕学在线网\"user_message.save() 在MyMessageView类视图中首先获取当前登录用户所有的消息，该获取的所有消息用于在我的消息页面进行显示，不管用户已读还是未读都进行显示到此页面；再从数据库中获取该用户的未读消息，遍历每个对象设置每个对象的has_read字段的值为True也就是设置为已读；接下来就是分页数据处理了，这个已经在很多列表页中进行说明了，就不细说了 12345678910111213141516171819class MyMessageView(LoginRequiredMixin, View): \"\"\"我的消息\"\"\" def get(self, request): current_page = \"message\" # 查询当前用户的所有消息 all_messages = UserMessage.objects.filter(user=request.user.id) # 用户进入个人消息后清空未读消息的记录 all_unread_messages = UserMessage.objects.filter(user=request.user.id, has_read=False) for unread_message in all_unread_messages: unread_message.has_read = True unread_message.save() # 分页处理 try: page = request.GET.get('page', 1) except PageNotAnInteger: page = 1 p = Paginator(all_messages, 5, request=request) messages = p.page(page) return render(request, \"usercenter-message.html\", &#123;\"current_page\": current_page, \"messages\": messages&#125;) 在模板中打印显示页面动态数据 123456789101112131415161718&lt;div class=\"head\"&gt; &lt;ul class=\"tab_header messagehead\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"&#123;% url 'users:mymessage' %&#125;\"&gt;个人消息&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=\"messagelist\"&gt; &#123;% for message in messages.object_list %&#125; &lt;div class=\"messages\"&gt; &lt;div class=\"fr\"&gt; &lt;div class=\"top\"&gt;&lt;span class=\"fl time\"&gt;&#123;&#123; message.add_time &#125;&#125;&lt;/span&gt;&lt;span class=\"fr btn foldbtn\"&gt;&lt;/span&gt;&lt;/div&gt; &lt;p&gt; &#123;&#123; message.message &#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 页面分页代码 123456789101112131415161718192021&lt;div class=\"pageturn pagerright\"&gt; &lt;ul class=\"pagelist\"&gt; &#123;% if messages.has_previous %&#125; &lt;li class=\"long\"&gt;&lt;a href=\"?&#123;&#123; messages.previous_page_number.querystring &#125;&#125;\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% for page in messages.pages %&#125; &#123;% if page %&#125; &#123;% ifequal page messages.number %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"?&#123;&#123; page.querystring &#125;&#125;\"&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"?&#123;&#123; page.querystring &#125;&#125;\" class=\"page\"&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endifequal %&#125; &#123;% else %&#125; &lt;li class=\"none\"&gt;&lt;a href=\"\"&gt;...&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if messages.has_next %&#125; &lt;li class=\"long\"&gt;&lt;a href=\"?&#123;&#123; messages.next_page_number.querystring &#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125;&lt;/ul&gt;&lt;/div&gt; 为了方便测试，所以在xadmin后台进行数据添加，需要注意的是用户字段（user）是填写用户的id，因为当初在模型类中user字段为int类型，默认是否已读字段为False 测试显示页面动态数据 3.在页面顶部栏小喇叭处显示未读消息 说明：因为所有页面顶部都设计小喇叭消息，所以需要在UserProfile模型类中，需定义一个方法来获取当前用户未读消息数量，可以让每个模板进行调用此方法 在UserProfile模型类中获取用户未读消息数量 1234def get_user_unread_nums(self): \"\"\"获取用户未读消息数量\"\"\" from operation.models import UserMessage return UserMessage.objects.filter(user=self.id, has_read=0).count() 因为每个页面都涉及顶部小喇叭消息，所以需要在所有父模板文件中，首先修改链接地址，然后通过request.user对象调用其模型类中的定义的get_user_unread_nums方法获取未读数量 123&lt;a href=\"&#123;% url 'users:mymessage' %&#125;\"&gt; &lt;div class=\"msg-num\"&gt;&lt;span id=\"MsgNum\"&gt;&#123;&#123; request.user.get_user_unread_nums &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;/a&gt; 测试之前需要在数据库中设置has_read字段的值为0也就表示未读消息，好方便进行测试 测试查看各个页面顶部小喇叭未读消息数量是否显示正确成功，然后进入我的消息页面，即各个页面顶部小喇叭未读消息数量则显示为0 六丶用户个人中心（退出）1.定义退出视图 123456class LogoutView(View): \"\"\"退出登录\"\"\" def get(self, request): logout(request) # 重定向到主页 return HttpResponseRedirect(reverse('index')) 2.在根级urls中定义视图路由 1url(r'^logout/$', LogoutView.as_view(), name=\"logout\"), # 用户退出 3.在三个父模板中，修改退出功能按钮链接地址 1&lt;a class=\"fr\" href=\"&#123;% url 'logout' %&#125;\"&gt;退出&lt;/a&gt; 4.测试退出功能 七丶 首页、全局功能细节和404以及500页面配置说明：将所有页涉及到的跳转链接地址进行修改（此细节就不做演示了） 1.全局功能细节 课程点击数增加（courses/views.CourseInfoView） 123# 当用点击开始学习进入章节信息页后则学习人数course.students += 1course.save() 教师点击数增加（organization/views.TeacherDetailView） 12teacher.click_nums += 1teacher.save() 机构点击数增加（organization/views.OrgHomeView） 12course_org.click_nums += 1course_org.save() 课程学习人数的增加（courses/views.VideoPlayView） 123# 当用点击开始学习进入章节信息页后则学习人数course.students += 1course.save() 课程丶课程机构丶讲师收藏数的增加（organization/views.AddFavView） 12345678910111213141516171819# 设置课程丶机构丶讲师的收藏数+1if int(fav_type) == 1: course = Course.objects.get(id=int(fav_id)) course.fav_nums -= 1 if course.fav_nums &lt; 0: course.fav_nums = 0 course.save()elif int(fav_type) == 2: course_org = CourseOrg.objects.get(id=int(fav_id)) course_org.fav_nums -= 1 if course_org.fav_nums &lt; 0: course_org.fav_nums = 0 course_org.save()elif int(fav_type) == 3: teacher = Teacher.objects.get(id=int(fav_id)) teacher.fav_nums -= 1 if teacher.fav_nums &lt; 0: teacher.fav_nums = 0 teacher.save() 课程丶课程机构丶讲师收藏数的减少（organization/views.AddFavView） 12345678910111213# 设置课程丶机构丶讲师的收藏数-1if int(fav_type) == 1: course = Course.objects.get(id=int(fav_id)) course.fav_nums += 1 course.save()elif int(fav_type) == 2: course_org = CourseOrg.objects.get(id=int(fav_id)) course_org.fav_nums += 1 course_org.save()elif int(fav_type) == 3: teacher = Teacher.objects.get(id=int(fav_id)) teacher.fav_nums += 1 teacher.save() 2.首页动态数据显示 定义视图 12345678910111213class IndexView(View): \"\"\"主页\"\"\" def get(self, request): # 驱逐主页轮播图 all_banners = Banner.objects.all().order_by('index') # 取出主页课程栏的6门课程 courses = Course.objects.filter(is_banner=False)[:6] # 取出主页课程栏的3门轮播课程 banner_courses = Course.objects.filter(is_banner=True)[:3] # 取出主页授课机构栏的15门机构 course_orgs = CourseOrg.objects.all()[:15] return render(request, \"index.html\", &#123;\"all_banners\":all_banners, \"courses\":courses, \"banner_courses\":banner_courses, \"course_orgs\":course_orgs&#125;) 在根据urls中配置路由对应的视图 1url(r'^$', IndexView.as_view(), name=\"index\"), # 主页 在xadmin后端中添加主页轮播图 在主页公开课程栏中还嵌套了一个小的轮播图，所以需要在Course模型类中增加一个字段，来判断该课程是否进行轮播标记 1is_banner = models.BooleanField(default=False, verbose_name=u\"是否轮播\") 生成对应数据表字段 需要在xadmin后台中课程中设置要进行轮播的课程 在首页课程机构栏列表中的课程需要添加tag机构标签，所以需在organization/models中的CourseOrg模型表添加该字段 1tag = models.CharField(default=\"全国知名\", max_length=10, verbose_name=u\"机构标签\") 生成对应的数据表字段 在index模板中打印页面动态数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!-------------- 轮播图 --------------&gt;&lt;div class=\"imgslide\"&gt; &lt;ul class=\"imgs\"&gt; &#123;% for banner in all_banners %&#125; &lt;li&gt; &lt;a href=\"&#123;&#123; banner.url &#125;&#125;\"&gt; &lt;img width=\"1200\" height=\"478\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; banner.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/div&gt;&lt;!-------------- 公开课程 --------------&gt;&lt;div class=\"module1_1 left\"&gt; &lt;img width=\"228\" height=\"614\" src=\"&#123;% static 'images/module1_1.jpg' %&#125;\"/&gt; &lt;p class=\"fisrt_word\"&gt;名师授课&lt;br/&gt;专业权威&lt;/p&gt; &lt;a class=\"more\" href=\"&#123;% url 'course:course_list' %&#125;\"&gt;查看更多课程 &gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=\"right group_list\"&gt; &lt;div class=\"module1_2 box\"&gt; &lt;div class=\"imgslide2\"&gt; &lt;ul class=\"imgs\"&gt; &#123;% for banner_course in banner_courses %&#125; &lt;li&gt; &lt;a href=\"&#123;% url 'course:course_detail' banner_course.id %&#125;\"&gt; &lt;img width=\"470\" height=\"300\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; banner_course.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"unslider-arrow2 prev\"&gt;&lt;/div&gt; &lt;div class=\"unslider-arrow2 next\"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% for course in courses %&#125; &lt;div class=\"module1_&#123;&#123; forloop.counter|add:2 &#125;&#125; box\"&gt; &lt;a href=\"&#123;% url 'course:course_detail' course.id%&#125;\"&gt; &lt;img width=\"233\" height=\"190\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;div class=\"des\"&gt; &lt;a href=\"course-detail.html\"&gt; &lt;h2 title=\"django入门\"&gt;&#123;&#123; course.name &#125;&#125;&lt;/h2&gt; &lt;/a&gt; &lt;span class=\"fl\"&gt;难度：&lt;i class=\"key\"&gt;&#123;&#123; course.get_degree_display &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;span class=\"fr\"&gt;学习人数：&#123;&#123; course.students &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;span class=\"fl\" title=\"慕课网\"&gt;&#123;&#123; course.course_org.name &#125;&#125;&lt;/span&gt; &lt;span class=\"star fr\"&gt;&#123;&#123; course.fav_nums &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt;&lt;!-------------- 课程机构 --------------&gt;&lt;div class=\"module3 eachmod\"&gt; &lt;div class=\"module3_1 left\"&gt; &lt;img width=\"228\" height=\"463\" src=\"&#123;% static 'images/module3_1.jpg' %&#125;\"/&gt; &lt;p class=\"fisrt_word\"&gt;名校来袭&lt;br/&gt;权威认证&lt;/p&gt; &lt;a class=\"more\" href=\"&#123;% url 'org:org_list' %&#125;\"&gt;查看更多机构 &gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;ul&gt; &#123;% for course_org in course_orgs %&#125; &lt;li class=\"&#123;% if forloop.counter|divisibleby:'5' %&#125;five&#123;% endif %&#125;\"&gt; &lt;a href=\"&#123;% url 'org:org_home' course_org.id %&#125;\"&gt; &lt;div class=\"company\"&gt; &lt;img width=\"184\" height=\"100\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course_org.image &#125;&#125;\"/&gt; &lt;div class=\"score\"&gt; &lt;div class=\"circle\"&gt; &lt;h2&gt;&#123;&#123; course_org.tag &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;&lt;span class=\"key\" title=\"&#123;&#123; course_org.name &#125;&#125;\"&gt;&#123;&#123; course_org.name &#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 测试显示主页动态数据 3.404以及500页面配置 在users/views中定义一个方法，获取404页面的响应数据并进行返回 123456def page_not_found(request): \"\"\"全局404页面\"\"\" from django.shortcuts import render_to_response response = render_to_response(\"404.html\") response.status_code = 404 return response 在根级urls中配置全局404路由 12# 全局404页面配置handler404 = \"users.views.page_not_found\" 还需要将项目开发环境配置成生产环境（线上环境） 123DEBUG = False ALLOWED_HOSTS = [\"*\"] 访问不存在的页面http://127.0.0.1:8000/111 结果成功渲染了指定的404页面，但页面的静态资源文件并没有加载成功，这个问题在之前的项目Django项目中已经说明过了，因为将settings中的DEBUG设置为False后django就不会帮我们管理静态资源文件了 解决方法就是：想要在线上环境加载静态资源文件，并且不使用代理服务器如apache或nginx，那么就像配置media静态目录上传的图片那样进行配置，首先在settings文件中添加静态资源目录static 1STATIC_ROOT = os.path.join(BASE_DIR, 'static') 然后在根级urls中配置静态文件处理函数 1url(r'^static/(?P&lt;path&gt;.*)$', serve, &#123;\"document_root\":STATIC_ROOT&#125;), # 配置静态文件处理函数 刷新页面成功加载出404页资源文件 500页面跟上面逻辑代码啥的都一样，首先在users/views中定义一个方法，获取500页面的响应数据并进行返回 123456def page_server_error(request): \"\"\"全局404页面\"\"\" from django.shortcuts import render_to_response response = render_to_response(\"500.html\") response.status_code = 500 return response 在根级urls中配置全局500路由 1handler500 = &quot;users.views.page_server_error&quot; 测试显示500服务器错误页面，完成该测试需要在主页视图IndexView中打印1/0则会抛出服务器错误500状态码 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/90141577","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目于之在线教育平台网站的实战开发（四）","slug":"Django项目于之在线教育平台网站的实战开发（四）","date":"2019-11-15T05:57:58.675Z","updated":"2019-11-15T06:48:46.096Z","comments":true,"path":"2019/11/15/Django项目于之在线教育平台网站的实战开发（四）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/15/Django项目于之在线教育平台网站的实战开发（四）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶公开课（详情页） 二丶公开课（开始学习） 三丶公开课（课程评论） 四丶公开课（课程播放） 五丶授课教师（列表页） 六丶授课教师（详情页）","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶公开课（详情页） 二丶公开课（开始学习） 三丶公开课（课程评论） 四丶公开课（课程播放） 五丶授课教师（列表页） 六丶授课教师（详情页） 一丶公开课（详情页）1.显示课程详情页 模板继承这个不用多说了 定义类视图get方法，用于显示页面 1234class CourseDetailView(View): \"\"\"课程详情页\"\"\" def get(self, request, course_id): return render(request, \"course-detail.html\") 定义url路由 1url(r'^detail/(?P&lt;course_id&gt;\\d+)/$', CourseDetailView.as_view(), name=\"course_detail\"), # 课程列表页 在课程列表页中修改课程详情链接地址 12345678910111213141516171819202122&#123;% for course in all_courses.object_list %&#125;&lt;div class=\"box\"&gt; &lt;a href=\"&#123;% url 'course:course_detail' course.id %&#125;\"&gt; &lt;img width=\"280\" height=\"350\" class=\"scrollLoading\" src=&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course.image &#125;&#125;/&gt; &lt;/a&gt; &lt;div class=\"des\"&gt; &lt;a href=\"&#123;% url 'course:course_detail' course.id %&#125;\"&gt; &lt;h2&gt;&#123;&#123; course.name &#125;&#125;&lt;/h2&gt; &lt;/a&gt; &lt;span class=\"fl\"&gt;时长：&lt;i class=\"key\"&gt;&#123;&#123; course.learn_times &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;span class=\"fr\"&gt;学习人数：&#123;&#123; course.students &#125;&#125;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;a href=\"&#123;% url 'course:course_detail' course.id %&#125;\"&gt;&lt;span class=\"fl\"&gt;来自&#123;&#123; course.course_org.name &#125;&#125;&lt;/span&gt;&lt;/a&gt; &lt;span class=\"star fr notlogin \" data-favid=\"15\"&gt; &#123;&#123; course.fav_nums &#125;&#125; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endfor %&#125; 测试在课程列表页点击课程，则显示课程详情页 2.动态显示出课程详情页数据 在类视图中根据请求地址传递的课程id获取对应的课程信息数据，当用户点击进入课程详情页时，则点击数+1 12345678class CourseDetailView(View): \"\"\"课程详情页\"\"\" def get(self, request, course_id): course = Course.objects.get(id=int(course_id)) # 当用户点击进入课程详情页时，则课程点击数+1 course.click_nums += 1 course.save() return render(request, \"course-detail.html\", &#123;\"course\":course&#125;) 分析课程详情页面中的（章节数和课程类别以及学习用户），在Course模型类中没有的字段 紧接着需要在模型类中，获取章节数以及学习用户信息，因为该两个字段是UserCourse模型表和Lesson表的外键，即可以使用django models提供self.小写表名_set方法获取字段信息 12345678def get_zj_nums(self): #获取课程章节数 return self.lesson_set.all().count()get_zj_nums.short_description = \"章节数\" def get_learn_users(self):# 获取课程学习用户return self.usercourse_set.all()[:5] 课程类别则需要在Course模型表中添加category字段 1category = models.CharField(default=u\"后端开发\", max_length=20, verbose_name=u\"课程类别\") 生成对应的数据表category字段 最后在课程详情模板中打印字段数据即可 12345678910111213141516&lt;h1 title=\"django 从入门到精通体验开始了\"&gt;&#123;&#123; course.name &#125;&#125;&lt;/h1&gt;&lt;span class=\"key\"&gt;&#123;&#123; course.desc &#125;&#125;&lt;/span&gt;&lt;div class=\"prize\"&gt; &lt;span class=\"fl\"&gt;难度：&lt;i class=\"key\"&gt;&#123;&#123; course.get_degree_display &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;span class=\"fr\"&gt;学习人数：&#123;&#123; course.students &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;ul class=\"parameter\"&gt; &lt;li&gt;&lt;span class=\"pram word3\"&gt;时&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;长：&lt;/span&gt;&lt;span&gt;&#123;&#123; course.learn_times &#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=\"pram word3\"&gt;章&amp;nbsp;节&amp;nbsp;数：&lt;/span&gt;&lt;span&gt;&#123;&#123; course.get_zj_nums &#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=\"pram word3\"&gt;课程类别：&lt;/span&gt;&lt;span title=\"\"&gt;&#123;&#123; course.category &#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;li class=\"piclist\"&gt;&lt;span class=\"pram word4\"&gt;学习用户：&lt;/span&gt; &#123;% for course_user in course.get_learn_users %&#125; &lt;span class=\"pic\"&gt;&lt;img width=\"40\" height=\"40\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course_user.user.image &#125;&#125;\"/&gt;&lt;/span&gt; &#123;% endfor %&#125; &lt;/li&gt;&lt;/ul&gt; 因为用户课程表并没有数据，则需要进行添加，为了显示详情页面中的学习用户 刷新课程详情页面，成功显示出详情页面动态数据 查看课程表中Mysql主从复制2的click_nums点击数字段，已经进行+1了 3.动态显示出课程详情页面右侧授课机构数据 授课机构数据包括教师数，所以需要在CourseOrg模型表中获取教师数数据 123def get_teacher_nums(self): #获取课程机构的教师数量 return self.teacher_set.all().count() 在模板中进行打印字段数据即可 123456789101112131415161718192021222324252627282930313233&lt;div class=\"right\"&gt; &lt;div class=\"head\"&gt; &lt;h1&gt;授课机构&lt;/h1&gt; &lt;p&gt;世界名校，课程权威&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pic\"&gt; &lt;a href=\"/company/14/\"&gt; &lt;img width=\"150\" height=\"80\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course.course_org.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;/div&gt; &lt;a href=\"/company/14/\"&gt; &lt;h2 class=\"center\" title=\"&#123;&#123; course.course_org.name &#125;&#125;\"&gt;&#123;&#123; course.course_org.name &#125;&#125;&lt;/h2&gt; &lt;/a&gt; &lt;div class=\"btn notlogin \"data-favid=\"14\" id=\"jsRightBtn\"&gt; 已收藏 &lt;/div&gt; &lt;div class=\"clear\"&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;课 &amp;nbsp;程&amp;nbsp; 数：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &#123;&#123; course.course_org.course_nums &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;教 &amp;nbsp;师&amp;nbsp; 数：&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &#123;&#123; course.course_org.get_teacher_nums &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;li&gt;所在地区：&amp;nbsp;&amp;nbsp;&#123;&#123; course.course_org.address &#125;&#125;&lt;/li&gt; &lt;li&gt;认&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;证&amp;nbsp;: &amp;nbsp;&amp;nbsp; &lt;img title=\"金牌机构\", src=\"&#123;% static 'images/gold.png' %&#125;\"/&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 刷新页面成功动态加载出授课机构数据 4.相关课程推荐功能 说明：完成该功能需要在Course课程模型类中添加tag标签字段，通过tag标签字段查找相等的课程，并且只获取一个结果，返回给模板 在course模型类中添加标签字段 1tag = models.CharField(default=\"\", verbose_name=u\"课程标签\", max_length=10) 生成对应数据表字段 在类视图中查看tag标签相同的课程数据 12345678910111213class CourseDetailView(View): \"\"\"课程详情页\"\"\" def get(self, request, course_id): course = Course.objects.get(id=int(course_id)) # 当用户点击进入课程详情页时，则课程点击数+1 course.click_nums += 1 course.save() tag = course.tag if tag: relate_courses = Course.objects.filter(tag=tag)[:1] else: relate_courses = [] return render(request, \"course-detail.html\", &#123;\"course\":course, \"relate_courses\":relate_courses&#125;) 在模板文件中找到相关课程推荐标签，进行数据打印 123456789101112131415&lt;div class=\"group_recommend\"&gt; &#123;% for relate_course in relate_courses%&#125; &lt;dl&gt; &lt;dt&gt; &lt;a target=\"_blank\" href=\"\"&gt; &lt;img width=\"240\" height=\"220\" class=\"scrollLoading\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; relate_course.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;/dt&gt; &lt;dd&gt; &lt;a target=\"_blank\" href=\"\"&gt;&lt;h2&gt; &#123;&#123; relate_course.name &#125;&#125;&lt;/h2&gt;&lt;/a&gt; &lt;span class=\"fl\"&gt;学习时长：&lt;i class=\"key\"&gt;&#123;&#123; relate_course.learn_times &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;/dd&gt; &lt;/dl&gt; &#123;% endfor %&#125;&lt;/div&gt; 为了视图中获取的tag字段的值不为空，则需要登录xadmin后台进行添加课程中的标签字段的数据，博主这里将课程mysql主从复制以及mysql主从复制2添加相同标签mysql 刷新页面，正确显示出相关课程信息 5.课程详情页面收藏功能 说明：在页面中有两个收藏功能，分别是课程收藏以及机构收藏，两个收藏功能逻辑与机构详情页面的收藏功能一致，公用AddFavView视图函数，完成同样逻辑，代码的重复性 即不需要再编写收藏功能接口函数了，只需要在course-detail详情页模板中继承父模板base中预留custom_js数据块，完成ajxa post异步请求，完成此功能，在js代码中需要分别定义课程收藏以及机构收藏，因为它们两个功能在调用add_fav函数时，传递的fav_id以及fav_type是不一样的 12345678910111213141516171819202122232425262728293031323334353637&#123;% block custom_js %&#125; &lt;script type=\"text/javascript\"&gt; //收藏分享 function add_fav(current_elem, fav_id, fav_type)&#123; $.ajax(&#123; cache: false, type: \"POST\", url:\"/org/add_fav/\", data:&#123;'fav_id':fav_id, 'fav_type':fav_type&#125;, async: true, beforeSend:function(xhr, settings)&#123; xhr.setRequestHeader(\"X-CSRFToken\", \"&#123;&#123; csrf_token &#125;&#125;\"); &#125;, success: function(data) &#123; if(data.status == 'fail')&#123; if(data.msg == '用户未登录')&#123; window.location.href=\"login.html\"; &#125;else&#123; alert(data.msg) &#125; &#125;else if(data.status == 'success')&#123; current_elem.text(data.msg) &#125; &#125;, &#125;); &#125; $('#jsLeftBtn').on('click', function()&#123; add_fav($(this), &#123;&#123; course.id &#125;&#125;, 1); &#123;#课程#&#125; &#125;); $('#jsRightBtn').on('click', function()&#123; add_fav($(this), &#123;&#123; course.course_org.id &#125;&#125;, 2); &#123;#课程机构#&#125; &#125;);&lt;/script&gt;&#123;% endblock %&#125; 在视图中跟之前机构收藏一样，需要判断UserFavorite用户收藏表中是否存在数据，设置开关，向模板中传递开关，根据开关的值，来判断页面收藏功能块内容是显示收藏还是已收藏 1234567891011# 设置默认为未收藏状态has_fav_course = Falsehas_fav_org = False# 当用户为登录状态才能根据条件查询该用户收藏数据if request.user.is_authenticated(): # 当用户已收藏课程时，即has_fav_course = True ，需注意这里的fav_type = 1 这个条件是固定的因此为课程收藏 if UserFavorite.objects.filter(user=request.user, fav_id=int(course.id), fav_type=1): has_fav_course = True # 当用户已收藏机构时，即has_fav_org = True ，需注意这里的fav_type = 2 这个条件是固定的因此为课程机构收藏 if UserFavorite.objects.filter(user=request.user, fav_id=int(course.course_org.id), fav_type=2): has_fav_org = True 测试课程详情页面课程收藏功能以及机构收藏功能 二丶公开课（开始学习）说明：当用户在课程详情页面点击开始学习即跳转到课程章节信息页面，在该页面除了显示章节信息页面（course-video），还包含评论信息页面（course-comment） 1.显示出课程章节信息页面 模板继承 定义类视图 12345class CourseInfoView(View): \"\"\"章节信息页\"\"\" def get(self, request, course_id): course = Course.objects.get(id=int(course_id)) return render(request, \"course-video.html\", &#123;\"course\": course&#125;) 定义路由 1url(r'^info/(?P&lt;course_id&gt;\\d+)/$', CourseInfoView.as_view(), name=\"course_info\"), # 课程章节信息页 测试显示课程章节信息页面 2.动态显示出课程章节信息页面数据 在xadmin后台对课程章节信息进行添加，有两种方式添加，第一种则是点击课程管理中的章节进行添加；第二种更快就是在课程中点击课程右侧的按钮，选择章节点击+进行添加，这个功能是根据外键关联由django提供进行设置的 添加课程章节 添加课程章节视频，需要在Video模型类中添加视频url地址字段 1url = models.CharField(max_length=200, default=\"\", verbose_name=u\"访问地址\") 生成对应数据表字段 添加课程章节视频 在课程章节信息中涉及到视频时长，所以老规矩需要在Video模型类中添加视频时长字段 1learn_times = models.IntegerField(default=0, verbose_name=u\"学习时长(分钟数)\") 生成对应数据表字段 在Course课程信息表中定义get_course_lesson方法获取课程所有章节信息 123def get_course_lesson(self): #获取课程所有章节 return self.lesson_set.all() 同样的在Lesson章节信息表中定义get_lesson_video方法获取课程下的章节视频信息 123def get_lesson_video(self): #获取章节视频 return self.video_set.all() 在模板文件course-video中打印章节信息 123456789101112131415161718192021222324252627282930313233343536&lt;div class=\"statics clearfix\"&gt; &lt;div class=\"static-item \"&gt; &lt;span class=\"meta-value\"&gt;&lt;strong&gt;&#123;&#123; course.get_degree_display &#125;&#125;&lt;/strong&gt;&lt;/span&gt; &lt;span class=\"meta\"&gt;难度&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt; &lt;div class=\"static-item static-time\"&gt; &lt;span class=\"meta-value\"&gt;&#123;&#123; course.learn_times &#125;&#125;分钟&lt;/span&gt; &lt;span class=\"meta\"&gt;时长&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt; &lt;div class=\"static-item\"&gt; &lt;span class=\"meta-value\"&gt;&lt;strong&gt;&#123;&#123; course.students &#125;&#125;&lt;/strong&gt;&lt;/span&gt; &lt;span class=\"meta\"&gt;学习人数&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- ************************分割线*************************** --&gt;&lt;div class=\"mod-chapters\"&gt; &#123;% for lesson in course.get_course_lesson %&#125; &lt;div class=\"chapter chapter-active\"&gt; &lt;h3&gt; &lt;strong&gt;&lt;i class=\"state-expand\"&gt;&lt;/i&gt;&#123;&#123; lesson.name &#125;&#125;&lt;/strong&gt; &lt;/h3&gt; &lt;ul class=\"video\"&gt; &#123;% for video in lesson.get_lesson_video %&#125; &lt;li&gt; &lt;a target=\"_blank\" href='&#123;&#123; video.url &#125;&#125;' class=\"J-media-item studyvideo\"&gt;&#123;&#123; video.name &#125;&#125; (&#123;&#123; video.learn_times &#125;&#125;) &lt;i class=\"study-state\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 测试成功显示对应课程的章节信息 3.页面资料下载功能 说明：在课程章节信息页面右侧栏有课程资料下载功能 首先需要在xadmin后台课程资源表中添加Mysql主从配置2的课程资源数据 添加Mysql主从复制2三个课程资源如下 在类视图中根据课程对象筛选出对应的课程资源数据，并返回给前端模板 1234567class CourseInfoView(View): \"\"\"章节信息页\"\"\" def get(self, request, course_id): course = Course.objects.get(id=int(course_id)) # 获取课程下的所有课程资源 all_resources = CourseResource.objects.filter(course=course) return render(request, \"course-video.html\", &#123;\"course\": course, \"all_resources\":all_resources&#125;) 在模板中进行打印显示 123456789101112&lt;div class=\"box mb40\"&gt; &lt;h4&gt;资料下载&lt;/h4&gt; &lt;ul class=\"downlist\"&gt; &#123;% for course_resource in all_resources %&#125; &lt;li&gt; &lt;span&gt;&lt;i class=\"aui-iconfont aui-icon-file\"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&#123;&#123; course_resource.name &#125;&#125;&lt;/span&gt; &lt;a href=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course_resource.download &#125;&#125;\" class=\"downcode\" target=\"_blank\" download=\"\" data-id=\"274\" title=\"\"&gt;下载&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/div&gt; 测试成功在课程章节信息页面显示出对应课程的资源下载数据 4.页面课程讲师提示动态数据显示 说明：在课程章节页面右侧显示课程讲师信息 在Course模型表中添加课程讲师外键字段关联Teacher模型表 1teacher = models.ForeignKey(Teacher, verbose_name=u\"讲师\", null=True, blank=True) 生成对应的数据表字段 紧接着老规矩在xadmin后台Mysql主从复制2课程中添加讲师字段信息 在讲师信息中包含课程须知和老师告诉你…的字段信息，但定义Course表并没有这两个字段，所以需要在Course模型类中添加此两个字段信息 12youneed_know = models.CharField(default=\"\", max_length=300, verbose_name=u\"课程须知\")teacher_tell = models.CharField(default=\"\", max_length=300, verbose_name=u\"老师告诉你\") 生成对应的数据表字段 在xadmin中添加添加Mysql主从复制2课程的课程须知以及老师告诉你字段数据 在course-video模板中打印讲师提示数据 12345678910111213141516171819202122&lt;div class=\"box mb40\"&gt; &lt;h4&gt;讲师提示&lt;/h4&gt; &lt;div class=\"teacher-info\"&gt; &lt;a href=\"/u/315464/courses?sort=publish\" target=\"_blank\"&gt; &lt;img src='&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course.teacher.image &#125;&#125;' width='80' height='80'/&gt; &lt;/a&gt; &lt;span class=\"tit\"&gt;&lt;a href=\"/u/315464/courses?sort=publish\" target=\"_blank\"&gt;&#123;&#123; course.teacher.name &#125;&#125;&lt;/a&gt;&lt;/span&gt; &lt;span class=\"job\"&gt;&#123;&#123; course.teacher.work_position &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"course-info-tip\"&gt; &lt;dl class=\"first\"&gt; &lt;dt&gt;课程须知&lt;/dt&gt; &lt;dd class=\"autowrap\"&gt;&#123;&#123; course.youneed_know &#125;&#125;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;老师告诉你能学到什么？&lt;/dt&gt; &lt;dd class=\"autowrap\"&gt;&#123;&#123; course.teacher_tell &#125;&#125;&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt;&lt;/div&gt; 测试成功显示出讲师提示动态数据 三丶公开课（课程评论）1.显示课程评论页面 模板继承 定义类视图，因课程评论页面与课程章节页面右侧栏数据一致，即在课程章节类视图逻辑上获取评论数据即可 12345678910class CourseCommentView(View): \"\"\"课程评论页\"\"\" def get(self, request, course_id): course = Course.objects.get(id=int(course_id)) # 获取课程下的所有课程资源 all_resources = CourseResource.objects.filter(course=course) # 获取课程所有的评论数据 all_comments = CourseComments.objects.all() return render(request, \"course-comment.html\", &#123;\"course\": course, \"all_resources\": all_resources ,\"all_comments\":all_comments&#125;) 定义路由 1url(r'^comment/(?P&lt;course_id&gt;\\d+)/$', CourseCommentView.as_view(), name=\"course_comment\"), # 课程评论页 在课程章节course-video模板中修改评论链接地址 1&lt;li&gt;&lt;a id=\"commentOn\" class=\"\" href=\"&#123;% url 'course:course_comment' course.id %&#125;\"&gt;&lt;span&gt;评论&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 点击评论，成功进入课程评论页面 2.课程评论页面动态数据显示 说明：课程章节页面与课程评论页面除了内容不一致，以下三个板块数据都是一样的，所以直接将course-video模板中对应标签块数据直接拷贝到course-comment模板中替换即可 修改模板中的章节以及评论按钮的链接地址 12345&lt;ul class=\"course-menu clearfix\"&gt; &lt;li&gt;&lt;a class=\"ui-tabs-active \" id=\"learnOn\" href=\"&#123;% url 'course:course_info' course.id %&#125;\"&gt;&lt;span&gt;章节&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a id=\"commentOn\" class=\"active\" href=\"&#123;% url 'course:course_comment' course.id %&#125;\"&gt;&lt;span&gt;评论&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 刷新页面点击评论按钮进入评论页面，成功显示出页面动态数据 3.发表评论功能实现以及显示评论信息 定义类视图 1234567891011121314151617181920class AddCommentView(View): \"\"\"发表评论\"\"\" def post(self, request): if not request.user.is_authenticated(): # 用户未登录的返回错误响应 return HttpResponse('&#123;\"status\":\"fail\", \"msg\":\"用户未登录\"&#125;', content_type='application/json') # 获取请求中的参数 course_id = request.POST.get('course_id', 0) comments = request.POST.get('comments', '') # 判断请求参数中的课程id大于0 以及评论内容不为空时，才会将数据保存至数据库表中 if int(course_id) &gt; 0 and comments: course_comments = CourseComments() course = Course.objects.get(id=int(course_id)) course_comments.course = course course_comments.comments = comments course_comments.user = request.user course_comments.save() return HttpResponse('&#123;\"status\":\"success\", \"msg\":\"评论成功\"&#125;', content_type='application/json') else: return HttpResponse('&#123;\"status\":\"fail\", \"msg\":\"评论失败\"&#125;', content_type='application/json') 定义url路由 1url(r'^add_comment/$', AddCommentView.as_view(), name=\"add_comment\"), # 发表评论功能 在course-comments模板中继承父模板base的custom_js数据块，完成发表评论功能js代码 1234567891011121314151617181920212223242526272829303132333435&#123;% block custom_js %&#125; &lt;script type=\"text/javascript\"&gt; //添加评论 $('#js-pl-submit').on('click', function () &#123; var comments = $(\"#js-pl-textarea\").val(); if (comments == \"\") &#123; alert(\"评论不能为空\"); return &#125; $.ajax(&#123; cache: false, type: \"POST\", url: \"/course/add_comment/\", data: &#123;'course_id': &#123;&#123; course.id &#125;&#125;, 'comments': comments&#125;, async: true, beforeSend: function (xhr, settings) &#123; xhr.setRequestHeader(\"X-CSRFToken\", \"&#123;&#123; csrf_token &#125;&#125;\"); &#125;, success: function (data) &#123; if (data.status == 'fail') &#123; if (data.msg == '用户未登录') &#123; window.location.href = \"login.html\"; &#125; else &#123; alert(data.msg) &#125; &#125; else if (data.status == 'success') &#123; window.location.reload();//刷新当前页面. &#125; &#125;, &#125;); &#125;); &lt;/script&gt;&#123;% endblock %&#125; Debug测试发表评论功能 查看数据表operation_coursecomments数据 显示课程评论页面信息，因之前定义评论页面时，已经向模板传递了all_comments评论讯息，即只需要在模板中进行打印显示即可 12345678910111213141516171819&lt;ul class=\"mod-post\" id=\"comment-list\"&gt; &#123;% for comment in all_comments %&#125; &lt;li class=\"post-row\"&gt; &lt;div class=\"media\"&gt; &lt;span target=\"_blank\"&gt;&lt;img src='&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; comment.user.image &#125;&#125;' width='40' height='40'/&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bd\"&gt; &lt;div class=\"tit\"&gt; &lt;span target=\"_blank\"&gt;&#123;&#123; comment.user.nick_name &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;p class=\"cnt\"&gt;&#123;&#123; comment.comments &#125;&#125;&lt;/p&gt; &lt;div class=\"footer clearfix\"&gt; &lt;span title=\"创建时间\" class=\"l timeago\"&gt;时间：&#123;&#123; comment.add_time &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 刷新评论页面，则显示出评论信息 4.完善评论页面评论信息显示 说明：正常逻辑为在该课程评论页面应该只显示出，用户对本课程的评论，而不应该显示出用户对所有课程的评论信息，并且评论信息应该按照添加时间到的倒序进行排序，也就是后进先出这个意思 即在课程评论视图中，应该对评论数据根据课程进行筛选，并按照添加时间倒序进行排序 12345678910class CourseCommentView(View): \"\"\"课程评论页\"\"\" def get(self, request, course_id): course = Course.objects.get(id=int(course_id)) # 获取课程下的所有课程资源 all_resources = CourseResource.objects.filter(course=course) # 获取课程所有的评论数据 all_comments = CourseComments.objects.filter(course=course).order_by(\"-add_time\") return render(request, \"course-comment.html\", &#123;\"course\": course, \"all_resources\": all_resources ,\"all_comments\":all_comments&#125;) 测试发表评论功能 5.补充章节页面以及评论页面右侧栏下方的该课的同学还学过的课程动态数据显示 说明：由于两个页面都是共有此模块数据，则这里就演示课程章节页面 在utils目录下创建mixin_utils.py模块，在模块中编写登录验证类，用于类视图验证操作必须登录状态才能进行的操作 123456789from django.contrib.auth.decorators import login_requiredfrom django.utils.decorators import method_decorator class LoginRequiredMixin(object): \"\"\"登录验证器\"\"\" @method_decorator(login_required(login_url='/login/')) def dispatch(self, request, *args, **kwargs): return super(LoginRequiredMixin, self).dispatch(request, *args, **kwargs) 在章节信息类视图CourseInfoView以及课程评论类视图CourseCommentView需继承于LoginRequiredMixin登录验证类，因为这两个页面上的操作都是需要用户在登录状态才能完成的 12class CourseInfoView(LoginRequiredMixin, View):class CourseCommentView(LoginRequiredMixin, View): 测试登录验证器，在xadmin后台管理中退出登录，刷新页面是否跳转到登录页 在CourseInfoView章节信息类视图中，进入章节信息则学习人数+1，获取用户和课程关联的用户课程对象，当不存在时则添加用户课程关联对象并保存到数据库中，如果存在则获取该用户学习的其他所有课程数据，返回给前端模板 12345678910111213141516171819202122232425262728class CourseInfoView(LoginRequiredMixin, View): \"\"\"章节信息页\"\"\" def get(self, request, course_id): course = Course.objects.get(id=int(course_id)) # 当用点击开始学习进入章节信息页后则学习人数 course.students += 1 course.save() # 获取用户和课程的关联对象 user_courses = UserCourse.objects.filter(user=request.user, course=course) # 当不存在时，则将用户与课程进行关联后保存到数据库中 if not user_courses: user_course = UserCourse(user=request.user, course=course) user_course.save() # 根据课程对象在UserCourse表中获取该课程下的用户信息 user_courses = UserCourse.objects.filter(course=course) # 使用列表生成式 获取用户的id user_ids = [user_course.user.id for user_course in user_courses] # 筛选此user_ids列表中的所有用户的课程数据 all_user_courses = UserCourse.objects.filter(user_id__in=user_ids) # 使用列表生成式 获取课程的id course_ids = [user_course.course.id for user_course in all_user_courses] # 获取学过该用户学习的其他所有课程 relate_courses = Course.objects.filter(id__in=course_ids).order_by(\"-click_nums\") # 获取课程下的所有课程资源 all_resources = CourseResource.objects.filter(course=course) return render(request, \"course-video.html\", &#123;\"course\": course, \"all_resources\":all_resources ,\"relate_courses\":relate_courses&#125;) 在course-video模板中进行打印该课的同学还学过的课程信息 123456789101112131415&lt;div class=\"cp-tab-pannel js-comp-tab-pannel\" data-pannel=\"course\" style=\"display: block\"&gt; &lt;!-- img 200 x 112 --&gt; &lt;ul class=\"other-list\"&gt; &#123;% for relate_course in relate_courses %&#125; &lt;li class=\"curr\"&gt; &lt;a href=\"&#123;% url 'course:course_detail' relate_course.id %&#125;\" target=\"_blank\"&gt; &lt;img src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; relate_course.image &#125;&#125;\" alt=\"django与vuejs实战项目2\"&gt; &lt;span class=\"name autowrap\"&gt;&#123;&#123; relate_course.name &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/div&gt; 测试显示该课的同学还学过的课程信息以及点击其他课程开始学习，查看该课的同学还学过的课程信息是否添加 四丶公开课（课程播放）1.上传视图到七牛云 注册或登录七牛云，上传章节课程视频到存储空间，之前的ihome-python项目中有详细的七牛云教程 需要注意的是如果上传到七牛云上的视频，播放时没有画面，那么需要将要上传的视频进行转码，转码格式为Web浏览器支持的视频格式，博主这里使用格式工厂将要上传到七牛云的视频转换成 WebM格式的视频 在七牛云内容管理列表中，点击视频右侧的操作栏，选择预览则可以检验该视频格式是否能正常播放，如下图所示 2.章节视频播放功能实现 分析视频播放页面，只有视频块为此页面独有的，页面其他部分与课程章节信息页和课程评论页一致 模板继承 定义视频播放类视图，与章节信息以及课程评论视图唯一不同的就是获取video对象，返回给前端模板页面 12345678910111213141516171819202122232425262728293031class VideoPlayView(View): \"\"\"视频播放页\"\"\" def get(self, request, video_id): video = Video.objects.get(id=int(video_id)) course = video.lesson.course # 当用点击开始学习进入章节信息页后则学习人数 course.students += 1 course.save() # 获取用户和课程的关联对象 user_courses = UserCourse.objects.filter(user=request.user, course=course) # 当不存在时，则将用户与课程进行关联后保存到数据库中 if not user_courses: user_course = UserCourse(user=request.user, course=course) user_course.save() # 根据课程对象在UserCourse表中获取该课程下的用户信息 user_courses = UserCourse.objects.filter(course=course) # 使用列表生成式 获取用户的id user_ids = [user_course.user.id for user_course in user_courses] # 筛选此user_ids列表中的所有用户的课程数据 all_user_courses = UserCourse.objects.filter(user_id__in=user_ids) # 使用列表生成式 获取课程的id course_ids = [user_course.course.id for user_course in all_user_courses] # 获取学过该用户学习的其他所有课程 relate_courses = Course.objects.filter(id__in=course_ids).order_by(\"-click_nums\") # 获取课程下的所有课程资源 all_resources = CourseResource.objects.filter(course=course) # 获取课程所有的评论数据 all_comments = CourseComments.objects.filter(course=course).order_by(\"-add_time\") return render(request, \"course-play.html\", &#123;\"course\": course, \"all_resources\": all_resources , \"all_comments\": all_comments, \"relate_courses\": relate_courses, \"video\":video&#125;) 定义url路由 1url(r'^video/(?P&lt;video_id&gt;\\d+)/$', VideoPlayView.as_view(), name=\"video_play\"), # 视频播放页 回到七牛云空间管理，复制视频的外链地址，然后在xadmin后台中向章节视频url改成七牛云视频外链地址以及修改视频时长 在course-play视频播放模板中填充模板数据 123456789101112131415161718192021222324252627282930313233&#123;% block title %&#125;&#123;&#123; video.name &#125;&#125; - 慕学在线网&#123;% endblock %&#125;&lt;!-- ------------------------分割线------------------------ --&gt;&#123;% block custom_bread %&#125; &lt;section&gt; &lt;div class=\"wp\"&gt; &lt;ul class=\"crumbs\"&gt; &lt;li&gt;&lt;a href=\"&#123;% url 'index' %&#125;\"&gt;首页&lt;/a&gt;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"&#123;% url 'course:course_list' %&#125;\"&gt;公开课程&lt;/a&gt;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"&#123;% url 'course:course_detail' course.id %&#125;\"&gt;&#123;&#123; course.name &#125;&#125;&lt;/a&gt;&gt;&lt;/li&gt; &lt;li&gt;&#123;&#123; video.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt;&#123;% endblock %&#125;&lt;!-- ------------------------分割线------------------------ --&gt;&lt;div style=\"width:1200px;height:675px; margin-left: 340px\"&gt; &lt;video id=\"example_video_1\" class=\"video-js vjs-default-skin\" controls preload=\"none\" width=\"1200\" poster=\"http://video-js.zencoder.com/oceans-clip.png\" data-setup=\"&#123;&#125;\"&gt; &lt;source src=\"&#123;&#123; video.url &#125;&#125;\" type='video/mp4'&gt; &lt;/video&gt;&lt;/div&gt;&lt;!-- ------------------------分割线------------------------ --&gt;&lt;ul class=\"video\"&gt; &#123;% for video in lesson.get_lesson_video %&#125; &lt;li&gt; &lt;a target=\"_blank\" href=\"&#123;% url 'course:video_play' video.id %&#125;\" class=\"J-media-item studyvideo\"&gt;&#123;&#123; video.name &#125;&#125; (&#123;&#123; video.learn_times &#125;&#125;) &lt;i class=\"study-state\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 在course-video章节信息模板中修改章节视频链接地址 123456789&lt;ul class=\"video\"&gt; &#123;% for video in lesson.get_lesson_video %&#125; &lt;li&gt; &lt;a target=\"_blank\" href=\"&#123;% url 'course:video_play' video.id %&#125;\" class=\"J-media-item studyvideo\"&gt;&#123;&#123; video.name &#125;&#125; (&#123;&#123; video.learn_times &#125;&#125;) &lt;i class=\"study-state\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 测试章节视频播放功能 五丶授课教师（列表页）1.显示授课教师列表页 分析教师列表页面，与其他机构和公开课列表页面一致，顶部跟底部都一样 模板继承 定义类视图，因Teacher模型类时在organization应用models中创建的，所以还是在此应用views中进行定义 1234class TeacherListView(View): \"\"\"教师列表页\"\"\" def get(self, request): return render(request, \"teachers-list.html\") 在organization/urls中定义路由 1url(r'^teacher/list/$', TeacherListView.as_view(), name=\"teacher_list\"), #课程讲师列表页 测试显示课程讲师页面 2.动态显示出课程讲师列表页数据 因课程讲师列表页讲师数据显示块包含教师年龄，所以需要在Teacher模型类中添加此字段 1age = models.IntegerField(default=18, verbose_name=u\"年龄\") 生成对应数据表字段 定义类视图，获取所有的教师信息以及教师数量并传递给前端模板 12345678class TeacherListView(View): \"\"\"教师列表页\"\"\" def get(self, request): # 获取所有的课程教师 all_teachers = Teacher.objects.all() # 获取教师个数 teacher_nums = all_teachers.count() return render(request, \"teachers-list.html\", &#123;\"all_teachers\":all_teachers, \"teacher_nums\":teacher_nums&#125;) 定义路由 1url(r'^teacher/list/$', TeacherListView.as_view(), name=\"teacher_list\"), #课程讲师列表页 在teacher-list模板文件中打印动态数据 123456789101112131415161718192021222324252627282930313233343536&lt;div class=\"fr butler-num\"&gt;共&lt;span class=\"key\"&gt;&#123;&#123; teacher_nums &#125;&#125;&lt;/span&gt;人&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&#123;% for teacher in all_teachers %&#125;&lt;dl class=\"des\"&gt; &lt;dt&gt; &lt;a href=\"/org/teacher/detail/1/\"&gt; &lt;div class=\"picpic\"&gt; &lt;img width=\"100\" height=\"100\" class=\"scrollLoading\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; teacher.image &#125;&#125;\"/&gt; &lt;/div&gt; &lt;/a&gt; &lt;div class=\"btn\"&gt; &lt;div class=\"fr btn2 bdsharebuttonbox\" data-text=\"授课教师-奥巴马-慕学在线\" data-desc=\"我在#慕课网#发现了教师“奥巴马”，对学习中的小伙伴很有帮助，一起来看看吧。\" data-comment=\"奥巴马金牌讲师，从业年限：5年\" &gt; &lt;span class=\"fl\"&gt;分享&lt;/span&gt; &lt;a href=\"#\" class=\"bds_more\" data-cmd=\"more\"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/dt&gt; &lt;dd&gt; &lt;a href=\"/org/teacher/detail/1/\"&gt; &lt;h1&gt;&#123;&#123; teacher.name &#125;&#125;&lt;span class=\"key picbig\"&gt;金牌讲师&lt;/span&gt;&lt;/h1&gt; &lt;/a&gt; &lt;ul class=\"cont\"&gt; &lt;li&gt;工作年限：&lt;span&gt;&#123;&#123; teacher.work_years &#125;&#125;年&lt;/span&gt;&lt;/li&gt; &lt;li&gt;工作职位：&lt;span&gt;&#123;&#123; teacher.work_position &#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;就职公司：&lt;span&gt;&#123;&#123; teacher.work_company &#125;&#125;&amp;nbsp;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;年龄：&lt;span&gt;&#123;&#123; teacher.age &#125;&#125;岁&lt;/span&gt;&lt;/li&gt; &lt;li&gt;教学特点：&lt;span&gt;&#123;&#123; teacher.points &#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;a class=\"buy buyservice\" href=\"/org/teacher/detail/1/\"&gt;&lt;br/&gt;查看&lt;br/&gt;详情&lt;/a&gt;&lt;/dl&gt;&#123;% endfor %&#125; 测试显示课程讲师列表页动态数据 3.讲师列表页数据分页功能实现 首先在视图中对获取的教师数据进行分页数据处理 123456789101112131415class TeacherListView(View): \"\"\"教师列表页\"\"\" def get(self, request): # 获取所有的课程教师 all_teachers = Teacher.objects.all() # 获取教师个数 teacher_nums = all_teachers.count() # 分页处理 try: page = request.GET.get('page', 1) except PageNotAnInteger: page = 1 p = Paginator(all_teachers, 5, request=request) teachers = p.page(page) return render(request, \"teachers-list.html\", &#123;\"all_teachers\":teachers, \"teacher_nums\":teacher_nums&#125;) 在teachers-list模板中，填充分页数据块，这个代码跟之前机构以及公开课一样，就不细说了 123456789101112131415161718192021&lt;div class=\"pageturn\"&gt; &lt;ul class=\"pagelist\"&gt; &#123;% if all_teachers.has_previous %&#125; &lt;li class=\"long\"&gt;&lt;a href=\"?&#123;&#123; all_teachers.previous_page_number.querystring &#125;&#125;\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% for page in all_teachers.pages %&#125; &#123;% if page %&#125; &#123;% ifequal page all_teachers.number %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"?&#123;&#123; page.querystring &#125;&#125;\"&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"?&#123;&#123; page.querystring &#125;&#125;\" class=\"page\"&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endifequal %&#125; &#123;% else %&#125; &lt;li class=\"none\"&gt;&lt;a href=\"\"&gt;...&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if all_teachers.has_next %&#125; &lt;li class=\"long\"&gt;&lt;a href=\"?&#123;&#123; all_teachers.next_page_number.querystring &#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt;&lt;/div&gt; 测试讲师列表页分页功能 4.课程讲师排序功能实现 在视图中获取sort参数，根据参数判断数据库排序条件 123456789101112131415161718192021class TeacherListView(View): \"\"\"教师列表页\"\"\" def get(self, request): # 获取所有的课程教师 all_teachers = Teacher.objects.all() # 获取教师个数 teacher_nums = all_teachers.count() sort = request.GET.get(\"sort\", \"\") # 讲师排序按照点击量 if sort: if sort == \"hot\": all_teachers = all_teachers.order_by(\"-click_nums\") # 分页处理 try: page = request.GET.get('page', 1) except PageNotAnInteger: page = 1 p = Paginator(all_teachers, 5, request=request) teachers = p.page(page) return render(request, \"teachers-list.html\", &#123;\"all_teachers\":teachers, \"teacher_nums\":teacher_nums, \"sort\":sort&#125;) 在模板中需要定义排序条件全部以及人气的url地址并判断点击激活按钮class样式 1234&lt;ul class=\"fl tab_header\"&gt; &lt;li class=\"&#123;% if not sort %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"?sort=\"&gt;全部&lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if sort == 'hot' %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"?sort=hot\"&gt;人气 &amp;#8595;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 需要说明现在的讲师点击量都为0，所以为了演示出效果博主，这里在mysql数据库中对某些教师进行点击量的修改操作 测试排序功能 5.讲师排行榜动态数据显示 说明：讲师排行榜跟页面人气排行逻辑一样，唯一区别就是只显示前3个 在视图中获取人气排行前三的讲师，并返回给模板 12# 讲师排行榜sorted_teachers = all_teachers.order_by(\"-click_nums\")[:3] 在模板中打印动态数据 1234567891011121314151617181920&lt;div class=\"right layout\"&gt; &lt;div class=\"head\"&gt;讲师排行榜&lt;/div&gt; &#123;% for sorted_teacher in sorted_teachers %&#125; &lt;dl class=\"des\"&gt; &lt;span class=\"num fl\"&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/span&gt; &lt;a href=\"/diary/hk_detail/6/\"&gt; &lt;dt&gt; &lt;img width=\"50\" height=\"50\" class=\"scrollLoading\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; sorted_teacher.image &#125;&#125;\"/&gt; &lt;/dt&gt; &lt;/a&gt; &lt;dd&gt; &lt;a href=\"/diary/hk_detail/6/\"&gt; &lt;h1 title=\"&#123;&#123; sorted_teacher.name &#125;&#125;\"&gt;&#123;&#123; sorted_teacher.name &#125;&#125;&lt;/h1&gt; &lt;/a&gt; &lt;p&gt;工作年限：&lt;span&gt;&#123;&#123; sorted_teacher.work_years &#125;&#125;年&lt;/span&gt;&lt;/p&gt; &lt;/dd&gt; &lt;/dl&gt; &#123;% endfor %&#125;&lt;/div&gt; 刷新页面，成功显示讲师排行动态数据 六丶授课教师（详情页）1.显示授课教师详情页 分析教师详情页，跟列表也一样顶部和底部是共有的 模板继承 定义类视图get方法用于显示讲师详情页，该视图需接收教师id，用于后面查询对应的教师详情信息 1234class TeacherDetailView(View): \"\"\"教师详情页\"\"\" def get(self, request, teacher_id): return render(request, \"teacher-detail.html\") 定义url路由 1url(r'^teacher/detail/(?P&lt;teacher_id&gt;\\d+)/$', TeacherDetailView.as_view(), name=\"teacher_detail\"), #课程讲师详情页 在teachers-list模板中需要修改讲师详情页的链接地址 1&lt;a href=\"&#123;% url 'org:teacher_detail' teacher.id %&#125;\"&gt; 测试显示讲师详情页 2.动态显示出讲师详情页数据 在视图中获取用户点击的讲师id和该讲师下的所有课程，获取讲师排行榜的数据，全部传递给前端模板 1234567891011class TeacherDetailView(View): \"\"\"教师详情页\"\"\" def get(self, request, teacher_id): # 获取点击的讲师信息 teacher = Teacher.objects.get(id=int(teacher_id)) # 获取该讲师下的所有课程 all_courses = Course.objects.filter(teacher=teacher) # 讲师排行榜 sorted_teachers = Teacher.objects.all().order_by(\"-click_nums\")[:3] return render(request, \"teacher-detail.html\", &#123;\"teacher\":teacher, \"all_courses\":all_courses, \"sorted_teachers\":sorted_teachers&#125;) 在模板中进行动态数据打印，数据块内容比较多，但都很简单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!-- ------------------------讲师信息模块------------------------ --&gt;&lt;dd&gt; &lt;a href=\"/diary/hk_detail/10/\"&gt; &lt;h1&gt;&#123;&#123; teacher.name &#125;&#125;&lt;span class=\"key picbig\"&gt;金牌讲师&lt;/span&gt;&lt;/h1&gt; &lt;/a&gt; &lt;ul class=\"cont\"&gt; &lt;li&gt;工作年限：&lt;span&gt;&#123;&#123; teacher.work_years &#125;&#125;年&lt;/span&gt;&lt;/li&gt; &lt;li&gt;就职公司：&lt;span&gt;&#123;&#123; teacher.work_company &#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;工作职位：&lt;span&gt;&#123;&#123; teacher.work_position &#125;&#125;&amp;nbsp;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;教学特点：&lt;span&gt;&#123;&#123; teacher.points &#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/dd&gt;&lt;!-- ------------------------全部课程模块------------------------ --&gt;&lt;div class=\"companycenter\"&gt; &lt;div class=\"group_list brief\"&gt; &#123;% for teacher_course in all_courses %&#125; &lt;div class=\"module1_5 box\"&gt; &lt;a href=\"&#123;% url 'course:course_detail' teacher_course.id %&#125;\"&gt; &lt;img width=\"214\" height=\"190\" class=\"scrollLoading\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; teacher_course.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;div class=\"des\"&gt; &lt;a href=\"&#123;% url 'course:course_detail' teacher_course.id %&#125;\"&gt;&lt;h2&gt;&#123;&#123; teacher_course.name &#125;&#125;&lt;/h2&gt;&lt;/a&gt; &lt;span class=\"fl\"&gt;时长：&lt;i class=\"key\"&gt;&#123;&#123; teacher_course.learn_times &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;span class=\"fr\"&gt;学习人数：&#123;&#123; teacher_course.students &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;span class=\"fl\"&gt;&#123;&#123; teacher_course.course_org.name &#125;&#125;&lt;/span&gt; &lt;span class=\"star fr notlogin\" data-favid=\"15\"&gt;&#123;&#123; teacher_course.fav_nums &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt;&lt;/div&gt;&lt;!-- ------------------------机构详情模块------------------------ --&gt;&lt;div class=\"butler_detail_list\"&gt; &lt;div class=\"right butler-company-box\"&gt; &lt;div class=\"head\"&gt; &lt;h1&gt;&#123;&#123; teacher.org.name &#125;&#125;&lt;/h1&gt; &lt;p&gt;知名高校，权威教学&lt;/p&gt; &lt;/div&gt; &lt;div class=\"pic\"&gt; &lt;a href=\"org-detail-homepage.html\"&gt; &lt;img width=\"150\" height=\"80\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; teacher.org.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;/div&gt; &lt;a href=\"org-detail-homepage.html\"&gt; &lt;h2 class=\"center\"&gt;&#123;&#123; teacher.org.name &#125;&#125;&lt;/h2&gt; &lt;/a&gt; &lt;p class=\"center tell\"&gt;地址：&#123;&#123; teacher.org.address &#125;&#125;&lt;/p&gt; &lt;a class=\"btn\" id=\"jsRightBtn\"&gt;收藏&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- ------------------------讲师排行榜模块------------------------ --&gt;&lt;div class=\"right layout\"&gt; &lt;div class=\"head\"&gt;讲师排行榜&lt;/div&gt; &#123;% for hot_teacher in sorted_teachers %&#125; &lt;dl class=\"des\"&gt; &lt;span class=\"num fl\"&gt;1&lt;/span&gt; &lt;a href=\"&#123;% url 'org:teacher_detail' hot_teacher.id%&#125;\"&gt; &lt;dt&gt; &lt;img width=\"50\" height=\"50\" class=\"scrollLoading\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; hot_teacher.image &#125;&#125;\"/&gt; &lt;/dt&gt; &lt;/a&gt; &lt;dd&gt; &lt;a href=\"&#123;% url 'org:teacher_detail' hot_teacher.id%&#125;\"&gt; &lt;h1 title=\"&#123;&#123; hot_teacher.name &#125;&#125;\"&gt;&#123;&#123; hot_teacher.name &#125;&#125;&lt;/h1&gt; &lt;/a&gt; &lt;p&gt;工作年限：&lt;span&gt;&#123;&#123; hot_teacher.work_years &#125;&#125;年&lt;/span&gt;&lt;/p&gt; &lt;/dd&gt; &lt;/dl&gt; &#123;% endfor %&#125;&lt;/div&gt; 需要在teachers-list模板中将所有涉及跳转到讲师详情页的地址进行修改 1&lt;a href=\"&#123;% url 'org:teacher_detail' sorted_teacher.id %&#125;\"&gt; 测试显示讲师详情页动态数据 3.讲师收藏以及机构收藏功能实现 说明：讲师详情页面的收藏功能与公开课课程详情以及机构详情中的收藏功能都是一样的逻辑，都是调用AddFavView类视图接口完成数据库表userfavorite的数据添加以及删除（添加收藏以及取消收藏）的操作 在视图中添加前面公开课课程详情视图中的用户收藏逻辑代码即可，修改其中的fav_id以及fav_type即可 123456789101112131415161718192021222324class TeacherDetailView(View): \"\"\"教师详情页\"\"\" def get(self, request, teacher_id): # 获取点击的讲师信息 teacher = Teacher.objects.get(id=int(teacher_id)) # 获取该讲师下的所有课程 all_courses = Course.objects.filter(teacher=teacher) # 设置默认为未收藏状态 has_fav_teacher = False has_fav_org = False # 当用户为登录状态才能根据条件查询该用户收藏数据 if request.user.is_authenticated(): # 当用户已收藏讲师时，即has_fav_course = True ，需注意这里的fav_type = 3 这个条件是固定的因此为讲师收藏 if UserFavorite.objects.filter(user=request.user, fav_id=int(teacher.id), fav_type=3): has_fav_teacher = True # 当用户已收藏机构时，即has_fav_org = True ，需注意这里的fav_type = 2 这个条件是固定的因此为课程机构收藏 if UserFavorite.objects.filter(user=request.user, fav_id=int(teacher.org.id), fav_type=2): has_fav_org = True # 讲师排行榜 sorted_teachers = Teacher.objects.all().order_by(\"-click_nums\")[:3] return render(request, \"teacher-detail.html\", &#123;\"teacher\":teacher, \"all_courses\":all_courses, \"sorted_teachers\":sorted_teachers, \"has_fav_teacher\":has_fav_teacher, \"has_fav_org\":has_fav_org&#125;) 在模板文件数据块custom_js中进行js代码编写，实现ajax 异步请求调用后端接口完成收藏以及取消收藏功能 1234567891011121314151617181920212223242526272829303132333435363738&#123;% block custom_js %&#125; &lt;script type=\"text/javascript\"&gt; //收藏分享 function add_fav(current_elem, fav_id, fav_type) &#123; $.ajax(&#123; cache: false, type: \"POST\", url: \"/org/add_fav/\", data: &#123;'fav_id': fav_id, 'fav_type': fav_type&#125;, async: true, beforeSend: function (xhr, settings) &#123; xhr.setRequestHeader(\"X-CSRFToken\", \"&#123;&#123; csrf_token &#125;&#125;\"); &#125;, success: function (data) &#123; if (data.status == 'fail') &#123; if (data.msg == '用户未登录') &#123; window.location.href = \"login.html\"; &#125; else &#123; alert(data.msg) &#125; &#125; else if (data.status == 'success') &#123; current_elem.text(data.msg) &#125; &#125;, &#125;); &#125; $('#jsLeftBtn').on('click', function () &#123; add_fav($(this), &#123;&#123; teacher.id &#125;&#125;, 3); &#123;#讲师#&#125; &#125;); $('#jsRightBtn').on('click', function () &#123; add_fav($(this), &#123;&#123; teacher.org.id &#125;&#125;, 2); &#123;#课程机构#&#125; &#125;); &lt;/script&gt;&#123;% endblock %&#125; 在模板中还需要判断页面收藏功能内容显示 12345&lt;span class=\"fl btn1 collectionbtn\" id=\"jsLeftBtn\"&gt; &#123;% if has_fav_teacher %&#125;已收藏&#123;% else %&#125;收藏&#123;% endif %&#125;&lt;/span&gt;&lt;!-- --------------------------------------------------------- --&gt;&lt;a class=\"btn\" id=\"jsRightBtn\"&gt;&#123;% if has_fav_org %&#125;已收藏&#123;% else %&#125;收藏&#123;% endif %&#125;&lt;/a&gt; 测试讲师详情页面中讲师以及机构收藏功能 4.处理菜单块跳转显示Bug 说明：相比认真仔细看完的同学会发现，当不管点击首页还是公开课或者是授课教师时，菜单栏一直显示激活为授课机构，这样肯定是大大的错误，如下图所示，点击授课讲师却显示授课机构为激活状态，正确应该是授课讲师 在父模板base.html中需要对这四个菜单块所在的li标签active激活状态进行判断；这里必须要说明一下，根据请求地址来精确判断当前用户点击的是哪个菜单块，request.path|slice 管道后面的slice则是精确判断请求地址为几个字符长度 1234567891011121314&lt;div class=\"wp\"&gt; &lt;ul&gt; &lt;li class=\"&#123;% if request.path == '/' %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'index' %&#125;\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if request.path|slice:'7' == '/course' %&#125;active&#123;% endif %&#125;\"&gt; &lt;a href=\"&#123;% url 'course:course_list' %&#125;\"&gt; 公开课&lt;img class=\"hot\" src=\"&#123;% static 'images/nav_hot.png' %&#125;\"&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=\"&#123;% if request.path|slice:'12' == '/org/teacher' %&#125;active&#123;% endif %&#125;\"&gt; &lt;a href=\"&#123;% url 'org:teacher_list' %&#125;\"&gt;授课教师&lt;/a&gt; &lt;/li&gt; &lt;li class=\"&#123;% if request.path|slice:'9' == '/org/list' %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'org:org_list' %&#125;\"&gt;授课机构&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 测试菜单块点击激活是否正确 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/90081752","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目于之在线教育平台网站的实战开发（三）","slug":"Django项目于之在线教育平台网站的实战开发（三）","date":"2019-11-14T04:11:29.047Z","updated":"2019-11-15T05:56:43.997Z","comments":true,"path":"2019/11/14/Django项目于之在线教育平台网站的实战开发（三）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/14/Django项目于之在线教育平台网站的实战开发（三）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶授课机构（列表页） 二丶授课机构（用户咨询） 三丶授课机构（详情页） 四丶授课机构（用户收藏） 五丶公开课（列表页）","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶授课机构（列表页） 二丶授课机构（用户咨询） 三丶授课机构（详情页） 四丶授课机构（用户收藏） 五丶公开课（列表页） 一丶授课机构（列表页）1.模板继承 在授课机构列表页（org-list.html）与其他页面除了内容块不同，其他部分都是共用的，如页面头部与底部（这个不用多说django模板继承基础知识点） 在templates模板目录下创建base.html父模板文件，然后将static目录下的org-list.html模板文件拷贝到templates目录下，并且将org-list模板内容剪切到base模板中，在base父模板文件中首先需要修改资源文件的加载方式这不用多说，然后需要对多个页面不一致的地方在父模板中进行挖坑处理（之前Django 电商项目已经详细说明过，这里简单说明下） 在org-list模板文件中只需要继承父模板，重写父模板中的授课机构独有的数据块即可 2.显示授课机构列表页面 在organization/views中定义类视图get方法，用于显示授课机构列表页 1234class OrgView(View): \"\"\"课程机构列表页\"\"\" def get(self, request): return render(request, \"org-list.html\") 在根级urls中定义路由 1url(r'^org_list/$', OrgView.as_view(), name=\"org_list\"), # 课程机构列表页 在index模板文件中修改授课机构链接地址 1&lt;li &gt;&lt;a href=\"&#123;% url 'org_list' %&#125;\"&gt;授课机构&lt;/a&gt;&lt;/li&gt; 运行项目，访问http://127.0.0.1:8000/org_list/页面则，显示授课机构列表页 3.添加页面数据 在xadmin后台管理系统中，在机构管理中添加城市信息 在xadmin后台管理系统中，在机构管理中添加授课机构信息，其中涉及到上传文件，所以需要定义保存文件路径 上传资源文件配置，首先在项目根目录下创建medio目录，然后在settings中添加目录路径 123# 资源文件配置MEDIA_URL = &apos;/media/&apos;MEDIA_ROOT = os.path.join(BASE_DIR, &apos;media&apos;) 回到xadmin后台管理系统进行添加课程机构信息 查看项目medio目录下已经成功创建生成上传的Logo图片文件，即在models中定义的image字段，在xadmin后台进行保存时，则会在settings配置的资源文件配置中指定的medio目录下创建当前的年/月的目录并将上传成功的图片文件放在该目录下（image = models.ImageField(upload_to=”org/%Y/%m”, verbose_name=u”logo”, max_length=100)） 博主这边直接添加了以下几所大学 4.增加数据表机构类别字段 之前在定义CourseOrg模型类时，未添加机构类别字段 即在CourseOrg模型类中增加此字段（该字端数据为固定数据） 1category = models.CharField(default=\"pxjg\", verbose_name=u\"机构类别\", max_length=20, choices=((\"pxjg\",\"培训机构\"),(\"gr\",\"个人\"),(\"gx\",\"高校\"))) 紧接着生成对应数据表字段 查看数据表结构 5.加载页面动态数据 在类视图get方法中获取数据表数据，并传递给模板 1234567class OrgView(View): \"\"\"课程机构列表页\"\"\" def get(self, request): all_orgs = CourseOrg.objects.all() # 课程机构 org_nums = all_orgs.count() # 机构数量 all_citys = CityDict.objects.all() # 城市 return render(request, \"org-list.html\", &#123;\"all_orgs\":all_orgs, \"org_nums\":org_nums, \"all_citys\":all_citys&#125;) 在org-list模板文件中进行打印目前数据库中获取的模板信息，具体如下，为了让大家明白模板中显示内容，博主专门进行注释 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 城市信息 --&gt;&lt;div class=\"cont\"&gt; &lt;a href=\"?ct=\"&gt;&lt;span class=\"active2\"&gt;全部&lt;/span&gt;&lt;/a&gt; &#123;% for city in all_citys %&#125; &lt;a href=\"?city=1&amp;ct=\"&gt;&lt;span class=\"\"&gt;&#123;&#123; city.name &#125;&#125;&lt;/span&gt;&lt;/a&gt; &#123;% endfor %&#125;&lt;/div&gt;&lt;!-- 机构数量 --&gt;&lt;div class=\"all\"&gt;共&lt;span class=\"key\"&gt;&#123;&#123; org_nums &#125;&#125;&lt;/span&gt;家&lt;/div&gt;&lt;!-- 机构列表 --&gt;&#123;% for org in all_orgs %&#125;&lt;dl class=\"des difdes\"&gt; &lt;dt&gt; &lt;a href=\"org-detail-homepage.html\"&gt; &lt;img width=\"200\" height=\"120\" class=\"scrollLoading\" data-url=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; org.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;/dt&gt; &lt;dd&gt; &lt;div class=\"clearfix\"&gt; &lt;a href=\"org-detail-homepage.html\"&gt; &lt;h1&gt;&#123;&#123; org.name &#125;&#125;&lt;/h1&gt; &lt;div class=\"pic fl\"&gt; &lt;img src=\"&#123;% static 'images/authentication.png' %&#125;\"/&gt; &lt;img src=\"&#123;% static 'images/gold.png' %&#125;\"/&gt; &lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;ul class=\"cont\"&gt; &lt;li class=\"first\"&gt;&lt;p class=\"pic9\"&gt;课程数：&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;&lt;p class=\"c7\"&gt;学习人数：&lt;span&gt;1000&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; &lt;li class=\"c8\" style=\"padding-left:18px;\"&gt;&#123;&#123; org.address &#125;&#125;&lt;/li&gt; &lt;li class=\"pic10\" style=\"padding-left:18px;\"&gt;经典课程： &lt;a href=\"/diary/19/\"&gt;c语言基础入门&lt;/a&gt; &lt;a href=\"/diary/16/\"&gt;数据库基础&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;div class=\"buy start_groupbuy jsShowPerfect2\" data-id=\"22\"&gt;&lt;br/&gt;联系&lt;br/&gt;服务&lt;/div&gt;&lt;/dl&gt;&#123;% endfor %&#125; 刷新页面成功显示模板中打印的动态数据 6.实现页面分页功能 安装第三方分页库django-pure-pagination，这个库在是Django本身的Paginator上进行封装的，而之前博主写的Django电商项目中则使用的是Django本身提供的Paginator进行分页的 添加到settings apps应用中 1234INSTALLED_APPS = ( ... &apos;pure_pagination&apos;,) 在视图中进行分页数据处理，之后将分页处理后的数据对象赋值给all_orgs变量，传递给模板 1234567891011121314class OrgView(View): \"\"\"课程机构列表页\"\"\" def get(self, request): all_orgs = CourseOrg.objects.all() # 课程机构 org_nums = all_orgs.count() # 机构数量 all_citys = CityDict.objects.all() # 城市 # 分页处理 try: page = request.GET.get('page', 1) except PageNotAnInteger: page = 1 p = Paginator(all_orgs, 5, request=request) orgs = p.page(page) return render(request, \"org-list.html\", &#123;\"all_orgs\":orgs, \"org_nums\":org_nums, \"all_citys\":all_citys&#125;) 在模板文件中，需要修改机构列表数据遍历对象，因为视图传递过来的all_orgs变量的值为分页数据对象，需要调用object_list方法，获取数据 1&#123;% for org in all_orgs.object_list %&#125; 在模板中打印显示分页信息，看不懂的话可根据django-pure-pagination上的文档进行参考 123456789101112131415161718192021&lt;div class=\"pageturn\"&gt; &lt;ul class=\"pagelist\"&gt; &#123;% if all_orgs.has_previous %&#125; &lt;li class=\"long\"&gt;&lt;a href=\"?&#123;&#123; all_orgs.previous_page_number.querystring &#125;&#125;\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% for page in all_orgs.pages %&#125; &#123;% if page %&#125; &#123;% ifequal page all_orgs.number %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"?&#123;&#123; page.querystring &#125;&#125;\"&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"?&#123;&#123; page.querystring &#125;&#125;\" class=\"page\"&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endifequal %&#125; &#123;% else %&#125; &lt;li class=\"none\"&gt;&lt;a href=\"\"&gt;...&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if all_orgs.has_next %&#125; &lt;li class=\"long\"&gt;&lt;a href=\"?&#123;&#123; all_orgs.next_page_number.querystring &#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt;&lt;/div&gt; 测试授课机构列表页数据分页显示功能 7.页面数据筛选功能 首选为了方便演示测试，博主这里打算添加各种机构类别的学校数据 在视图中进行地区以及机构内别进行条件筛选逻辑处理，逻辑很简单都是通过获取全部的课程all_orgs，在通过获取的所有授课分别根据城市以及机构条件进行数据筛选操作，最后需要将获取到的请求地址参数传递到模板文件中 12345678910111213141516171819202122232425262728class OrgView(View): \"\"\"课程机构列表页\"\"\" def get(self, request): all_orgs = CourseOrg.objects.all() # 课程机构 all_citys = CityDict.objects.all() # 城市 # 从请求地址中获取city_id city_id = request.GET.get(\"city\", \"\") # 城市筛选 if city_id: all_orgs = all_orgs.filter(city_id=int(city_id)) # 需要注意的是models中并没有定义city_id字段，但数据库显示为此字段 # 机构类别筛选 category = request.GET.get(\"ct\", \"\") if category: # 将过滤查询后的结果赋值给all_orgs变量，在分页处理逻辑中根据此变量的数据进行分页处理，如果category的值不存在，就按照CourseOrg数据表的所有数据进行分页处理，此说明针对逻辑理解力差的朋友 all_orgs = all_orgs.filter(category=category) org_nums = all_orgs.count() # 机构数量 # 分页处理 try: page = request.GET.get('page', 1) except PageNotAnInteger: page = 1 p = Paginator(all_orgs, 5, request=request) orgs = p.page(page) return render(request, \"org-list.html\", &#123;\"all_orgs\":orgs, \"org_nums\":org_nums, \"all_citys\":all_citys , \"city_id\":city_id, \"category\":category&#125;) 在模板文件中首先根据后端传递过来的参数是否存在来判断筛选条件中按钮是否为激活状态，请求地址都为?xxxx，表示当前地址上添加筛选条件参数，即调用同一视图OrgView 12345678910111213141516171819&lt;li&gt; &lt;h2&gt;机构类别&lt;/h2&gt; &lt;div class=\"cont\"&gt; &lt;a href=\"?city=\"&gt;&lt;span class=\"&#123;% if not category %&#125;active2&#123;% endif %&#125;\"&gt;全部&lt;/span&gt;&lt;/a&gt; &lt;a href=\"?ct=pxjg\"&gt;&lt;span class=\"&#123;% if category == 'pxjg' %&#125;active2&#123;% endif %&#125;\"&gt;培训机构&lt;/span&gt;&lt;/a&gt; &lt;a href=\"?ct=gx\"&gt;&lt;span class=\"&#123;% if category == 'gx' %&#125;active2&#123;% endif %&#125;\"&gt;高校&lt;/span&gt;&lt;/a&gt; &lt;a href=\"?ct=gr\"&gt;&lt;span class=\"&#123;% if category == 'gr' %&#125;active2&#123;% endif %&#125;\"&gt;个人&lt;/span&gt;&lt;/a&gt; &lt;/div&gt;&lt;/li&gt;&lt;li&gt; &lt;h2&gt;所在地区&lt;/h2&gt; &lt;div class=\"more\"&gt;更多&lt;/div&gt; &lt;div class=\"cont\"&gt; &lt;a href=\"?city=\"&gt;&lt;span class=\"&#123;% if not city_id %&#125;active2&#123;% endif %&#125;\"&gt;全部&lt;/span&gt;&lt;/a&gt; &#123;% for city in all_citys %&#125; &lt;a href=\"?city=&#123;&#123; city.id &#125;&#125;\"&gt;&lt;span class=\"&#123;% if city.id|stringformat:\"i\" == city_id %&#125;active2&#123;% endif %&#125;\"&gt;&#123;&#123; city.name &#125;&#125;&lt;/span&gt;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt;&lt;/li&gt; 测试授课机构列表页条件筛选功能 问题：当筛选条件为城市时，再点击机构类别时，则城市筛选条件会清空，反之当筛选条件为机构类别时，再点击城市，则机构类别变为全部；导致这种情况的原因是筛选条件的链接地址，不管点击机构类别还是城市时，都只会按照各自定义的链接进行跳转，即刷新页面，而导致重置之前选中的筛选条件 解决方法：修改模板中筛选条件的url地址，这里稍微比较绕，给机构类别筛选条件url地址添加城市筛选条件地址，也就是city=city_id，反之城市筛选条件url地址也添加机构类别的筛选条件地址，这样做的逻辑为当点击机构类别筛选条件时附带city的参数，在此条件下再选择城市条件时，则会给当前地址city参数赋值，反之道理也一样，例如：http://127.0.0.1:8000/org_list/?city=2&amp;ct=pxjg 12345678910111213141516171819&lt;li&gt; &lt;h2&gt;机构类别&lt;/h2&gt; &lt;div class=\"cont\"&gt; &lt;a href=\"?city=&#123;&#123; city_id &#125;&#125;\"&gt;&lt;span class=\"&#123;% if not category %&#125;active2&#123;% endif %&#125;\"&gt;全部&lt;/span&gt;&lt;/a&gt; &lt;a href=\"?ct=pxjg&amp;city=&#123;&#123; city_id &#125;&#125;\"&gt;&lt;span class=\"&#123;% if category == 'pxjg' %&#125;active2&#123;% endif %&#125;\"&gt;培训机构&lt;/span&gt;&lt;/a&gt; &lt;a href=\"?ct=gx&amp;city=&#123;&#123; city_id &#125;&#125;\"&gt;&lt;span class=\"&#123;% if category == 'gx' %&#125;active2&#123;% endif %&#125;\"&gt;高校&lt;/span&gt;&lt;/a&gt; &lt;a href=\"?ct=gr&amp;city=&#123;&#123; city_id &#125;&#125;\"&gt;&lt;span class=\"&#123;% if category == 'gr' %&#125;active2&#123;% endif %&#125;\"&gt;个人&lt;/span&gt;&lt;/a&gt; &lt;/div&gt;&lt;/li&gt;&lt;li&gt; &lt;h2&gt;所在地区&lt;/h2&gt; &lt;div class=\"more\"&gt;更多&lt;/div&gt; &lt;div class=\"cont\"&gt; &lt;a href=\"?ct=&#123;&#123; category &#125;&#125;\"&gt;&lt;span class=\"&#123;% if not city_id %&#125;active2&#123;% endif %&#125;\"&gt;全部&lt;/span&gt;&lt;/a&gt; &#123;% for city in all_citys %&#125; &lt;a href=\"?city=&#123;&#123; city.id &#125;&#125;&amp;ct=&#123;&#123; category &#125;&#125;\"&gt;&lt;span class=\"&#123;% if city.id|stringformat:\"i\" == city_id %&#125;active2&#123;% endif %&#125;\"&gt;&#123;&#123; city.name &#125;&#125;&lt;/span&gt;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt;&lt;/li&gt; 再次测试授课机构列表页条件筛选功能（注意浏览器地址变化） 8.授课机构排名 在类视图get方法中通过模型表点击量字段进行倒序排序并且只取前三个授课机构信息 12# 授课机构排名hot_orgs = all_orgs.order_by(\"-click_nums\")[:3] 在模板中找到授课机构排名，进行数据打印显示 123456789101112&lt;div class=\"right companyrank layout\"&gt; &lt;div class=\"head\"&gt;授课机构排名&lt;/div&gt; &#123;% for hot_org in hot_orgs %&#125; &lt;dl class=\"des\"&gt; &lt;dt class=\"num fl\"&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/dt&gt; &lt;dd&gt; &lt;a href=\"/company/2/\"&gt;&lt;h1&gt;&#123;&#123; hot_org.name &#125;&#125;&lt;/h1&gt;&lt;/a&gt; &lt;p&gt;&#123;&#123; hot_org.address &#125;&#125;&lt;/p&gt; &lt;/dd&gt; &lt;/dl&gt; &#123;% endfor %&#125;&lt;/div&gt; 测试显示授课机构排名 9.授课机构排序 分析：从授课机构列表中可以看到排序按照学习人数和课程数这两个条件进行排序的 因为当初定义数据模型类时，未定义这两个字段，所以需要在models进行添加 12students = models.IntegerField(default=0, verbose_name=u\"学习人数\")course_nums = models.IntegerField(default=0, verbose_name=u\"课程数\") 生成对应数据表字段 在视图中获取数据库中授课机构所有信息，并对获取的信息按照学习人数和课程数进行排序（逻辑与筛选功能一致） 1234567# 授课机构排序sort = request.GET.get(\"sort\", \"\")if sort: if sort == \"students\": all_orgs = all_orgs.order_by(\"-students\") elif sort == \"courses\": all_orgs = all_orgs.order_by(\"-course_nums\") 回到模板文件中进行判断显示激活active样式，以及定义排序条件url链接地址，添加筛选条件参数（逻辑与筛选功能一致，不再重述） 1234567&lt;div class=\"head\"&gt; &lt;ul class=\"tab_header\"&gt; &lt;li class=\"&#123;% if not sort %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"?ct=&#123;&#123; category &#125;&#125;&amp;city=&#123;&#123; city_id &#125;&#125;\"&gt;全部&lt;/a&gt; &lt;/li&gt; &lt;li class=\"&#123;% if sort == 'students' %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"?sort=students&amp;ct=&#123;&#123; category &#125;&#125;&amp;city=&#123;&#123; city_id &#125;&#125;\"&gt;学习人数 &amp;#8595;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if sort == 'courses' %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"?sort=courses&amp;ct=&#123;&#123; category &#125;&#125;&amp;city=&#123;&#123; city_id &#125;&#125;\"&gt;课程数 &amp;#8595;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 测试授课机构排序功能（注意浏览器地址变化） 二丶授课机构（用户咨询）1.使用modelform对表单进行验证和保存来完成咨询功能 在授课机构列表页中如下图所示有个立即咨询功能 立即咨询功能说白了就是表单数据的提交，设计到表单验证操作，按照之前users应用中表单的操作，定义表单类继承与forms.Form来完成表单的验证，但是这样定义表单的验证缺点比较多，例如：与模型类中的代码重复性高，并且此方式并不能保存表单的数据，所以在实现咨询功能时，定义的表单类不继承与forms.Form而是继承于forms.ModelForm，只需要在定义Meta类中指定要验证的模型类以及模型类中的字段，即可完整表单的验证及保存，在organization目录下创建forms.py模块，咋forms中定义表单验证类 12345678910111213\"\"\"class UserAskFrom(forms.Form): name = forms.CharField(required=True, min_length=2, max_length=10) # 姓名 mobile = forms.CharField(required=True, min_length=11, max_length=11) # 手机 course_name = forms.CharField(required=True) # 课程名\"\"\" class UserAskForm(forms.ModelForm): \"\"\"用户咨询\"\"\" class Meta: model = UserAsk fields = [\"name\", \"mobile\", \"course_name\"] # 只保留想要的模型中的字段 在所有的应用目录下创建urls.py文件，用于完成页面中功能的路由，需要说明的是在本项目创建的app应用中没有生产urls.py文件，而在之前的Django项目中使用命令创建的应用时包含此文件的，然后在organization/urls中进行编写咨询功能路由 123urlpatterns = [ url(r'^list/$', OrgView.as_view(), name=\"org_list\"), # 课程机构列表页] 紧接着在根级的urls中需要定义将应用organization下的urls包含进来，这样就很之前Django电商项目配置一样了 1url(r'org/', include('organization.urls', namespace=\"org\")), # 应用organization下的urls 此时授课机构列表页的链接地址就不再是http://127.0.0.1:8000/org_list/ 而是http://127.0.0.1:8000/org/list/ 了，并且在index模板中需要修改授课机构列表页面的链接地址，也就是之前Django 电商项目说的反向解析 1&lt;li &gt;&lt;a href=\"&#123;% url 'org:org_list' %&#125;\"&gt;授课机构&lt;/a&gt;&lt;/li&gt; 测试访问http://127.0.0.1:8000/org/list/ 授课机构列页面 2.再次说明：此做法与之前的Django项目一样，在根级urls中匹配地址后，将所有应用下的的urls路由包含进去，例如本项目中的captcha验证码一样url(r’captcha/‘,include(‘captcha.urls’))，理解此路由就是只要匹配captcha规则的请求，通通的进入到captcha.urls中进行匹配调用，如下图流程 分析授课机构列表页中的我要学习咨询功能，当用户点击立即咨询按钮时则应该页面不进行任何跳转，并且是异步执行的过程，所以这里在前端模板中使用ajax方式进行异步请求 在organization/views中定义用户咨询类视图，返回响应的浏览器协议格式的数据 123456789class AddUserAskView(View): \"\"\"添加用户咨询\"\"\" def post(self, request): userask_form = UserAskForm(request.POST) if userask_form.is_valid(): user_ask = userask_form.save(commit=True) # 设置自动保存数据到数据库，就不用像之前的表单验证模型那样 return HttpResponse('&#123;\"status\":\"success\"&#125;', content_type='application/json') else: return HttpResponse('&#123;\"status\":\"fail\", \"msg\":\"咨询失败\"&#125;', content_type='application/json') 在父模板文件中需要在底部进行挖坑（block custom_js），并在子模板org-list中填充js数据，并进行如下编写（博主全方面注释） 12345678910111213141516171819202122232425262728&#123;% block custom_js %&#125;&lt;script&gt;$(function () &#123; $('#jsStayBtn').click(function () &#123; &#123;#alert(222);#&#125; $.ajax(&#123; cache: false, &#123;#禁用缓存#&#125; type: \"POST\", &#123;#请求方式#&#125; url: \"&#123;% url 'org:add_ask' %&#125;\", &#123;#请求地址#&#125; data: $('#jsStayForm').serialize(), &#123;#序列化表单内容#&#125; async: true, &#123;#异步请求方式#&#125; success: function (data) &#123; &#123;#发送请求成功回调函数，接收后端响应数据data#&#125; &#123;#alert(1111);#&#125; if (data.status == 'success') &#123; &#123;# 重置表单#&#125; $('#jsStayForm')[0].reset(); alert(\"提交成功\") &#125; else if (data.status == 'fail') &#123; &#123;#alert(111);#&#125; &#123;# 将错误信息条件到id=jsCompanyTips的标签内容中 #&#125; $('#jsCompanyTips').html(data.msg) &#125; &#125; &#125;); &#125;); &#125;)&lt;/script&gt;&#123;% endblock %&#125; Debug测试咨询功能（空表单进行提交） 当Debug测试完毕后，查看页面提示信息，以及后端响应前端页面数据 Debug测试咨询功能（填写完整数据进行提交） Debug断点完成后，页面打印出提交成功，点击确定后，查看后端返回的响应数据为success 查看数据operation_userask表信息，成功通过ajax异步提交的表单数据保存到响应的数据表中 完善咨询功能，判断用户输入的手机号码是否合法，在forms表单验证类中直接forms.ModelFrom提供的clean方法，后面跟字段明，必须是该写法， 在clean_mobile方法中使用正则匹配进行判断，并返回正确结果或者错误提示 123456789101112131415class UserAskForm(forms.ModelForm): \"\"\"用户咨询\"\"\" class Meta: model = UserAsk fields = [\"name\", \"mobile\", \"course_name\"] # 只保留想要的模型中的字段 def clean_mobile(self): \"\"\"验证手机号码是否合法\"\"\" mobile = self.cleaned_data['mobile'] REGEX_MOBILE = \"^1[358]\\d&#123;9&#125;$|^147\\d&#123;8&#125;$|^176\\d&#123;8&#125;$|^177\\d&#123;8&#125;$|^199\\d&#123;8&#125;$\" p = re.compile(REGEX_MOBILE) if p.match(mobile): return mobile else: raise forms.ValidationError(u\"手机号码非法\", code=\"mobile_invalid\") Debug测试（输入不合法的手机号） 三丶授课机构（详情页）1.机构详情页面展示 说明：当用户在授课机构列表页中点击机构即进入机构详情页面 说明：在以上页面中需要讲师以及课程的数据，所以需要在xadmin后台进行数据添加 在xadmin后台机构管理中添加教师模型表数据 在xadmin后台课程管理中添加课程模型表数据，但是发现该课程表未与课程机构表关联，无法选择课程机构 即所以在课程管理course/models中在课程表模型类中定义外键，并且允许为空，因为在搭建后台管理系统的时候已经存在一条数据了 1course_org = models.ForeignKey(CourseOrg, verbose_name=u\"课程机构\", null=True, blank=True) 生成对应数据表字段 刷新xadmin后台增加课程页面，则可以选择对应课程的课程机构了 将机构详情页面所需要的模板文件拷贝到templates模板目录下，总共有4个模板（org-detail-course，org-detail-desc，org-detail-homepage，org-detail-teachers）分析页面得知，这四个页面除了各自内容不同其他均一样，所以需要将共有的部分单独放到一个模板中，即利用模板继承 在template是目录下新建org_base.html模板，将org-detail-homepage.html或者其他三个模板的数据拷贝到org_base模板中，然后在org_base模板中进行如下数据块挖坑，通俗来说将是将四个页面不同的地方进行挖坑 在模板org-detail-homepage中继承与父模板org_base，并进行独有数据块填充 在organization/views中定义类视图post方法，用于获取机构详情首页中页面数据 123456789101112class OrgHomeView(View): \"\"\"机构首页\"\"\" def get(self, request, org_id): course_org = CourseOrg.objects.get(id=int(org_id)) # 获取课程机构信息 # 根据Course表的外键关联CourseOrg表通过django提供的course_set方法来获取Course表的课程所有信息 # 并不是所有课程，而是一个课程的所有信息 all_courses = course_org.course_set.all()[:3] # 同理根据Teachers表的外键关联CourseOrg表通过teacher_set方法获取Teachers表的教师所有信息 # 并不是所有教师，而是一个教师的所有信息 all_teachers = course_org.teacher_set.all()[:1] return render(request, \"org-detail-homepage.html\", &#123;\"all_courses\":all_courses, \"all_teachers\":all_teachers ,\"course_org\":course_org&#125;) 在urls中定义机构详情首页路由 1url(r'^home/(?P&lt;org_id&gt;\\d+)$', OrgHomeView.as_view(), name=\"org_home\"), # 机构首页 在org-detail-homepage模板中打印显示页面数据 1234567891011121314151617&lt;div class=\"brief group_list\"&gt;&#123;% for course in all_courses %&#125;&lt;div class=\"module1_5 box\"&gt; &lt;a href=\"course-detail.html\"&gt;&lt;img width=\"214\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course.image &#125;&#125;\"/&gt;&lt;/a&gt; &lt;div class=\"des\"&gt; &lt;a href=\"course-detail.html\"&gt;&lt;h2&gt;&#123;&#123; course.name &#125;&#125;&lt;/h2&gt;&lt;/a&gt; &lt;span class=\"fl\"&gt;课时：&lt;i class=\"key\"&gt;&#123;&#123; course.learn_times &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;span class=\"fr\"&gt;参加人数：&#123;&#123; course.students &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;span class=\"fl\"&gt;&#123;&#123; course.course_org.name &#125;&#125;&lt;/span&gt; &lt;span class=\"star fr notlogin \" data-favid=\"13\" data-fav-type=\"4\"&gt; &#123;&#123; course.fav_nums &#125;&#125; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 在父模板org_base中打印显示出机构名称以及机构logo图片 12345678910111213141516171819&lt;div class=\"wp\"&gt; &lt;img class=\"fl\" style=\"width: 112px;height: 103px\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course_org.image &#125;&#125;\"/&gt; &lt;div class=\"head fl\"&gt; &lt;h1&gt; &#123;&#123; course_org.name &#125;&#125; &lt;img src=\"&#123;% static 'images/authentication.png' %&#125;\"/&gt; &lt;img src=\"&#123;% static 'images/gold.png' %&#125;\"/&gt; &lt;/h1&gt; &lt;p class=\"fl\"&gt; &lt;span class=\"fl\" style=\"margin-top:8px;color:#848484;\"&gt;推荐指数： &lt;/span&gt; &lt;span class=\"precision company-credit\" data-star-scope=\"5.0\"&gt;&lt;/span&gt; &lt;span class=\"key\"&gt;5.0&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=\"btn fr collectionbtn notlogin \" data-favid=\"22\" data-fav-type=\"1\"&gt; 收藏 &lt;/div&gt;&lt;/div&gt; 测试机构详情首页数据显示 在机构详情首页中需要对机构教师进行打印显示，则需要在xadmin管理后台上传头像，在前面添加讲师时，并没有图片字段，所以老规矩在models中定义Teacher模型的image字段，并生成数据表，最后在xadmin后台中添加教师头像即可 1image = models.ImageField(default='', upload_to=\"teacher/%Y/%m\", verbose_name=u\"头像\", max_length=100) 在org-detail-homepage模板中打印显示机构教师以及机构介绍 12345678910111213141516171819202122&#123;% for teacher in all_teachers %&#125; &lt;div class=\"diarys\"&gt; &lt;div class=\"module5 share company-diary-box\" style=\"padding:10px 0;\"&gt; &lt;div class=\"left\"&gt; &lt;img class=\"pic\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; teacher.image &#125;&#125;\"/&gt; &lt;p&gt;昵称：&#123;&#123; teacher.name &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;div class=\"top\"&gt; &lt;div class=\"fl\"&gt; &lt;a href=\"\"&gt;&lt;h1&gt;Java开发教程&lt;/h1&gt;&lt;/a&gt; &lt;span&gt;发表于：2017-11-12&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"middle\" style=\"border-bottom:0; \"&gt;课程介绍 &lt;p style=\"font-size: 16px\"&gt;1.java基础 2.java进阶 3.java高级&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endfor %&#125;&lt;div class=\"cont\"&gt;&amp;nbsp; &amp;nbsp;&#123;&#123; course_org.desc &#125;&#125;&lt;a href=\"/company/desc/22/\"&gt;&lt;span class=\"green\"&gt;[查看更多]&lt;/span&gt;&lt;/a&gt;&lt;/div&gt; 刷新页面成功显示出机构教师以及机构介绍数据 2.机构课程列表页数据显示 整个逻辑跟机构首页一样，首先就是完成模板的继承，这个就不在细说了，然后定义类视图get方法，获取课程表数据并传递给前端模板，在页面左侧栏，需要通过后端传递current_page变量的值来判断是否激活，并且修改父模板中的左侧栏的链接地址 12345678910class OrgCourseView(View): \"\"\"机构课程页\"\"\" def get(self, request, org_id): current_page = \"course\" course_org = CourseOrg.objects.get(id=int(org_id)) # 获取课程机构信息 # 根据Course表的外键关联CourseOrg表通过django提供的course_set方法来获取Course表的课程所有信息 # 并不是所有课程，而是一个课程的所有信息 all_courses = course_org.course_set.all() return render(request, \"org-detail-course.html\", &#123;\"all_courses\":all_courses,\"course_org\":course_org ,\"current_page\":current_page&#125;) 定义url路由 1url(r'^course/(?P&lt;org_id&gt;\\d+)$', OrgCourseView.as_view(), name=\"org_course\"), # 机构课程页 在机构课程列表页模板org-detail-course中打印显示页面数据 12345678910111213141516171819202122&lt;div class=\"brief group_list\"&gt; &#123;% for course in all_courses %&#125; &lt;div class=\"module1_5 box\"&gt; &lt;a class=\"comp-img-box\" href=\"course-detail.html\"&gt; &lt;img width=\"214\" height=\"195\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;div class=\"des\"&gt; &lt;a href=\"course-detail.html\"&gt;&lt;h2&gt;&#123;&#123; course.name &#125;&#125;&lt;/h2&gt;&lt;/a&gt; &lt;span class=\"fl\"&gt;课时：&lt;i class=\"key\"&gt;&#123;&#123; course.learn_times &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;span class=\"fr\"&gt;学习人数：&#123;&#123; course.students &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;span class=\"fl\"&gt;&#123;&#123; course.course_org.name &#125;&#125;&lt;/span&gt; &lt;span class=\"star fr notlogin \" data-favid=\"13\" data-fav-type=\"4\"&gt; &#123;&#123; course.fav_nums &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 在父模板org_base中修改详情页左侧栏菜单链接地址 12345678&lt;div class=\"left\"&gt; &lt;ul&gt; &lt;li class=\"&#123;% if current_page == 'home' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'org:org_home' course_org.id %&#125;\"&gt;机构首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if current_page == 'course' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'org:org_course' course_org.id %&#125;\"&gt;机构课程&lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if current_page == 'desc' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"org-detail-desc.html\"&gt;机构介绍&lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if current_page == 'teacher' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"org-detail-teachers.html\"&gt;机构讲师&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 测试左侧菜单激活并跳转到正确页面以及显示课程机构列表页数据 3.机构介绍页面以及机构讲师页面数据显示 说明：这两个页面都很简单逻辑与前面两个机构首页机构课程一样，就不细说了 定义类视图 12345678910111213141516171819class OrgDescView(View): \"\"\"机构介绍页\"\"\" def get(self, request, org_id): current_page = \"desc\" course_org = CourseOrg.objects.get(id=int(org_id)) # 获取课程机构信息 return render(request, \"org-detail-desc.html\", &#123;\"course_org\":course_org ,\"current_page\":current_page&#125;) class OrgTeacherView(View): \"\"\"教师列表页\"\"\" def get(self, request, org_id): current_page = \"teacher\" course_org = CourseOrg.objects.get(id=int(org_id)) # 获取课程机构信息 # 根据Course表的外键关联CourseOrg表通过django提供的course_set方法来获取Course表的课程所有信息 # 并不是所有课程，而是一个课程的所有信息 all_teachers = course_org.teacher_set.all() return render(request, \"org-detail-teachers.html\", &#123;\"all_teachers\":all_teachers,\"course_org\":course_org ,\"current_page\":current_page&#125;) 定义路由 12url(r'^desc/(?P&lt;org_id&gt;\\d+)$', OrgDescView.as_view(), name=\"org_desc\"), # 机构介绍页url(r'^teacher/(?P&lt;org_id&gt;\\d+)$', OrgTeacherView.as_view(), name=\"org_teacher\"), # 教师列表页 对应的模板文件继承于org_base模板，只需要重写right_form数据库块内容即可，前面两个模板中并没有去重写bread_title数据块，博主在写完后面两个模板就已经给补充了，这里演示org-detail-teacher模板即可 1234567891011121314151617181920212223242526272829303132333435&#123;% extends 'org_base.html' %&#125;&#123;% load staticfiles %&#125;&#123;% block title %&#125;慕课网教师列表 - 慕学网&#123;% endblock %&#125;&#123;% block bread_title %&#125;机构讲师&#123;% endblock %&#125;&#123;% block right_form %&#125; &lt;div class=\"right companycenter layout\" &gt; &lt;div class=\"head\"&gt; &lt;h1&gt;机构讲师&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"messagelist\"&gt; &lt;div class=\" butler_list butler-fav-box\"&gt; &#123;% for teacher in all_teachers %&#125; &lt;dl class=\"des users\"&gt; &lt;dt&gt; &lt;a href=\"\"&gt; &lt;img width=\"100\" height=\"100\" class=\"scrollLoading\" src=\"&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; teacher.image &#125;&#125;\"/&gt; &lt;/a&gt; &lt;/dt&gt; &lt;dd&gt; &lt;h1&gt; &lt;a href=\"\"&gt; &#123;&#123; teacher.name &#125;&#125;&lt;span class=\"key\"&gt;已认证&lt;/span&gt; &lt;/a&gt; &lt;/h1&gt; &lt;ul class=\"cont clearfix\"&gt; &lt;li class=\"time\"&gt;工作年限：&lt;span&gt;&#123;&#123; teacher.work_years &#125;&#125;年&lt;/span&gt;&lt;/li&gt; &lt;li class=\"c7\"&gt;课程数：&lt;span&gt;3&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;/dl&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 在父模板org_base中完善详情页左侧栏菜单链接地址 123456&lt;ul&gt; &lt;li class=\"&#123;% if current_page == 'home' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'org:org_home' course_org.id %&#125;\"&gt;机构首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if current_page == 'course' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'org:org_course' course_org.id %&#125;\"&gt;机构课程&lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if current_page == 'desc' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'org:org_desc' course_org.id %&#125;\"&gt;机构介绍&lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if current_page == 'teacher' %&#125;active2&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;% url 'org:org_teacher' course_org.id %&#125;\"&gt;机构讲师&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 测试机构详情页四个页面数据 四丶授课机构（用户收藏）1.课程机构收藏功能实现 分析：该功能跟咨询功能一样使用ajax异步向后端接口发送请求的，当收藏功能显示收藏字段时，用户点击收藏，则该功能按钮显示已收藏，反之表示取消收藏，则该功能内容显示为收藏；在后端逻辑中如果在数据库中根据用户id和fav_id以及fav_type能查询到数据，则表示用户是想取消收藏，反之查询不到则表示用户想收藏 定义收藏及取消功能视图 1234567891011121314151617181920212223242526272829class AddFavView(View): \"\"\"用户收藏以及取消收藏课程机构\"\"\" def post(self, request): # 获取请求中的参数 fav_id = request.POST.get('fav_id', 0) fav_type = request.POST.get('fav_type', 0) # 跟在index模板中判断用户登录使用django提供的is_authenticated方法进行判断 if not request.user.is_authenticated(): # 用户未登录的返回错误响应 return HttpResponse('&#123;\"status\":\"fail\", \"msg\":\"用户未登录\"&#125;', content_type='application/json') # 用户存在则在UserFavorite表中根据当前用户对象和fav_id以及fav_type字段查询该条记录 exist_records = UserFavorite.objects.filter(user=request.user, fav_id=int(fav_id), fav_type=int(fav_type)) if exist_records: # 如果记录存在，表示用户是想取消收藏，则删除此记录 exist_records.delete() # 返回正确状态，以及收藏消息，该‘收藏’用于显示收藏按钮标签中的内容 return HttpResponse('&#123;\"status\":\"success\", \"msg\":\"收藏\"&#125;', content_type='application/json') else: # 判断获取的fav_id以及fav_type不为0，则只能是&gt;0，才表示用户选择 if int(fav_id) &gt; 0 and int(fav_type) &gt; 0 : user_fav = UserFavorite() # 保存数据到数据库 user_fav.user = request.user user_fav.fav_id = int(fav_id) user_fav.fav_type = int(fav_type) user_fav.save() return HttpResponse('&#123;\"status\":\"success\", \"msg\":\"已收藏\"&#125;', content_type='application/json') else: return HttpResponse('&#123;\"status\":\"fail\", \"msg\":\"错误收藏\"&#125;', content_type='application/json') 配置类视图路由 1url(r'^add_fav/$', AddFavView.as_view(), name=\"add_fav\"), # 用户收藏功能 因为该功能是4个页面共有的，所以在父模板中定义js代码即可，简单说明一下js代码，点击事件绑定类选择器collectionbtn，调用定义的add_fav函数，这个函数需要接收标签对象，以及后端类视图的参数fav_id以及fav_type，使用ajax post异步向后端接口发送请求，根据后端返回的响应数据msg来判断是取消收藏还是添加收藏以及判断用户的状态，状态未登录则跳转到登录页 1234567891011121314151617181920212223242526272829303132&lt;script type=\"text/javascript\"&gt; //收藏 function add_fav(current_elem, fav_id, fav_type) &#123; $.ajax(&#123; cache: false, type: \"POST\", url: \"/org/add_fav/\", data: &#123;'fav_id': fav_id, 'fav_type': fav_type&#125;, async: true, beforeSend: function (xhr, settings) &#123; xhr.setRequestHeader(\"X-CSRFToken\", \"&#123;&#123; csrf_token &#125;&#125;\"); &#125;, success: function (data) &#123; if (data.status == 'fail') &#123; if (data.msg == '用户未登录') &#123; window.location.href = \"/login/\"; &#125; else &#123; alert(data.msg) &#125; &#125; else if (data.status == 'success') &#123; current_elem.text(data.msg) &#125; &#125;, &#125;); &#125; $('.collectionbtn').on('click', function () &#123; add_fav($(this), &#123;&#123; course_org.id &#125;&#125;, 2); &#125;); &lt;/script&gt; Debug测试收藏功能（用户未登录时） Debug测试收藏功能（用户已登录） 收藏功能展示 2.完善收藏功能 说明：当用户点击收藏并且收藏成功时，则功能内容显示为已收藏，但刷新页面就变成了收藏，实际数据库userfavorite表时存在数据的；因为当前的页面并不知道收藏功能的状态时什么状态 在机构详情4个页面类视图中添加以下代码，并将has_fav变量进行返回给前端模板 1234567# 设置默认为未收藏状态has_fav = False# 当用户为登录状态才能根据条件查询该用户收藏数据if request.user.is_authenticated(): # 当用户已收藏时，即has_fav = True ，需注意这里的fav_type = 2 这个条件是固定的因为此页面为课程机构页面 if UserFavorite.objects.filter(user=request.user, fav_id=int(course_org.id), fav_type=2): has_fav = True 在父模板org_base中根据后端传递的has_fav数据的值，判断页面是显示收藏还是已收藏 1234&lt;div class=\"btn fr collectionbtn notlogin\" data-favid=\"22\" data-fav-type=\"1\"&gt; &#123;% if has_fav %&#125;已收藏&#123;% else %&#125;收藏&#123;% endif %&#125;&lt;/div&gt; 在机构详情页面top栏还是登录注册应该进行判断显示，直接将index模板的判断内容拷贝替换掉org_base模板中同标签内容 测试收藏功能 五丶公开课（列表页）1.模板继承 前端模板为course-list，页面如下 course-list模板与org-list模板一样都是继承于base模板（这里不用再多说了） 2.显示课程列表页 在根级urls中配置course应用下的urls 1url(r'course/', include('courses.urls', namespace=\"course\")), # 课程应用course下的urls 在course/views中定义类视图get方法 1234class CourseListView(View): \"\"\"课程列表页\"\"\" def get(self, request): return render(request, \"course-list.html\") 在应用urls中定义路由 1url(r'^list/$', CourseListView.as_view(), name=\"course_list\"), # 课程列表页 访问http://127.0.0.1:8000/course/list/ 课程列表页，成功显示出页面 3.课程列表页动态数据展示 在xadmin后台中添加课程表数据 在视图中获取所有的课程信息，并返回给模板 12345class CourseListView(View): \"\"\"课程列表页\"\"\" def get(self, request): all_courses = Course.objects.all() return render(request, \"course-list.html\", &#123;\"all_courses\":all_courses&#125;) 在模板中进行循环遍历打印显示页面内容字段数据 123456789101112131415161718192021222324&lt;div class=\"group_list\"&gt; &#123;% for course in all_courses %&#125; &lt;div class=\"box\"&gt; &lt;a href=\"course-detail.html\"&gt; &lt;img width=\"280\" height=\"350\" class=\"scrollLoading\" src=&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; course.image &#125;&#125;/&gt; &lt;/a&gt; &lt;div class=\"des\"&gt; &lt;a href=\"course-detail.html\"&gt; &lt;h2&gt;&#123;&#123; course.name &#125;&#125;&lt;/h2&gt; &lt;/a&gt; &lt;span class=\"fl\"&gt;时长：&lt;i class=\"key\"&gt;&#123;&#123; course.learn_times &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;span class=\"fr\"&gt;学习人数：&#123;&#123; course.students &#125;&#125;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;a href=\"course-detail.html\"&gt;&lt;span class=\"fl\"&gt;来自&#123;&#123; course.course_org.name &#125;&#125;&lt;/span&gt;&lt;/a&gt; &lt;span class=\"star fr notlogin \" data-favid=\"15\"&gt; &#123;&#123; course.fav_nums &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt; 刷新页面，成功显示出动态数据 4.课程列表页数据分页 跟机构列表页一样使用pure_pagination第三方工具进行分页处理，完全可以照搬，首先在视图中进行分页数据处理 123456789101112class CourseListView(View): \"\"\"课程列表页\"\"\" def get(self, request): all_courses = Course.objects.all() # 分页处理 try: page = request.GET.get('page', 1) except PageNotAnInteger: page = 1 p = Paginator(all_courses, 12, request=request) courses = p.page(page) return render(request, \"course-list.html\", &#123;\"all_courses\":courses&#125;) 在course-list模板中需要将前面遍历的all_courses修改为{% for course in all_courses.object_list %}，然后将org-list模板中的分页代码拷贝到course-list分页标签下，只需要将代码中的all_orgs修改为all_courses即可 123456789101112131415161718192021&lt;div class=\"pageturn\"&gt; &lt;ul class=\"pagelist\"&gt; &#123;% if all_courses.has_previous %&#125; &lt;li class=\"long\"&gt;&lt;a href=\"?&#123;&#123; all_courses.previous_page_number.querystring &#125;&#125;\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% for page in all_courses.pages %&#125; &#123;% if page %&#125; &#123;% ifequal page all_courses.number %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"?&#123;&#123; page.querystring &#125;&#125;\"&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"?&#123;&#123; page.querystring &#125;&#125;\" class=\"page\"&gt;&#123;&#123; page &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endifequal %&#125; &#123;% else %&#125; &lt;li class=\"none\"&gt;&lt;a href=\"\"&gt;...&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if all_courses.has_next %&#125; &lt;li class=\"long\"&gt;&lt;a href=\"?&#123;&#123; all_courses.next_page_number.querystring &#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt;&lt;/div&gt; 课程列表页分页功能测试 5.课程列表页面数据排序 在视图中根据链接地址sort参数来判断从数据库进行什么条件排序，需将请求地址获取的sort参数的值传递给前端模板，用于前端模板判断标签active激活操作 123456789101112131415161718192021class CourseListView(View): \"\"\"课程列表页\"\"\" def get(self, request): # 默认按最新排序 all_courses = Course.objects.all().order_by(\"-add_time\") # 热门与人数排序 sort = request.GET.get(\"sort\", \"\") if sort: if sort == \"students\": all_courses = all_courses.order_by(\"-students\") # 人数 elif sort == \"hot\": all_courses = all_courses.order_by(\"-click_nums\") # 点击数来决定热门 # 分页处理 try: page = request.GET.get('page', 1) except PageNotAnInteger: page = 1 p = Paginator(all_courses, 12, request=request) courses = p.page(page) return render(request, \"course-list.html\", &#123;\"all_courses\":courses, \"sort\":sort&#125;) 在模板中需要定义链接地址，以及判断后台传递过来的sort值，来给标签添加激活样式 12345&lt;ul class=\"tab_header\"&gt; &lt;li class=\"&#123;% if not sort %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"?sort=\"&gt;最新 &lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if sort == 'hot' %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"?sort=hot\"&gt;最热门&lt;/a&gt;&lt;/li&gt; &lt;li class=\"&#123;% if sort == 'students' %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"?sort=students\"&gt;参与人数&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 测试页面数据排序功能 6.页面右侧栏热门课程显示 在视图中按照click_num倒序排序获取数据，传递到模板中 12# 热门课程hot_courses = Course.objects.all().order_by(\"-click_nums\")[:3] 在模板中进行打印显示即可，非常简单，需要注意的是因为degree课程难度为choice字段所以需要使用django提供的此方式进行打印get_表字段_display 12345678910111213141516171819&lt;div class=\"right layout\"&gt; &lt;div class=\"head\"&gt;热门课程推荐&lt;/div&gt; &lt;div class=\"group_recommend\"&gt; &#123;% for hot_course in hot_courses %&#125; &lt;dl&gt; &lt;dt&gt; &lt;a target=\"_blank\" href=\"\"&gt; &lt;img width=\"240\" height=\"220\" class=\"scrollLoading\" src=&#123;&#123; MEDIA_URL &#125;&#125;&#123;&#123; hot_course.image &#125;&#125;/&gt; &lt;/a&gt; &lt;/dt&gt; &lt;dd&gt; &lt;a target=\"_blank\" href=\"\"&gt;&lt;h2&gt; &#123;&#123; hot_course.name &#125;&#125;&lt;/h2&gt;&lt;/a&gt; &lt;span class=\"fl\"&gt;难度：&lt;i class=\"key\"&gt;&#123;&#123; hot_course.get_degree_display &#125;&#125;&lt;/i&gt;&lt;/span&gt; &lt;/dd&gt; &lt;/dl&gt; &#123;% endfor %&#125; &lt;/div&gt;&lt;/div&gt; 测试显示页面中的热门课程 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/89914436","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目于之在线教育平台网站的实战开发（二）","slug":"Django项目于之在线教育平台网站的实战开发（二）","date":"2019-11-12T05:25:50.123Z","updated":"2019-11-13T14:38:40.037Z","comments":true,"path":"2019/11/12/Django项目于之在线教育平台网站的实战开发（二）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/12/Django项目于之在线教育平台网站的实战开发（二）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶用户登录注册功能实现 二丶找回密码（忘记密码）","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶用户登录注册功能实现 二丶找回密码（忘记密码） 一丶用户登录注册功能实现1.渲染网站主页面 在项目根目录下创建static目录，将资源文件拷贝到目录中 将static/html目录中的主页模板index.html文件拷贝到templates模板目录中，并修改代码中引入的静态资源路径，例如下 在settings目录中添加static静态资源目录 1STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')] 在根级urls中定义主页路由 1url(r'^$', TemplateView.as_view(template_name=\"index.html\"), name=\"index\") 启动项目，在浏览器输入http://127.0.0.1:8000 则渲染出网站主页 2.渲染登录页以及注册页 跟主页一样首先拷贝login.html和register.html模板文件到templates目录中，修改静态资源路径（不演示），在根级urls中配置登录页和注册页的路由规则 1234567urlpatterns = [ # url(r'^admin/', admin.site.urls), url(r'^xadmin/', xadmin.site.urls), url(r'^$', TemplateView.as_view(template_name=\"index.html\"), name=\"index\"), url(r'^login/$', TemplateView.as_view(template_name=\"login.html\"), name=\"login\"), url(r'^register/$', TemplateView.as_view(template_name=\"register.html\"), name=\"register\")] 在主页丶登录页以及注册页中将所有涉及到的注册登录链接地址修改如下 12&lt;a style=\"color:white\" class=\"fr registerbtn\" href=\"/register/\"&gt;注册&lt;/a&gt;&lt;a style=\"color:white\" class=\"fr loginbtn\" href=\"/login/\"&gt;登录&lt;/a&gt; 测试注册登录页面间跳转与显示 3.实现登录功能 在users/views中定义登录视图函数，视图函数逻辑为首先根据用户请求方式进行不同的逻辑处理，登录逻辑代码简单，需要注意的是，用户进行登录时需要提交表单post请求，获取请求携带参数username和password，django提供了authenticate方法，向数据库对应表发起验证，判断用户填写的用户名和密码是否正确，正确返回对象，不正确返回None；同时提供了login方法，该方法才是完成正常的登录 1234567891011121314151617from django.shortcuts import renderfrom django.contrib.auth import authenticate, login# Create your views here. def user_login(request): if request.method == \"GET\": return render(request, \"login.html\") elif request.method == \"POST\": user_name = request.POST.get(\"username\", \"\") pass_word = request.POST.get(\"password\", \"\") user = authenticate(username=user_name, password=pass_word) if user is not None: login(request, user) return render(request, \"index.html\") else: return render(request, \"login.html\") 对应的login.html登录模板中修改form表单请求地址，以及请求方式并且定义csrf 1&lt;form action=\"/login/\" method=\"post\" autocomplete=\"off\"&gt; 在根级urls中，当比配login/ 路由时需要去调用定义的user_login视图函数，而不是渲染模板文件，所以需要进行如下修改 1url(r'^login/$', user_login, name=\"login\"), 当登录成功后，即在index主页面不应该显示登录与注册按钮，而是显示出登录成功后的用户信息，所以在主页模板文件中需要进行如下判断，这里需要使用django默认传递的request参数到模板中去掉用user对象中的is_authenticated方法判断用户是否登录成功，说明一点这里还未替换登录成功后显示的用户信息，只是作于判断显示用户信息模块还是登录注册模块 123456789101112131415161718192021222324&#123;% if request.user.is_authenticated %&#125;&lt;div class=\"personal\"&gt; &lt;dl class=\"user fr\"&gt; &lt;dd&gt;bobby&lt;img class=\"down fr\" src=\"&#123;% static 'images/top_down.png' %&#125;\"/&gt;&lt;/dd&gt; &lt;dt&gt;&lt;img width=\"20\" height=\"20\" src=\"&#123;% static 'media/image/2016/12/default_big_14.png' %&#125;\"/&gt;&lt;/dt&gt; &lt;/dl&gt; &lt;div class=\"userdetail\"&gt; &lt;dl&gt; &lt;dt&gt;&lt;img width=\"80\" height=\"80\" src=\"&#123;% static 'media/image/2016/12/default_big_14.png' %&#125;\"/&gt;&lt;/dt&gt; &lt;dd&gt; &lt;h2&gt;django&lt;/h2&gt; &lt;p&gt;bobby&lt;/p&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;div class=\"btn\"&gt; &lt;a class=\"personcenter fl\" href=\"usercenter-info.html\"&gt;进入个人中心&lt;/a&gt; &lt;a class=\"fr\" href=\"/logout/\"&gt;退出&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% else %&#125; &lt;a style=\"color:white\" class=\"fr registerbtn\" href=\"/register/\"&gt;注册&lt;/a&gt; &lt;a style=\"color:white\" class=\"fr loginbtn\" href=\"/login/\"&gt;登录&lt;/a&gt;&#123;% endif %&#125; 测试用户登录功能（账号密码为超级管理员），登录成功则跳转到主页并且在主页上不显示登录和注册功能而显示用户信息模块；登录不成功则跳转到登录页 4.增加邮箱登录 django 提供的authenticate方法只是针对用使用用户名进行登录，当使用邮箱进行登录时，则会出现异常，博主使用Debug模式启动项目，在视图函数中打断点，然后在登录页面输入邮箱和密码后点击登录，则debug显示authenticate方法返回的user的值为None 要想使用邮箱进行登录，则需要自定义authenticate方法即可，首先在settings中设置AUTHENTICATION_BACKENDS为我们自定义的类，而这个类需要继承django.contrib.auth.backends中的ModelBackend类才能去重写父类的authenticate方法，具体实现如下 123456789class CustomBackend(ModelBackend): def authenticate(self, request, username=None, password=None, **kwargs): try: # 使用get查询唯一条件，使用django模型中提供的的Q类对查询条件or查询，通俗来说就是满足username或者email其中一个即可 user = UserProfile.objects.get(Q(username=username) | Q(email=username)) if user.check_password(password): return user except Exception as e: return None 在users/views中定义CustomBackend类后，还需要在settings配置AUTHENTICATION_BACKENDS 123AUTHENTICATION_BACKENDS = ( 'users.views.CustomBackend',) Debug测试使用邮箱登录成功调用重写的authenticate方法，并返回user对象 当user为None表示用户名或者密码错误，即需要在页面上提示用户错误信息，所以在视图函中返回登录页面时，需要向模板中传递错误信息 12345if user is not None: login(request, user) return render(request, \"index.html\")else: return render(request, \"login.html\", &#123;\"err_msg\":\"用户名或密码错误\"&#125;) 紧接着在登录模板文件中打印出此错误信息 1&lt;div class=\"error btns login-form-tips\" id=\"jsLoginTips\"&gt;&#123;&#123; err_msg &#125;&#125;&lt;/div&gt; 测试邮箱登录以及错误提示显示 5.使用类视图来区分用户请求（跟前面Djnago 电商项目一样） 定义类视图并且继承与View类，在类中编写对应的请求方式函数即可 1234567891011121314class LoginView(View): \"\"\"登录\"\"\" def get(self, request): return render(request, \"login.html\") def post(self, request): user_name = request.POST.get(\"username\", \"\") pass_word = request.POST.get(\"password\", \"\") user = authenticate(username=user_name, password=pass_word) if user is not None: login(request, user) return render(request, \"index.html\") else: return render(request, \"login.html\", &#123;\"err_msg\": \"用户名或密码错误\"&#125;) 在根级urls中需进行如下修改，需导入定义的类视图，并在路由中调用该类的as_views方法 1url(r'^login/$', LoginView.as_view(), name=\"login\") 6.在后端中进行登录表单信息验证 说明：在用户登录时，为了减少数据库查询操作，那么一个网站会在前端使用js对用户输入的信息进行判断（比如密码长度，是否为空等等）；不管前端有没有进行校验判断，后端也必须进行校验判断 在users应用下创建forms.py文件，用于校验用户输入的用户名密码是否合法，在文件中进行如下编写 12345class LoginFrom(forms.Form): \"\"\"登录表单验证\"\"\" # username和password变量名要与模板中表单字段名一致 username = forms.CharField(required=True) password = forms.CharField(required=True, min_length=5) 在登录类视图post方法中需要判断登录表单信息验证是否正确，当不正确存在错误时则将表单对象传递到登录模板中 12345678910111213def post(self, request): login_form = LoginFrom(request.POST) # 需传递的是字典对象 if login_form.is_valid(): user_name = request.POST.get(\"username\", \"\") pass_word = request.POST.get(\"password\", \"\") user = authenticate(username=user_name, password=pass_word) if user is not None: login(request, user) return render(request, \"index.html\") else: return render(request, \"login.html\", &#123;\"err_msg\": \"用户名或密码错误\"&#125;) else: return render(request, \"login.html\", &#123;\"login_form\": login_form&#125;) 不合法登录验证测试（输入密码小于5个字符） 不合法登录验证测试（密码为空） 7.将表单验证错误信息显示在登录页面中 在login.html模板中需要进行判断，如果后端传递过来的login_form对象中的errors存在username字段则在用户名所在的标签中添加errorput样式，password所在标签也是同样的 12345678&lt;div class=\"form-group marb20 &#123;% if login_form.errors.username %&#125;errorput&#123;% endif %&#125;\"&gt; &lt;label&gt;用&amp;nbsp;户&amp;nbsp;名&lt;/label&gt; &lt;input name=\"username\" id=\"account_l\" type=\"text\" placeholder=\"手机号/邮箱\" /&gt;&lt;/div&gt;&lt;div class=\"form-group marb8 &#123;% if login_form.errors.password %&#125;errorput&#123;% endif %&#125;\"&gt; &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码&lt;/label&gt; &lt;input name=\"password\" id=\"password_l\" type=\"password\" placeholder=\"请输入您的密码\" /&gt;&lt;/div&gt; 显示错误信息，需要循环遍历并且打印显示错误的字段对应错误提示，最初后面打印的error_msg信息与表单验证错误信息是不共存情况，所以写在一起无所谓 1&lt;div class=\"error btns login-form-tips\" id=\"jsLoginTips\"&gt;&#123;% for key,error in login_form.errors.items %&#125;&#123;&#123; error &#125;&#125;&#123;% endfor %&#125;&#123;&#123; err_msg &#125;&#125;&lt;/div&gt; 错误信息登录测试 8.Django 如何通过cookie和session来实现用户自动登录 用户第一次登录成功时在cookies中并没有携带名为sessionid的cookie，那么服务器就会根据登录成功的用户名和密码随机生成一段随机字符串，这段字符串是具有过期时间的，然后将这端字符串sessionid返回给浏览器并存在cookies中；当用户下一次请求时就会携带cookies中保存的sessionid给服务器，服务器根据浏览器发送的sessionid，在数据库django_session表中去进行查询，查询到sessionid对应的数据则自动登录，那么在登录成功后，是怎么将sessionid保存到数据库的呢？在LoginView类视图post请求方法中，login(request, user)这行代码中使用django提供的login方法会将用户登录成功的信息数据生成对应的sessionid保存到数据库表django_session的session_key中，当用户登录成功后，会去查询此sessionid取出用户信息的；如何将sessionid的值转换为用户信息取决于视图中的request，而request可以直接去调用user对象是因为settings中配置的’django.contrib.sessions’的app，查看用户登录成功后，访问主页index页面请求的cookies数据 查看数据库django_sessions表数据，从中可以发现session_key的值与cookies中sessionid的值一致 9.实现注册功能 在前面已经渲染出了注册页面，但这里需要通过类视图中的get方法来对注册模板进行渲染，所以首先需要定义类视图 1234class RegisterView(View): \"\"\"注册\"\"\" def get(self, request): return render(request, \"register.html\") 修改根基urls中的注册路由 1url(r'^register/$', RegisterView.as_view(), name=\"register\") 在index丶login以及register模板文件中将所有涉及到注册登录链接地址地方进行如下修改 12&lt;a style=\"color:white\" class=\"fr registerbtn\" href=\"&#123;% url 'register' %&#125;\"&gt;注册&lt;/a&gt;&lt;a style=\"color:white\" class=\"fr loginbtn\" href=\"&#123;% url 'login' %&#125;\"&gt;登录&lt;/a&gt; 在浏览器中输入http://127.0.0.1:8000/register 成功渲染出注册页面 在注册页面设计到验证码，所以需要安装django 第三方工具包captcha 安装captcha完成后，紧接需要将captcha注册到app中 123456789101112131415INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', \"users\", \"courses\", \"organization\", \"operation\", \"xadmin\", \"crispy_forms\", \"captcha\"] 在根级urls中将captcha.urls包含进来 1url(r'captcha/',include('captcha.urls')) 生成captcha迁移文件并执行迁移，在数据库中生成对应的数据表 查看生成的captcha数据表 如何在注册页面中显示captcha包生成的验证码，首先在users/forms模块中定义注册表单验证，在表单验证码字段中需要从captcha.fields中去导入CaptchaField类来进行验证，验证码错误提示为英文的invalid，所以需要进行转换为中文提示信息 12345class RegisterForm(forms.Form): '''注册表单验证''' email = forms.EmailField(required=True) password = forms.CharField(required=True, min_length=5) captcha = CaptchaField(error_messages=&#123;'invalid': '验证码错误'&#125;) 在类视图get方法中需要创建注册表单验证实例化对象 12345class RegisterView(View): \"\"\"注册\"\"\" def get(self, request): register_form = RegisterForm() return render(request, \"register.html\", &#123;'register_form':register_form&#125;) 在注册模板文件form表单中验证码标签下需要打印出后端传递的register_form对象的的captcha方法来显示出验证码图片 12345678910111213141516171819&lt;form id=\"email_register_form\" method=\"post\" action=\"&#123;% url 'register' %&#125;\" autocomplete=\"off\"&gt; &lt;div class=\"form-group marb20 \"&gt; &lt;label&gt;邮&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;箱&lt;/label&gt; &lt;input type=\"text\" id=\"id_email\" name=\"email\" placeholder=\"请输入您的邮箱地址\" /&gt; &lt;/div&gt; &lt;div class=\"form-group marb8 \"&gt; &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码&lt;/label&gt; &lt;input type=\"password\" id=\"id_password\" name=\"password\" placeholder=\"请输入6-20位非中文字符密码\" /&gt; &lt;/div&gt; &lt;div class=\"form-group marb8 captcha1 \"&gt; &lt;label&gt;验&amp;nbsp;证&amp;nbsp;码&lt;/label&gt; &#123;&#123; register_form.captcha &#125;&#125; &lt;/div&gt; &lt;div class=\"error btns\" id=\"jsEmailTips\"&gt;&lt;/div&gt; &lt;div class=\"auto-box marb8\"&gt; &lt;/div&gt; &lt;input class=\"btn btn-green\" id=\"jsEmailRegBtn\" type=\"submit\" value=\"注册并登录\" /&gt; &#123;% csrf_token %&#125;&lt;/form&gt; 测试注册页面验证码显示 查看数据表captcha_captchastore生成的验证码数据 在类视图RegisterView中定义post方法，进行注册表单的验证 1234def post(self, request): register_form = RegisterForm(request.POST) if register_form.is_valid(): pass 不合法注册验证（密码小于5） 不合法注册验证（邮箱密码为空） 不合法注册验证（验证码错误） 定义类视图post方法，将用户注册填写的用户名（邮箱）密码保存到数据库中 12345678910def post(self, request): register_form = RegisterForm(request.POST) if register_form.is_valid(): user_name = request.POST.get(\"email\", \"\") pass_word = request.POST.get(\"password\", \"\") user_profile = UserProfile() user_profile.username = user_name # 用户名 user_profile.email = user_name # 邮箱 user_profile.password = make_password(pass_word) # 密码 user_profile.save() 10.发送用户注册激活邮件 因为使用邮箱注册成功时需要向该邮箱发送激活邮件，对注册用户进行激活处理，所以在项目中需要定义发送邮件工具，即在apps目录下创建utils工具包，在工具包下创建email_send模块，在模块中进行发送邮件代码逻辑处理 12345678910111213141516171819202122232425262728293031def random_str(randomlength=8): \"\"\"生成随机字符串\"\"\" str = '' chars = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789' length = len(chars) - 1 random = Random() for i in range(randomlength): str+=chars[random.randint(0, length)] return str def send_register_email(email, send_type=\"register\"): \"\"\"发送邮件\"\"\" # 将要发送的随机字符串和邮箱地址以及验证码类型先保存到数据库中 email_record = EmailVerifyRecord() code = random_str(16) email_record.code = code email_record.email = email email_record.send_type = send_type email_record.save() # 定义发送邮件的标题和内容，根据验证码类型send_type对应发送不同的内容 email_title = \"\" email_body = \"\" if send_type == \"register\": email_title = \"慕学在线网注册激活链接\" email_body = \"请点击下面的链接激活你的账号: http://127.0.0.1:8000/active/&#123;0&#125;\".format(code) send_status = send_mail(email_title, email_body, EMAIL_FROM, [email]) if send_status: pass 博主在之前的Django电商项目中注册功能实现邮件激活是通过QQ邮箱进行演示的，而这里博主打算新建个新浪邮箱来进行本项目中账户邮件激活演示，首先进入新浪邮箱开启POP3/SMTP服务如下图配置即可 完成上一步后，需要在settings中配置邮件信息 123456EMAIL_HOST = \"smtp.sina.com\"EMAIL_PORT = 25EMAIL_HOST_USER = \"cdtaogang@sina.com\"EMAIL_HOST_PASSWORD = \"xxxxx\"EMAIL_USE_TLS= FalseEMAIL_FROM = \"cdtaogang@sina.com\" 回到注册类视图post方法中，调用定义的邮件发送工具包中的send_register_email方法，进行发送注册账号激活邮件 12# 发送激活邮件send_register_email(user_name, \"register\") Debug运行项目打断点测试邮件发送是否成功，Debug到post函数中发送调用send_register_email方法时并没有出错 继续Debug查看工具包中的send_register_email方法中调用send_email方法，返回为1表示发送成功 此时查看邮箱已收到邮件，整个注册发送激活邮件逻辑正确 查看数据库userprofile表信息，注册用户成功；因为UserProfile模型类继承的是django user用户类，所以默认is_active为激活状态，正常来说为0未激活，在后面代码逻辑中会进行设置的 当注册成功后则跳转到登录页，失败则跳转到注册页 12345678910111213141516def post(self, request): register_form = RegisterForm(request.POST) if register_form.is_valid(): user_name = request.POST.get(\"email\", \"\") pass_word = request.POST.get(\"password\", \"\") user_profile = UserProfile() user_profile.username = user_name # 用户名 user_profile.email = user_name # 邮箱 user_profile.password = make_password(pass_word) # 密码 user_profile.save() # 发送激活邮件 send_register_email(user_name, \"register\") return render(request, \"login.html\") else: return render(request, \"register.html\",&#123;\"register_form\": register_form&#125;) 11.将注册表单错误信息显示在页面中 跟登录功能一样，在注册模板中当存在不合法表单提交时打印出对应的错误提示，并对其input框添加红框样式显示；这里给邮箱框和密码框设定了value值为当用户输入不合法时，则在输入框中显示上一次的输入 12345678910111213141516171819&lt;form id=\"email_register_form\" novalidate method=\"post\" action=\"&#123;% url 'register' %&#125;\" autocomplete=\"off\"&gt; &lt;div class=\"form-group marb20 &#123;% if register_form.errors.email %&#125;errorput&#123;% endif %&#125;\"&gt; &lt;label&gt;邮&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;箱&lt;/label&gt; &lt;input type=\"text\" id=\"id_email\" name=\"email\" value=\"&#123;&#123; register_form.email.value &#125;&#125;\" placeholder=\"请输入您的邮箱地址\" /&gt; &lt;/div&gt; &lt;div class=\"form-group marb8 &#123;% if register_form.errors.password %&#125;errorput&#123;% endif %&#125;\"&gt; &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码&lt;/label&gt; &lt;input type=\"password\" id=\"id_password\" name=\"password\" value=\"&#123;&#123; register_form.password.value &#125;&#125;\" placeholder=\"请输入5-20位非中文字符密码\" /&gt; &lt;/div&gt; &lt;div class=\"form-group marb8 captcha1 &#123;% if register_form.errors.captcha %&#125;errorput&#123;% endif %&#125;\"&gt; &lt;label&gt;验&amp;nbsp;证&amp;nbsp;码&lt;/label&gt; &#123;&#123; register_form.captcha &#125;&#125; &lt;/div&gt; &lt;div class=\"error btns\" id=\"jsEmailTips\"&gt;&#123;% for key,error in register_form.errors.items %&#125;&#123;&#123; error &#125;&#125;&#123;% endfor %&#125;&#123;&#123; err_msg &#125;&#125;&lt;/div&gt; &lt;div class=\"auto-box marb8\"&gt; &lt;/div&gt; &lt;input class=\"btn btn-green\" id=\"jsEmailRegBtn\" type=\"submit\" value=\"注册并登录\" /&gt; &#123;% csrf_token %&#125;&lt;/form&gt; 注册功能提交错误表达测试 12.定义账户激活类视图，完成账户的激活 在注册类视图post方法中需要设置用户的激活状态为False，表示未激活 1user_profile.is_active = False 在users/views中定义账户激活类视图 1234567891011121314class AciveUserView(View): \"\"\"账户激活\"\"\" def get(self, request, active_code): # 根据邮件中的链接地址获取地址中的随机字符串到数据库emailverifyrecord表中获取此数据 all_records = EmailVerifyRecord.objects.filter(code=active_code) # 如果查询到数据则进行遍历获取record对象中的email，再根据email到用户信息表中查询user对象，设置此对象的is_active字段为True(激活) # 最后返回到登录页面 if all_records: for record in all_records: email = record.email user = UserProfile.objects.get(email=email) user.is_active = True user.save() return render(request, \"login.html\") 在根级urls中定义账户激活的路由，（）进行获取正则匹配到的参数保存到active_code中 1url(r'^active/(?P&lt;active_code&gt;.*)/$',AciveUserView.as_view(), name=\"user_active\") 在登录类视图post方法中则需要判断当前用户的is_active字段的值是否为True 12345678910111213141516def post(self, request): login_form = LoginFrom(request.POST) # 需传递的是字典对象 if login_form.is_valid(): user_name = request.POST.get(\"username\", \"\") pass_word = request.POST.get(\"password\", \"\") user = authenticate(username=user_name, password=pass_word) if user is not None: if user.is_active: login(request, user) return render(request, \"index.html\") else: return render(request, \"login.html\", &#123;\"err_msg\": \"用户未激活\"&#125;) else: return render(request, \"login.html\", &#123;\"err_msg\": \"用户名或密码错误\"&#125;) else: return render(request, \"login.html\", &#123;\"login_form\": login_form&#125;) 删除userprofile用户表和emailverifyrecord邮箱验证表cdtaogang@sina.com账户信息（因为之前还未设置用户注册时is_active字段为False），重新进行注册登录验证 还是使用之前的新浪邮箱进行注册，注册成功后查看数据表userprofile信息中is_active字段显示为0 登录以上注册账户进行测试，则提示账户未激活 查看邮件中激活邮件，访问激活链接地址，调用激活类视图，对此注册用户进行激活，最后跳转到登录页面 查看数据表userprofile信息 13.完善注册功能 一个邮箱只能允许被注册一次，即在注册类视图post方法中需要将用户填写的邮箱拿到后台数据库中进行查询，如果查询到说明此邮箱已经被注册过了，那么就返回错误信息提示，并返回注册页面，需要注意的是注册模板中需要register_form值，所以需要进行传递，不传递则，不会提示错误信息 123# 判断邮箱是否已经注册过if UserProfile.objects.filter(email=user_name): return render(request, \"register.html\", &#123;\"register_form\": register_form, \"err_msg\": \"此邮箱已被注册过\"&#125;) 测试使用已经注册成功的邮箱进行二次注册 在激活链接视图中当激活链接中的active_code不存在时，则返回错误页面信息 12345678910111213141516class AciveUserView(View): \"\"\"账户激活\"\"\" def get(self, request, active_code): # 根据邮件中的链接地址获取地址中的随机字符串到数据库emailverifyrecord表中获取此数据 all_records = EmailVerifyRecord.objects.filter(code=active_code) # 如果查询到数据则进行遍历获取record对象中的email，再根据email到用户信息表中查询user对象，设置此对象的is_active字段为True(激活) # 最后返回到登录页面 if all_records: for record in all_records: email = record.email user = UserProfile.objects.get(email=email) user.is_active = True user.save() else: return render(request, \"active_fail.html\") return render(request, \"login.html\") 在templates目录下创建active_fail模板文件，在该文件中可自定义页面数据，主要是为了提示用户链接地址错误不存在之类的 123456&lt;div class=\"txtbox\"&gt; &lt;p&gt;对不起，您请求的页面不存在、或已被删除、或暂时不可用&lt;/p&gt; &lt;p class=\"paddingbox\"&gt;请点击以下链接继续浏览网页&lt;/p&gt; &lt;p&gt;&lt;a style=\"cursor:pointer\" οnclick=\"history.back()\"&gt;返回上一页面&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=\"&#123;% url 'index' %&#125;\"&gt;返回网站首页&lt;/a&gt;&lt;/p&gt;&lt;/div&gt; 测试访问错误的激活链接地址（为了方便演示，换了火狐浏览器） 二丶找回密码（忘记密码）1.显示忘记密码页面 定义忘记密码类视图get函数 1234class ForgetPwdView(View): \"\"\"找回密码\"\"\" def get(self, request): return render(request, \"forgetpwd.html\") 在根级urls中配置路由 1url(r'^forget/$', ForgetPwdView.as_view(), name=\"forget_pwd\") 将static目录下的forgetpwd.html模板文件拷贝到templates目录下，然后在login模板文件中修改忘记密码链接地址 1&lt;a class=\"fr\" href=\"&#123;% url 'forget_pwd' %&#125;\"&gt;忘记密码？&lt;/a&gt; 测试显示忘记密码页面 修改forgetpwd模板文件中的静态资源链接地址，再次刷新页面 2.在忘记密码页面显示验证码图片 定义忘记密码form表单验证（跟注册表单验证逻辑一样） 1234class ForgetForm(forms.Form): \"\"\"忘记密码表单验证\"\"\" email = forms.EmailField(required=True) captcha = CaptchaField(error_messages=&#123;'invalid': '验证码错误'&#125;) 在类视图get方法中需要传递表单验证实例化对象到模板中 123def get(self, request): forget_form = ForgetForm() return render(request, \"forgetpwd.html\", &#123;\"forget_form\": forget_form&#125;) 在forgetpwd模板中，打印验证码图片 1234&lt;div class=\"form-group captcha1 marb38\"&gt; &lt;label&gt;验&amp;nbsp;证&amp;nbsp;码&lt;/label&gt; &#123;&#123; forget_form.captcha &#125;&#125;&lt;/div&gt; 刷新页面，则成功显示出图片验证码 3.发送重置密码邮件 在类视图中定义post方法，实现重置密码（代码逻辑与注册一样） 12345678def post(self, request): forget_form = ForgetForm(request.POST) if forget_form.is_valid(): email = request.POST.get(\"email\", \"\") send_register_email(email, \"forget\") return render(request, \"send_success.html\") else: return render(request, \"forgetpwd.html\", &#123;\"forget_form\": forget_form&#125;) 在forgetpwd模板文件中首先定义表单的请求方式以及地址，然后打印显示错误提示信息和显示错误红框以及在输入框中显示错误输入的邮箱地址（和register模板一样） 123456789101112131415&lt;form id=\"jsFindPwdForm\" novalidate method=\"post\" action=\"&#123;% url 'forget_pwd' %&#125;\" autocomplete=\"off\"&gt; &lt;div class=\"form-group marb20 &#123;% if register_form.errors.email %&#125;errorput&#123;% endif %&#125;\"&gt; &lt;label&gt;帐&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;号&lt;/label&gt; &lt;input type=\"text\" id=\"account\" name=\"email\" value=\"&#123;&#123; register_form.email.value &#125;&#125;\" placeholder=\"邮箱\" /&gt; &lt;/div&gt; &lt;div class=\"form-group captcha1 marb38 &#123;% if register_form.errors.captcha %&#125;errorput&#123;% endif %&#125;\"&gt; &lt;label&gt;验&amp;nbsp;证&amp;nbsp;码&lt;/label&gt; &#123;&#123; forget_form.captcha &#125;&#125; &lt;/div&gt; &lt;div class=\"error btns\" id=\"jsForgetTips\"&gt;&#123;% for key,error in forget_form.errors.items %&#125;&#123;&#123; error &#125;&#125;&#123;% endfor %&#125;&#123;&#123; err_msg &#125;&#125;&lt;/div&gt; &lt;input type=\"hidden\" name=\"sms_type\" value=\"1\"&gt; &lt;input class=\"btn btn-green\" id=\"jsFindPwdBtn\" type=\"submit\" value=\"提交\" /&gt; &lt;p class=\"form-p\" style=\"bottom:40px;\"&gt;您还可以&lt;a href=\"login.html\"&gt; [直接登录]&lt;/a&gt;&lt;/p&gt; &#123;% csrf_token %&#125;&lt;/form&gt; 在email_send模块send_register_email方法中需要定义发送重置密码的链接地址 1234567elif send_type == \"forget\": email_title = \"慕学在线网注册密码重置链接\" email_body = \"请点击下面的链接重置密码: http://127.0.0.1:8000/reset/&#123;0&#125;\".format(code) send_status = send_mail(email_title, email_body, EMAIL_FROM, [email]) if send_status: pass 邮件发送成功后则需要提示用户发送成功，所以需要在templates目录下创建视图方法中返回的send_success模板文件 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p style=\"font-size: 25px;font-style:inherit;color: #3f4724\"&gt;邮件发送成功，请查收&lt;/p&gt;&lt;a style=\"text-decoration: none\" href=\"https://mail.sina.com.cn/\"&gt;登录我的邮箱&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; Debug测试忘记密码发送邮件成功 同时Debug测试完成后，则在页面上渲染出send_success模板 点击登录我的邮箱，查看邮件 4.访问重置密码链接地址跳转到密码重置页面 首先定义重置密码类视图get方法（与注册账户激活逻辑大同小异），获取到用户邮箱后，则跳转到密码重置的页面（password_rest.html） 1234567891011121314class ResetView(View): \"\"\"重置密码\"\"\" def get(self, request, active_code): # 根据邮件中的链接地址获取地址中的随机字符串到数据库emailverifyrecord表中获取此数据 all_records = EmailVerifyRecord.objects.filter(code=active_code) # 如果查询到数据则进行遍历获取record对象中的email，返回密码重置页面，并将email传递给模板 # 最后返回到登录页面 if all_records: for record in all_records: email = record.email return render(request, \"password_reset.html\", &#123;\"email\":email&#125;) else: return render(request, \"active_fail.html\") return render(request, \"login.html\") 将static目录下的password_rest.html模板拷贝到templates目录下，修改模板资源路径这个就不再说了，之前已经演示过了，只需要将类视图传递过来的email，隐藏打印在input标签中 123456789101112131415161718&lt;form id=\"reset_password_form\" action=\"\" method=\"post\"&gt; &lt;ul&gt; &lt;li&gt; &lt;span class=\"\"&gt;新 密 码 ：&lt;/span&gt; &lt;input type=\"password\" name=\"password1\" id=\"pwd\" placeholder=\"5-20位非中文字符\"&gt; &lt;i&gt;&lt;/i&gt; &lt;/li&gt; &lt;input type=\"hidden\" name=\"email\" value=\"&#123;&#123; email &#125;&#125;\"&gt; &lt;li&gt; &lt;span class=\"\"&gt;确定密码：&lt;/span&gt; &lt;input type=\"password\" name=\"password2\" id=\"repwd\" placeholder=\"5-20位非中文字符\"&gt; &lt;i&gt;&lt;/i&gt; &lt;/li&gt; &lt;li class=\"button\"&gt; &lt;input type=\"submit\" value=\"提交\" &gt; &lt;/li&gt; &lt;/ul&gt;&lt;/form&gt; Debug断点测试访问重置密码链接地址http://127.0.0.1:8000/reset/iY9fgEJkd4bVJXSL是否跳转到密码重置页面 Debug断点测试完成后，页面成功跳转至密码修改页面（password_rest.html） 5.密码修改功能实现 因为密码修改页面，也是form表单提交，所以需要在forms中定义修改密码表单验证（需要注意的是忘记密码是一个表单，同样修改密码也是一个表单，两个表单都是单独页面） 1234class ModifyPwdForm(forms.Form): \"\"\"修改密码表单验证\"\"\" password1 = forms.CharField(required=True, min_length=5) password2 = forms.CharField(required=True, min_length=5) 定义修改密码类视图post方法，完成密码修改功能逻辑，需要注意的是为什么不在重置密码类视图ResetView下直接定义post方法，因为该类视图的路由规则中需要传递active_code，所以这里需要另外定义类视图来完成修改密码 123456789101112131415161718192021class ModifyPwdView(View): \"\"\"修改密码\"\"\" def post(self, request): modify_form = ModifyPwdForm(request.POST) if modify_form.is_valid(): pwd1 = request.POST.get(\"password1\", \"\") pwd2 = request.POST.get(\"password2\", \"\") # 该email为模板中隐藏的input标签 email = request.POST.get(\"email\", \"\") # 当用户两次密码不一致则提示错误信息到页面，一致时则通过用户名也就是邮箱来获取用户信息user对象，设置对象中的密码为用户填写的密码 # 最后返回到登录页面 if pwd1 != pwd2: return render(request, \"password_reset.html\", &#123;\"email\":email, \"msg\":\"密码不一致\"&#125;) user = UserProfile.objects.get(email=email) user.password = make_password(pwd2) user.save() return render(request, \"login.html\") else: # 表单验证不通过，则需要获取email邮箱地址，返回给password_reset模板，以及表单对象好用作于密码修改表单错误信息打印 email = request.POST.get(\"email\", \"\") return render(request, \"password_reset.html\", &#123;\"email\":email, \"modify_form\":modify_form&#125;) 在根级urls中配置路由 1url(r'^modify_pwd/$', ModifyPwdView.as_view(), name=\"modify_pwd\"), 紧接着在password_rest模板中，定义表单的请求方式以及地址 1&lt;form id=\"reset_password_form\" action=\"&#123;% url 'modify_pwd' %&#125;\" method=\"post\"&gt; Debug测试密码修改功能，测试密码修改成功 Debug测试完成后，页面跳转到登录页面 6.密码修改功能完整测试 说明：由于时间过长所以制作成两部分的动图 第一部分完成重置密码邮件的发送 第二部分访问重置密码链接地址完成密码修改并进行登录 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/89844432","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目于之在线教育平台网站的实战开发（一）","slug":"Django项目于之在线教育平台网站的实战开发（一）","date":"2019-11-12T03:59:14.371Z","updated":"2019-11-16T03:33:20.852Z","comments":true,"path":"2019/11/12/Django项目于之在线教育平台网站的实战开发（一）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/12/Django项目于之在线教育平台网站的实战开发（一）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶叙述 二丶Windows环境搭建 三丶数据库模型设计 四丶搭建后台管理系统 五丶使用xadmin注册方式注册模型表 六丶xadmin后台页面全局配置","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶叙述 二丶Windows环境搭建 三丶数据库模型设计 四丶搭建后台管理系统 五丶使用xadmin注册方式注册模型表 六丶xadmin后台页面全局配置 一丶叙述1.项目介绍 产品：关于Web端的教育平台网站 商业模式：B2C模式 企业对个人 设计模式：使用前后端不分离进行项目开发(后端控制前端的效果展示 2.开发环境（Windows） 开发语言：Python3 数据库：MySQL 前端：X-admin（前端后台模板框架） Web开发框架：Django 编程工具：PyCharm 3.前端页面效果展示 二丶Windows环境搭建 创建虚拟环境 在django_py3虚拟环境中安装django 创建django项目并配置解释器（django_py3） 创建成功如下图所示 配置settings中的数据库 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'mxonline', 'USER': 'root', 'PASSWORD': 'mysql', 'HOST': 'localhost', 'PORT': '3306', &#125;&#125; 创建mxonline数据库 启动项目，然后提示如下报错（之前的django项目使用的是python2环境，当前项目环境为python3） python3和python2两个的版本不一样，所以安装的东西也不一样：MySQLdb 安装mysql的连接包；工具安装 python3.x版本pip install mysqlclient 但是python2.x 版本pip install mysql-python 重新运行项目成功 三丶数据库模型设计1.创建app应用users（用户信息的应用） 打开IDE–Tools/Run manage.py Task，创建应用app 在users/models中创建用户信息模型表（该模型继承与django认证的user模型类，并且可以在原有的基础上添加所需表字段） 123456789101112131415class UserProfile(AbstractUser): \"\"\"用户信息\"\"\" nick_name = models.CharField(max_length=50, verbose_name=u\"昵称\", default=\"\") birday = models.DateField(verbose_name=u\"生日\", null=True, blank=True) gender = models.CharField(max_length=6, choices=((\"male\", u\"男\"), (\"female\", u\"女\")), default=\"female\") address = models.CharField(max_length=100, default=u\"\") mobile = models.CharField(max_length=11, null=True, blank=True) image = models.ImageField(upload_to=\"image/%Y/%m\", default=u\"image/default.png\", max_length=100) class Meta: verbose_name = \"用户信息\" verbose_name_plural = verbose_name def __unicode__(self): return self.username 在setting中注册users，并指定定义的模型类（默认覆盖AbstractUser类中的User表） 1234567891011INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', \"users\"]# 设置用户模型类AUTH_USER_MODEL = \"users.UserProfile\" 生成迁移文件并执行迁移 查看数据库表信息 在users/models中创建邮箱验证码模型表 12345678910class EmailVerifyRecord(models.Model): \"\"\"邮箱验证码\"\"\" code = models.CharField(max_length=20, verbose_name=u\"验证码\") email = models.EmailField(max_length=50, verbose_name=u\"邮箱\") send_type = models.CharField(verbose_name=u\"验证码类型\", choices=((\"register\",u\"注册\"),(\"forget\",u\"找回密码\"), (\"update_email\",u\"修改邮箱\")), max_length=30) send_time = models.DateTimeField(verbose_name=u\"发送时间\", default=datetime.now) class Meta: verbose_name = u\"邮箱验证码\" verbose_name_plural = verbose_name 在users/models中创建主页轮播图模型表 1234567891011class Banner(models.Model): \"\"\"主页轮播图\"\"\" title = models.CharField(max_length=100, verbose_name=u\"标题\") image = models.ImageField(upload_to=\"banner/%Y/%m\", verbose_name=u\"轮播图\", max_length=100) url = models.URLField(max_length=200, verbose_name=u\"访问地址\") index = models.IntegerField(default=100, verbose_name=u\"顺序\") add_time = models.DateTimeField(default=datetime.now, verbose_name=u\"添加时间\") class Meta: verbose_name = u\"轮播图\" verbose_name_plural = verbose_name 生成迁移文件并执行迁移 查看生成的数据库表信息 2.创建app应用courses（课程相关的应用） 创建app应用 在courses/models中创建课程基本信息表 12345678910111213141516class Course(models.Model): \"\"\"课程基本信息表\"\"\" name = models.CharField(max_length=50, verbose_name=u\"课程名\") desc = models.CharField(max_length=300, verbose_name=u\"课程描述\") detail = models.TextField(verbose_name=u\"课程详情\") degree = models.CharField(verbose_name=u\"难度\", choices=((\"cj\",\"初级\"), (\"zj\",\"中级\" ), (\"gj\",\"高级\")), max_length=2) learn_times = models.IntegerField(default=0, verbose_name=u\"学习时长(分钟数)\") students = models.IntegerField(default=0, verbose_name=u'学习人数') fav_nums = models.IntegerField(default=0, verbose_name=u'收藏人数') image = models.ImageField(upload_to=\"courses/%Y/%m\", verbose_name=u\"封面图\", max_length=100) click_nums = models.IntegerField(default=0, verbose_name=u\"点击数\") add_time = models.DateTimeField(default=datetime.now, verbose_name=u\"添加时间\") class Meta: verbose_name = u\"课程\" verbose_name_plural = verbose_name 在courses/models中创建章节信息表 123456789class Lesson(models.Model): \"\"\"章节信息表\"\"\" course = models.ForeignKey(Course, verbose_name=u\"课程\") name = models.CharField(max_length=100, verbose_name=u\"章节名\") add_time = models.DateTimeField(default=datetime.now, verbose_name=u\"添加时间\") class Meta: verbose_name = u\"章节\" verbose_name_plural = verbose_name 在courses/models中创建视频表 123456789class Video(models.Model): \"\"\"视频表\"\"\" lesson = models.ForeignKey(Lesson, verbose_name=u\"章节\") name = models.CharField(max_length=100, verbose_name=u\"视频名\") add_time = models.DateTimeField(default=datetime.now, verbose_name=u\"添加时间\") class Meta: verbose_name = u\"视频\" verbose_name_plural = verbose_name 在courses/models中创建课程资源表 12345678910class CourseResource(models.Model): \"\"\"课程资源\"\"\" course = models.ForeignKey(Course, verbose_name=u\"课程\") name = models.CharField(max_length=100, verbose_name=u\"名称\") download = models.FileField(upload_to=\"course/resource/%Y/%m\", verbose_name=u\"资源文件\", max_length=100) add_time = models.DateTimeField(default=datetime.now, verbose_name=u\"添加时间\") class Meta: verbose_name = u\"课程资源\" verbose_name_plural = verbose_name 3.创建app应用organization（机构相关的应用） 创建app应用 在organization/models中创建城市基本信息表 123456789class CityDict(models.Model): \"\"\"城市基本信息\"\"\" name = models.CharField(max_length=20, verbose_name=u\"城市\") desc = models.CharField(max_length=200, verbose_name=u\"描述\") add_time = models.DateTimeField(default=datetime.now) class Meta: verbose_name = u\"城市\" verbose_name_plural = verbose_name 在organization/models中创建课程机构基本信息表 1234567891011121314class CourseOrg(models.Model): \"\"\"课程机构基本信息\"\"\" name = models.CharField(max_length=50, verbose_name=u\"机构名称\") desc = models.TextField(verbose_name=u\"机构描述\") click_nums = models.IntegerField(default=0, verbose_name=u\"点击数\") fav_nums = models.IntegerField(default=0, verbose_name=u\"收藏数\") image = models.ImageField(upload_to=\"org/%Y/%m\", verbose_name=u\"logo\", max_length=100) address = models.CharField(max_length=150, verbose_name=u\"机构地址\") city = models.ForeignKey(CityDict, verbose_name=u\"所在城市\") add_time = models.DateTimeField(default=datetime.now) class Meta: verbose_name = u\"课程机构\" verbose_name_plural = verbose_name 在organization/models中创建教师基本信息表 123456789101112131415class Teacher(models.Model): \"\"\"教师基本信息\"\"\" org = models.ForeignKey(CourseOrg, verbose_name=u\"所属机构\") name = models.CharField(max_length=50, verbose_name=u\"教师名\") work_years = models.IntegerField(default=0, verbose_name=u\"工作年限\") work_company = models.CharField(max_length=50, verbose_name=u\"就职公司\") work_position = models.CharField(max_length=50, verbose_name=u\"公司职位\") points = models.CharField(max_length=50, verbose_name=u\"教学特点\") click_nums = models.IntegerField(default=0, verbose_name=u\"点击数\") fav_nums = models.IntegerField(default=0, verbose_name=u\"收藏数\") add_time = models.DateTimeField(default=datetime.now) class Meta: verbose_name = u\"教师\" verbose_name_plural = verbose_name 4.创建app应用operation（用户操作的应用） 创建app应用 在operation/models中创建用户咨询表 12345678910class UserAsk(models.Model): \"\"\"用户咨询\"\"\" name = models.CharField(max_length=20, verbose_name=u\"姓名\") mobile = models.CharField(max_length=11, verbose_name=u\"手机\") course_name = models.CharField(max_length=50, verbose_name=u\"课程名\") add_time = models.DateTimeField(default=datetime.now, verbose_name=u\"添加时间\") class Meta: verbose_name = u\"用户咨询\" verbose_name_plural = verbose_name 在operation/models中创建课程评论表 12345678910class CourseComments(models.Model): \"\"\"课程评论\"\"\" user = models.ForeignKey(UserProfile, verbose_name=u\"用户\") course = models.ForeignKey(Course, verbose_name=u\"课程\") comments = models.CharField(max_length=200, verbose_name=u\"评论\") add_time = models.DateTimeField(default=datetime.now, verbose_name=u\"添加时间\") class Meta: verbose_name = u\"课程评论\" verbose_name_plural = verbose_name 在operation/models中创建用户收藏表 12345678910class UserFavorite(models.Model): \"\"\"用户收藏\"\"\" user = models.ForeignKey(UserProfile, verbose_name=u\"用户\") fav_id = models.IntegerField(default=0, verbose_name=u\"数据id\") fav_type = models.IntegerField(choices=((1,\"课程\"),(2,\"课程机构\"),(3,\"讲师\")), default=1, verbose_name=u\"收藏类型\") add_time = models.DateTimeField(default=datetime.now, verbose_name=u\"添加时间\") class Meta: verbose_name = u\"用户收藏\" verbose_name_plural = verbose_name 在operation/models中创建用户消息表 12345678910class UserMessage(models.Model): \"\"\"用户消息\"\"\" user = models.IntegerField(default=0, verbose_name=u\"接收用户\") message = models.CharField(max_length=500, verbose_name=u\"消息内容\") has_read = models.BooleanField(default=False, verbose_name=u\"是否已读\") add_time = models.DateTimeField(default=datetime.now, verbose_name=u\"添加时间\") class Meta: verbose_name = u\"用户消息\" verbose_name_plural = verbose_name 在operation/models中创建用户学习课程表 123456789class UserCourse(models.Model): \"\"\"用户学习课程\"\"\" user = models.ForeignKey(UserProfile, verbose_name=u\"用户\") course = models.ForeignKey(Course, verbose_name=u\"课程\") add_time = models.DateTimeField(default=datetime.now, verbose_name=u\"添加时间\") class Meta: verbose_name = u\"用户课程\" verbose_name_plural = verbose_name 5.生成所有的数据表 在settings中注册创建的应用 123456789101112INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', \"users\", \"courses\", \"organization\", \"operation\"] 生成所有应用的migrations记录（迁移文件） 说明：因为之前users应用已经进行生成过迁移，所以这里只显示出以下三个应用app，makemigrations 后面不跟上应用app，则表示执行全部app应用可生成的迁移文件 在项目根目录下创建apps模块，将4个应用拷贝到该模块中，如下图所示 此时在models中会发现导入其他应用的app会提示找不到，则需要右击apps模块，点击Soures Root（这个操作会让IDE去搜索此apps目录） 执行迁移文件，然后会提示找不到users app应用，这个提示是正常的，因为上一步是针对于IDE编辑器本身查找路径，跟django框架本身没有任何关系，所以提示找不到 在settings配置文件中添加apps路径 1sys.path.insert(0, os.path.join(BASE_DIR, \"apps\")) 再次执行迁移，则执行成功 查看数据库mxonline表信息 四丶搭建后台管理系统1.创建后台管理员用户 2.进入admin后台管理页面 启动项目 在浏览器输入http://127.0.0.1:8000/admin，进入后台登录页面 使用创建的cdtaogang用户进行后台管理系统的登录 3.更改后台管理系统页面语言 在settings中配置语言和时区 12345LANGUAGE_CODE = &apos;zh-hans&apos; TIME_ZONE = &apos;Asia/Shanghai&apos; USE_TZ = False # 更改数据库存储时间为本地时间而不是国际utc时间 刷新页面 4.在django后端管理系统中显示用户信息表 在users/admin中注册用户信息表 1234class UserProfileAdmin(admin.ModelAdmin): pass admin.site.register(UserProfile, UserProfileAdmin) 刷新页面则显示注册的用户信息表 进入用户信息表查看当前用户信息 5.使用X-admin（基于django的后台框架）来替换当前的django后台管理系统 安装xadmin，结果报错，提示README.rst文件中编码问题 解决方法：下载xadmin安装包https://github.com/sshwsfc/xadmin，打开安装包中的README.rst文件，将内容全部删除即可 将xadmin-master.zip安装包放在项目根目录下，进入如下安装 最后安装xadmin成功，但提示django版本需在1.11版本以上，但1.9版本不兼容，博主该项目django版本为1.9 那么就换个django版本安装即可 查看当前环境下的包 将安装成功后的xadmin以及crispy_forms包添加到应用中 1234567891011121314INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', \"users\", \"courses\", \"organization\", \"operation\", \"xadmin\", \"crispy_forms\"] 修改根基urls中的路由地址 12345678from django.conf.urls import urlfrom django.contrib import adminimport xadmin urlpatterns = [ # url(r'^admin/', admin.site.urls),url(r'^xadmin/', xadmin.site.urls),] 运行项目，在浏览器中输入http://127.0.0.1:8000/xadmin/，提示以下错误（原因是xadmin自带的表为找到） 解决以上错误的方法：在数据库中去生成xadmin所需要的表（生成迁移并执行迁移） 刷新http://127.0.0.1:8000/xadmin/ 页面，成功显示xadmin的后台管理页面（确实要比django 自带的admin后台管理系统强大的多） 6.源码安装xadmin 为了方便对xadmin源码进行修改操作，所以可以直接将下载好的xadmin-master.zip包进行解压后，在解压的文件中找xadmin文件拷贝到项目根目录下的extra_apps包下（需要创建extra_apps包），该操作为源码安装，如下图所示 测试源码安装的xadmin是否成功，能否进入xadmin管理后台，在根级urls导入extra_apps包下的xadmin模块 123456789from django.conf.urls import urlfrom django.contrib import admin# import xadminfrom extra_apps import xadmin urlpatterns = [ # url(r'^admin/', admin.site.urls),url(r'^xadmin/', xadmin.site.urls),] 修改settings配置文件中注册的xadmin为extra_apps.xadmin 1234567891011121314INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &quot;users&quot;, &quot;courses&quot;, &quot;organization&quot;, &quot;operation&quot;, &quot;extra_apps.xadmin&quot;, &quot;crispy_forms&quot;] 刷新页面，xadmin后台管理页面显示不变，说明源码安装成功 五丶使用xadmin注册方式注册模型表1.注册users应用下的模型表 定义py文件的签名模板（每当创建一个py文件时，就会自动添加定义的模板内容） 在users应用下创建adminx.py文件（xadmin会自动去搜索应用下的此文件），在该文件中进行模型表注册 123456789101112# -*- coding: utf-8 -*-__author__ = 'cdtaogang'__date__ = '2019/5/4 15:24' from extra_apps import xadminfrom .models import EmailVerifyRecord class EmailVerifyRecordAdmin(object): pass xadmin.site.register(EmailVerifyRecord, EmailVerifyRecordAdmin) 刷新页面，就能看到以上注册的邮箱验证码了 在xadmin后台中添加邮箱验证码 自定义邮箱验证码列表显示字段 12class EmailVerifyRecordAdmin(object): list_display = ['code', 'email', 'send_type', 'send_time'] # 列表字段展示 刷新页面，查看邮箱验证码列表显示字段 添加邮箱验证码列表页面中搜索字段框 123class EmailVerifyRecordAdmin(object): list_display = ['code', 'email', 'send_type', 'send_time'] # 列表字段展示 search_fields = ['code', 'email', 'send_type'] # 搜索框显示 刷新页面，查看邮箱验证码列表页搜索框 测试搜索框功能 添加筛选器 1list_filter = ['code', 'email', 'send_type', 'send_time'] 测试筛选器功能 在users/adminx中进行注册轮播图模型表 123456class BannerAdmin(object): list_display = ['title', 'image', 'url', 'index', 'add_time'] search_fields = ['title', 'image', 'url', 'index'] list_filter = ['title', 'image', 'url', 'index', 'add_time'] xadmin.site.register(Banner, BannerAdmin) 刷新页面，成功显示出轮播图 2.注册courses应用下的模型表 在courses应用下创建adminx.py文件，在该文件中注册课程基本信息表 123456class CourseAdmin(object): list_display = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students'] search_fields = ['name', 'desc', 'detail', 'degree', 'students'] list_filter = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students'] xadmin.site.register(Course, CourseAdmin) 查看后台管理页面中课程信息表 注册章节信息表 123456class LessonAdmin(object): list_display = ['course', 'name', 'add_time'] search_fields = ['course', 'name'] list_filter = ['course__name', 'name', 'add_time'] xadmin.site.register(Lesson, LessonAdmin) 查看后台管理页面中章节信息表 测试添加课程以及章节 添加章节成功后，在章节列表中课程字段后面会出现一个感叹号，点击感叹号则会弹出该门课程的详细信息 注册视频信息表 123456class VideoAdmin(object): list_display = ['lesson', 'name', 'add_time'] search_fields = ['lesson', 'name'] list_filter = ['lesson', 'name', 'add_time'] xadmin.site.register(Video, VideoAdmin) 查看后台管理页面中视频信息表 注册课程资源表 123456class CourseResourceAdmin(object): list_display = ['course', 'name', 'download', 'add_time'] search_fields = ['course', 'name', 'download'] list_filter = ['course', 'name', 'download', 'add_time'] xadmin.site.register(CourseResource, CourseResourceAdmin) 查看后台管理页面中课程资源表 3.注册organization应用下的模型表 在organization应用下创建adminx.py文件，在该文件中注册城市基本信息表和课程机构基本信息表以及教师基本信息表 1234567891011121314151617181920class CityDictAdmin(object): list_display = ['name', 'desc', 'add_time'] search_fields = ['name', 'desc'] list_filter = ['name', 'desc', 'add_time'] class CourseOrgAdmin(object): list_display = ['name', 'desc', 'click_nums', 'fav_nums'] search_fields = ['name', 'desc', 'click_nums', 'fav_nums'] list_filter = ['name', 'desc', 'click_nums', 'fav_nums'] class TeacherAdmin(object): list_display = ['org', 'name', 'work_years', 'work_company'] search_fields = ['org', 'name', 'work_years', 'work_company'] list_filter = ['org', 'name', 'work_years', 'work_company'] xadmin.site.register(Teacher, TeacherAdmin)xadmin.site.register(CityDict, CityDictAdmin)xadmin.site.register(CourseOrg, CourseOrgAdmin) 查看后台管理页面中organization应用下的模型表 4.注册operation应用下的模型表 在operation应用下创建adminx.py文件，在该文件中注册用户咨询表丶用户学习课程表丶用户消息表丶课程评论以及用户收藏表 1234567891011121314151617181920212223242526272829303132333435class UserAskAdmin(object): list_display = [&apos;name&apos;, &apos;mobile&apos;, &apos;course_name&apos;, &apos;add_time&apos;] search_fields = [&apos;name&apos;, &apos;mobile&apos;, &apos;course_name&apos;] list_filter = [&apos;name&apos;, &apos;mobile&apos;, &apos;course_name&apos;, &apos;add_time&apos;] class UserCourseAdmin(object): list_display = [&apos;user&apos;, &apos;course&apos;, &apos;add_time&apos;] search_fields = [&apos;user&apos;, &apos;course&apos;] list_filter = [&apos;user&apos;, &apos;course&apos;, &apos;add_time&apos;] class UserMessageAdmin(object): list_display = [&apos;user&apos;, &apos;message&apos;, &apos;has_read&apos;, &apos;add_time&apos;] search_fields = [&apos;user&apos;, &apos;message&apos;, &apos;has_read&apos;] list_filter = [&apos;user&apos;, &apos;message&apos;, &apos;has_read&apos;, &apos;add_time&apos;] class CourseCommentsAdmin(object): list_display = [&apos;user&apos;, &apos;course&apos;, &apos;comments&apos;, &apos;add_time&apos;] search_fields = [&apos;user&apos;, &apos;course&apos;, &apos;comments&apos;] list_filter = [&apos;user&apos;, &apos;course&apos;, &apos;comments&apos;, &apos;add_time&apos;] class UserFavoriteAdmin(object): list_display = [&apos;user&apos;, &apos;fav_id&apos;, &apos;fav_type&apos;, &apos;add_time&apos;] search_fields = [&apos;user&apos;, &apos;fav_id&apos;, &apos;fav_type&apos;] list_filter = [&apos;user&apos;, &apos;fav_id&apos;, &apos;fav_type&apos;, &apos;add_time&apos;] xadmin.site.register(UserAsk, UserAskAdmin)xadmin.site.register(UserCourse, UserCourseAdmin)xadmin.site.register(UserMessage, UserMessageAdmin)xadmin.site.register(CourseComments, CourseCommentsAdmin)xadmin.site.register(UserFavorite, UserFavoriteAdmin) 查看后台管理页面中operation应用下的模型表 六丶xadmin后台页面全局配置1.更换xadmin主题 开启主题功能，在users/adminx中进行如下编写 1234567from extra_apps.xadmin import views class BaseSetting(object): enable_themes = True # 开启主题功能 use_bootswatch = True xadmin.site.register(views.BaseAdminView, BaseSetting) &lt;font=”color:red”&gt;查看Terminal终端日志提示以下错误 解决方法：卸载django_py3环境中的xadmin包（因之前博主是通过pip3 install xadmin-master.zip包，并且源码安装了xadmin），一直都是通过from extra_apps import xadmin导入方式，但现在该方式报错了，这个错是内部代码错误，所以博主这里就只保留源码的xadmin以及pip安装xadmin包时安装的依赖包 卸载完环境中的xadmin包后，需要在settings中将xadmin的搜索路径以及将添加的应用名extra_apps.xadmin修改为xadmin 12345678910111213141516sys.path.insert(0, os.path.join(BASE_DIR, \"extra_apps\")) INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', \"users\", \"courses\", \"organization\", \"operation\", \"xadmin\", \"crispy_forms\"] 将extra_apps目录进行Sources Root操作（在代码中可直接import xadmin）并且在根级urls中进行如下修改 123456789from django.conf.urls import urlfrom django.contrib import adminimport xadmin# from extra_apps import xadmin urlpatterns = [ # url(r'^admin/', admin.site.urls),url(r'^xadmin/', xadmin.site.urls),] 以防万一还需要将所有应用下的adminx中的导入xadmin模块的方式修改为import xadmin（这个自己修改即可），重新修改users/amdinx中的导入views以及xadmin方式，如下 1234567891011121314151617181920212223242526import xadminfrom .models import EmailVerifyRecord, Bannerfrom xadmin import views# from extra_apps import xadmin 错误的导入# from extra_apps.xadmin import views 错误的导入 class BaseSetting(object): enable_themes = True # 开启主题功能 use_bootswatch = True class EmailVerifyRecordAdmin(object): list_display = ['code', 'email', 'send_type', 'send_time'] # 列表字段展示 search_fields = ['code', 'email', 'send_type'] # 搜索框显示 list_filter = ['code', 'email', 'send_type', 'send_time'] # 筛选字段 class BannerAdmin(object): list_display = ['title', 'image', 'url', 'index', 'add_time'] search_fields = ['title', 'image', 'url', 'index'] list_filter = ['title', 'image', 'url', 'index', 'add_time'] xadmin.site.register(EmailVerifyRecord, EmailVerifyRecordAdmin)xadmin.site.register(Banner, BannerAdmin)xadmin.site.register(xadmin.views.BaseAdminView, BaseSetting) 重新启动项目，刷新xadmin后台管理页面，在页面右上方栏多出一个主题框 结果发现只显示了默认和Bootstrap2，这肯定是不对的，查看终端看有没有保存提示以下错误，但是没有指定是摸个模块下的第几行，说明是在try中捕获的异常 找到xadmin包中关于主题的模块themes.py模块，博主进行打印测试发现，因为博主使用的是python3开发，所以会进入six.PY3判断逻辑中，根据Terminal终端提示的’str’ object has no attribute ‘decode’，发现是这里出错导致代码没有继续执行，所以在页面中主题栏那里只显示了（默认和Bootstrap2），解决方法是注释掉此if six.PY3代码，则显示全部主题（该解决方法百度没有，因为百度上的解决方法都是针对于python2开发环境的） 注释掉以上红框的代码后，刷新页面成功显示出全部主题 博主按自己喜好更改了如下主题 2.修改页面左上方的Django Xadmin以及页面底部的我的公司 在users/adminx模块中进入如下编写 12345class GlobalSettings(object): site_title = \"慕学后台管理系统\" site_footer = \"慕学在线网\" xadmin.site.register(views.CommAdminView, GlobalSettings) 刷新页面，成功显示出定义的名字 3.将页面左侧显示的数据表栏信息，进行归纳收缩 只需要在GlobalSettings类中添加menu_style = “accordion” 代码即可 1234class GlobalSettings(object): site_title = \"慕学后台管理系统\" site_footer = \"慕学在线网\" menu_style = \"accordion\" 刷新页面，效果如下 4.设置左侧栏数据表名为中文名称 说明：在4个应用下的apps中定义verbose_name变量的值，并且在应用下的init.py文件中设置default_app_config的值 在users/apps中定义verbose_name变量的值 123class UsersConfig(AppConfig): name = 'users' verbose_name = u\"用户信息\" 在users/init中定义default_app_config的值 1default_app_config = \"users.apps.UsersConfig\" 在organization/apps中定义verbose_name变量的值 123class OrganizationConfig(AppConfig): name = 'organization' verbose_name = u\"机构管理\" 在organization/init中定义default_app_config的值 1default_app_config = \"organization.apps.OrganizationConfig\" 在operation/apps中定义verbose_name变量的值 123class OperationConfig(AppConfig): name = 'operation' verbose_name = u\"用户操作\" 在operation/init中定义default_app_config的值 1default_app_config = \"operation.apps.OperationConfig\" 在courses/apps中定义verbose_name变量的值 123class CoursesConfig(AppConfig): name = 'courses' verbose_name = u\"课程管理\" 在courses/init中定义default_app_config的值 1default_app_config = \"courses.apps.CoursesConfig\" 刷新页面成功显示出定义的模型表名称 还是黑色的主题看着顺眼 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/89788542","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之个性化微电影网站的实战开发（完结）","slug":"Flask项目之个性化微电影网站的实战开发（完结）","date":"2019-11-12T03:11:43.147Z","updated":"2019-11-13T14:35:20.351Z","comments":true,"path":"2019/11/12/Flask项目之个性化微电影网站的实战开发（完结）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/12/Flask项目之个性化微电影网站的实战开发（完结）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶前台管理（会员模块） 二丶前台管理（电影模块） 三丶前台管理（电影评论及统计） 四丶前台管理（电影收藏） 五丶前台管理（电影弹幕） 六丶代码优化以及bug处理","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶前台管理（会员模块） 二丶前台管理（电影模块） 三丶前台管理（电影评论及统计） 四丶前台管理（电影收藏） 五丶前台管理（电影弹幕） 六丶代码优化以及bug处理 一丶前台管理（会员模块）1.会员注册 定义会员注册表单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class RegistForm(FlaskForm): \"\"\"会员注册表单\"\"\" name = StringField( label=\"昵称\", validators=[ DataRequired(\"请输入昵称！\") ], description=\"昵称\", render_kw=&#123; \"class\": \"form-control input-lg\", \"placeholder\": \"请输入昵称！\", &#125; ) email = StringField( label=\"邮箱\", validators=[ DataRequired(\"请输入邮箱！\"), Email(\"邮箱格式不正确！\") ], description=\"邮箱\", render_kw=&#123; \"class\": \"form-control input-lg\", \"placeholder\": \"请输入邮箱！\", &#125; ) phone = StringField( label=\"手机\", validators=[ DataRequired(\"请输入手机！\"), Regexp(\"1[345789]\\\\d&#123;9&#125;\", message=\"手机格式不正确！\") ], description=\"手机\", render_kw=&#123; \"class\": \"form-control input-lg\", \"placeholder\": \"请输入手机！\", &#125; ) pwd = PasswordField( label=\"密码\", validators=[ DataRequired(\"请输入密码！\") ], description=\"密码\", render_kw=&#123; \"class\": \"form-control input-lg\", \"placeholder\": \"请输入密码！\", &#125; ) repwd = PasswordField( label=\"确认密码\", validators=[ DataRequired(\"请输入确认密码！\"), EqualTo('pwd', message=\"两次密码不一致！\") ], description=\"确认密码\", render_kw=&#123; \"class\": \"form-control input-lg\", \"placeholder\": \"请输入确认密码！\", &#125; ) submit = SubmitField( '注册', render_kw=&#123; \"class\": \"btn btn-lg btn-success btn-block\", &#125; ) def validate_name(self, field): name = field.data user = User.query.filter_by(name=name).count() if user == 1: raise ValidationError(\"昵称已经存在！\") def validate_email(self, field): email = field.data user = User.query.filter_by(email=email).count() if user == 1: raise ValidationError(\"邮箱已经存在！\") def validate_phone(self, field): phone = field.data user = User.query.filter_by(phone=phone).count() if user == 1: raise ValidationError(\"手机号码已经存在！\") 填写模板数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;form novalidate role=\"form\" method=\"post\"&gt; &lt;fieldset&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_name\"&gt;&lt;span class=\"glyphicon glyphicon-user\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.name.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.name&#125;&#125; &#123;% for error in form.name.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_name\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_email\"&gt;&lt;span class=\"glyphicon glyphicon-envelope\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.email.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.email&#125;&#125; &#123;% for error in form.email.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_email\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_phone\"&gt;&lt;span class=\"glyphicon glyphicon-phone\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.phone.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.phone&#125;&#125; &#123;% for error in form.phone.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_phone\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_password\"&gt;&lt;span class=\"glyphicon glyphicon-lock\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.pwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.pwd&#125;&#125; &#123;% for error in form.pwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_password\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_repassword\"&gt;&lt;span class=\"glyphicon glyphicon-lock\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.repwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.repwd&#125;&#125; &#123;% for error in form.repwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_repassword\"&gt;&lt;/div&gt; &#123;&#123;form.submit&#125;&#125; &#123;&#123;form.csrf_token&#125;&#125; &lt;/fieldset&gt;&lt;/form&gt; 定义视图函数 1234567891011121314151617# 会员注册@home.route('/register/', methods=['GET', 'POST'])def register(): form = RegistForm() if form.validate_on_submit(): data = form.data user = User( name=data[\"name\"], email=data[\"email\"], phone=data[\"phone\"], pwd=generate_password_hash(data[\"pwd\"]), uuid=uuid.uuid4().hex ) db.session.add(user) db.session.commit() flash(\"会员注册成功\", \"ok\") return render_template(\"home/register.html\",form=form) 测试会员注册功能 2.会员登录以及退出 会员登录 定义登录表单 123456789101112131415161718192021222324252627282930class LoginForm(FlaskForm): \"\"\"会员登录表单\"\"\" name = StringField( label=\"账号\", validators=[ DataRequired(\"请输入账号！\") ], description=\"账号\", render_kw=&#123; \"class\": \"form-control input-lg\", \"placeholder\": \"请输入账号！\", &#125; ) pwd = PasswordField( label=\"密码\", validators=[ DataRequired(\"请输入密码！\") ], description=\"密码\", render_kw=&#123; \"class\": \"form-control input-lg\", \"placeholder\": \"请输入密码！\", &#125; ) submit = SubmitField( '登录', render_kw=&#123; \"class\": \"btn btn-lg btn-primary btn-block\", &#125; ) 定义登录视图函数 12345678910111213141516171819202122# 会员登录@home.route('/login/', methods=['GET', 'POST'])def login(): form = LoginForm() if form.validate_on_submit(): data = form.data user = User.query.filter_by(name=data['name']).first() if not user.check_pwd(data['pwd']): flash(\"密码错误！\", \"err\") return redirect(url_for('home.login')) # 将登录成功后的用户名以及用户id保存到session会话机制中 session['user'] = user.name session['user_id'] = user.id # 将登陆操作保存到会员日志中 userlog = UserLog( user_id=user.id, ip=request.remote_addr ) db.session.add(userlog) db.session.commit() return redirect(url_for('home.user')) # 跳转到会员中心 return render_template(\"home/login.html\", form=form) 填写模板数据 1234567891011121314151617181920212223242526&lt;form novalidate role=\"form\" method=\"post\"&gt; &lt;fieldset&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_contact\"&gt;&lt;span class=\"glyphicon glyphicon-user\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.name.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.name&#125;&#125; &#123;% for error in form.name.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_contact\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_password\"&gt;&lt;span class=\"glyphicon glyphicon-lock\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.pwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.pwd&#125;&#125; &#123;% for error in form.pwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_password\"&gt;&lt;/div&gt; &#123;&#123;form.submit&#125;&#125; &#123;&#123;form.csrf_token&#125;&#125; &lt;/fieldset&gt;&lt;/form&gt;a 测试会员登录功能 会员退出 定义退出视图函数 123456# 会员退出@home.route('/logout/')def logout(): session.pop(\"user\", None) session.pop(\"user_id\", None) return redirect(url_for(\"home.login\")) 定义登录装饰器 12345678# 登录装饰器def user_login_required(f): @wraps(f) def decorated_function(*args, **kwargs): if \"user\" not in session: return redirect(url_for(\"home.login\", next=request.url)) return f(*args, **kwargs) return decorated_function 测试会员退出功能以及访问需要登录后才能访问的页面 3.修改会员资料 显示会员信息 定义会员信息表单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class UserdetailForm(FlaskForm): \"\"\"会员资料表单\"\"\" name = StringField( label=\"账号\", validators=[ DataRequired(\"请输入账号！\") ], description=\"账号\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入账号！\", &#125; ) email = StringField( label=\"邮箱\", validators=[ DataRequired(\"请输入邮箱！\"), Email(\"邮箱格式不正确！\") ], description=\"邮箱\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入邮箱！\", &#125; ) phone = StringField( label=\"手机\", validators=[ DataRequired(\"请输入手机！\"), Regexp(\"1[345789]\\\\d&#123;9&#125;\", message=\"手机格式不正确！\") ], description=\"手机\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入手机！\", &#125; ) face = FileField( label=\"头像\", validators=[ DataRequired(\"请上传头像！\") ], description=\"头像\", ) info = TextAreaField( label=\"简介\", validators=[ DataRequired(\"请输入简介！\") ], description=\"简介\", render_kw=&#123; \"class\": \"form-control\", \"rows\": 10 &#125; ) submit = SubmitField( '保存修改', render_kw=&#123; \"class\": \"btn btn-success\", &#125; ) 定义视图函数 1234567891011121314151617# 会员详情@home.route('/user/', methods=['GET', 'POST'])@user_login_requireddef user(): form = UserdetailForm() form.face.validators = [] # 默认图片为空 user = User.query.get(int(session['user_id'])) # 设置表单字段初始值 if request.method == 'GET': form.name.data = user.name form.email.data = user.email form.phone.data = user.phone form.face.data = user.face form.info.data = user.info if form.validate_on_submit(): data = form.data return render_template(\"home/user.html\", form=form, user=user) 填写模板数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;form novalidate role=\"form\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;fieldset&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_name\"&gt;&lt;span class=\"glyphicon glyphicon-user\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.name.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.name&#125;&#125; &#123;% for error in form.name.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_name\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_email\"&gt;&lt;span class=\"glyphicon glyphicon-envelope\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.email.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.email&#125;&#125; &#123;% for error in form.email.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_email\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_phone\"&gt;&lt;span class=\"glyphicon glyphicon-phone\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.phone.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.phone&#125;&#125; &#123;% for error in form.phone.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_phone\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_face\"&gt;&lt;span class=\"glyphicon glyphicon-picture\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.face.label&#125;&#125;&lt;/label&gt; &#123;% if user.face %&#125; &lt;img src=\"&#123;&#123;url_for('static', filename='uploads/users/'+user.face)&#125;&#125;\" width=\"100px\" class=\"img-responsive img-rounded\"&gt; &#123;% else %&#125; &lt;img data-src=\"holder.js/100x100\" class=\"img-responsive img-rounded\"&gt; &#123;% endif %&#125; &#123;&#123;form.face&#125;&#125; &#123;% for error in form.face.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_face\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_info\"&gt;&lt;span class=\"glyphicon glyphicon-edit\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.info.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.info&#125;&#125; &#123;% for error in form.info.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_info\"&gt;&lt;/div&gt; &#123;&#123;form.submit&#125;&#125; &#123;&#123;form.csrf_token&#125;&#125; &lt;/fieldset&gt;&lt;/form&gt; 测试显示会员表单信息 修改会员信息 在app/init.py文件中定义会员头像资源路径 1app.config[\"FC_DIR\"] = os.path.join(os.path.abspath(os.path.dirname(__file__)), \"static/uploads/users/\") 在视图函数进行修改逻辑编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 会员详情@home.route('/user/', methods=['GET', 'POST'])@user_login_requireddef user(): form = UserdetailForm() form.face.validators = [] # 默认图片为空 user = User.query.get(int(session['user_id'])) # 设置表单字段初始值 if request.method == 'GET': form.name.data = user.name form.email.data = user.email form.phone.data = user.phone form.info.data = user.info if form.validate_on_submit(): data = form.data file_face = secure_filename(form.face.data.filename) # 获取上传图片文件名 if not os.path.exists(app.config[\"FC_DIR\"]): # 文件夹不存在 os.makedirs(app.config[\"FC_DIR\"]) # 创建多级目录 os.chmod(app.config[\"FC_DIR\"], \"rw\") # 赋予文件读写的权限 user.face = change_filename(file_face) # 返回加密后的图片文件名 # 将url和logo数据写入到static/uploads/目录的filename文件中 form.face.data.save(app.config[\"FC_DIR\"] + user.face) # 判断用户修改的name email phone是否已经存在 name_count = User.query.filter_by(name=data[\"name\"]).count() if name_count == 1 and user.name != data['name']: flash(\"账号已存在！\", \"err\") return redirect(url_for('home.user')) email_count = User.query.filter_by(email=data[\"email\"]).count() if email_count == 1 and user.email != data['email']: flash(\"邮箱已存在！\", \"err\") return redirect(url_for('home.user')) phone_count = User.query.filter_by(phone=data[\"phone\"]).count() if phone_count == 1 and user.phone != data['phone']: flash(\"号码已存在！\", \"err\") return redirect(url_for('home.user')) # 更新数据 user.name = data['name'] user.email = data['email'] user.phone = data['phone'] user.info = data['info'] db.session.add(user) db.session.commit() flash(\"修改会员信息成功\", \"ok\") return redirect(url_for('home.user')) return render_template(\"home/user.html\", form=form, user=user) 测试修改会员信息功能 4.修改密码 定义修改密码表单 12345678910111213141516171819202122232425262728293031323334353637383940class PwdForm(FlaskForm): \"\"\"修改密码表单\"\"\" old_pwd = PasswordField( label=\"旧密码\", validators=[ DataRequired(\"请输入旧密码！\") ], description=\"旧密码\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入旧密码！\", &#125; ) new_pwd = PasswordField( label=\"新密码\", validators=[ DataRequired(\"请输入新密码！\"), ], description=\"新密码\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入新密码！\", &#125; ) submit = SubmitField( '修改密码', render_kw=&#123; \"class\": \"btn btn-success\", &#125; ) def validate_old_pwd(self, field): from flask import session pwd = field.data name = session[\"user\"] user = User.query.filter_by( name=name ).first() if not user.check_pwd(pwd): raise ValidationError(\"旧密码错误！\") 定义视图函数 1234567891011121314# 修改密码@home.route('/pwd/', methods=['GET', 'POST'])@user_login_requireddef pwd(): form = PwdForm() if form.validate_on_submit(): data = form.data user = User.query.filter_by(name=session['user']).first() user.pwd = generate_password_hash(data['new_pwd']) db.session.add(user) db.session.commit() flash(\"修改密码成功，请重新登录\", \"ok\") return redirect(url_for('home.logout')) return render_template(\"home/pwd.html\", form=form) 填写模板数据 1234567891011121314151617181920212223242526&lt;form novalidate role=\"form\" method=\"post\"&gt; &lt;fieldset&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_oldpwd\"&gt;&lt;span class=\"glyphicon glyphicon-lock\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.old_pwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.old_pwd&#125;&#125; &#123;% for error in form.old_pwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;span style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_oldpwd\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_newpwd\"&gt;&lt;span class=\"glyphicon glyphicon-lock\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;form.new_pwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.new_pwd&#125;&#125; &#123;% for error in form.new_pwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;span style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12\" id=\"error_newpwd\"&gt;&lt;/div&gt; &#123;&#123;form.submit&#125;&#125; &#123;&#123;form.csrf_token&#125;&#125; &lt;/fieldset&gt;&lt;/form&gt; 测试修改密码功能（hellomovie） 5.会员登录日志 定义视图函数 12345678910# 会员登录日志@home.route('/loginlog/&lt;int:page&gt;')@user_login_requireddef loginlog(page): if page == None: page=1 page_data = UserLog.query.filter_by( user_id=int(session['user_id']) ).order_by(UserLog.addtime.desc()).paginate(page=page, per_page=10) return render_template(\"home/loginlog.html\", page_data=page_data) 修改会员登录日志链接地址 123&lt;a id=\"m-4\" href=\"&#123;&#123;url_for('home.loginlog', page=1)&#125;&#125;\" class=\"list-group-item\"&gt; &lt;span class=\"glyphicon glyphicon-calendar\"&gt;&lt;/span&gt;&amp;nbsp;登录日志&lt;/a&gt; 填写模板数据 12345678910111213141516171819202122&lt;div class=\"panel-body\"&gt; &lt;table class=\"table table-bordered\"&gt; &lt;tr&gt; &lt;td style=\"width:10%\"&gt;编号&lt;/td&gt; &lt;td style=\"width:30%\"&gt;登录时间&lt;/td&gt; &lt;td style=\"width:30%\"&gt;登录IP&lt;/td&gt; &lt;!--&lt;td style=\"width:30%\"&gt;登录地址&lt;/td&gt;--&gt; &lt;/tr&gt; &#123;% for m in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;m.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.addtime&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.ip&#125;&#125;&lt;/td&gt; &lt;!--&lt;td&gt;云南昆明&lt;/td&gt;--&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'home.loginlog')&#125;&#125;&lt;/div&gt; 测试显示会员登录日志信息 二丶前台管理（电影模块）1.上映预告 定义视图函数 12345# 上映预告@home.route('/animation/')def animation(): data = Preview.query.all() return render_template(\"home/animation.html\", data=data) 填写模板数据 123456789&lt;ul&gt; &#123;% for d in data%&#125; &lt;li id=\"imgCard&#123;&#123;d.id-1&#125;&#125;\"&gt; &lt;a href=\"\"&gt;&lt;span style=\"opacity:0;\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;img src=\"&#123;&#123;url_for('static', filename='uploads/'+d.logo)&#125;&#125;\" alt=\"\"&gt; &lt;p style=\"bottom:0\"&gt;&#123;&#123;d.title&#125;&#125;&lt;/p&gt; &lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 测试上映预告显示 2.标签筛选 定义视图函数 1234567891011121314151617# 首页@home.route('/')def index(): tags = Tag.query.all() tid = request.args.get('tid', 0) # 标签 star = request.args.get('star', 0) # 星级 time = request.args.get(\"time\", 0) # 时间 pm = request.args.get(\"pm\", 0) # 播放量 cm = request.args.get(\"cm\", 0) # 评论量 p = dict( tid=tid, star=star, time=time, pm=pm, cm=cm ) return render_template(\"home/index.html\", tags=tags, p=p) 填写模板数据 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;table class=\"table text-left table-bordered\" id=\"movietags\"&gt; &lt;tr&gt; &lt;td style=\"width:10%;\"&gt;电影标签&lt;/td&gt; &lt;td style=\"width:90%;\"&gt; &#123;% for t in tags %&#125; &lt;a href=\"&#123;&#123;url_for('home.index')&#125;&#125;?tid=&#123;&#123;t.id&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-info\"&gt;&lt;span class=\"glyphicon glyphicon-tag\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;t.name&#125;&#125;&lt;/a&gt; &amp;nbsp; &#123;% endfor %&#125; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;电影星级&lt;/td&gt; &lt;td&gt; &#123;% for i in range(1,6) %&#125; &lt;a href=\"&#123;&#123;url_for('home.index')&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;i&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-warning\"&gt;&lt;span class=\"glyphicon glyphicon-star\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;i&#125;&#125;星&lt;/a&gt; &amp;nbsp; &#123;% endfor %&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;上映时间&lt;/td&gt; &lt;td&gt; &lt;a href=\"&#123;&#123;url_for('home.index')&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=1&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-default\"&gt;&lt;span class=\"glyphicon glyphicon-time\"&gt;&lt;/span&gt;&amp;nbsp;最近&lt;/span&gt;&lt;/a&gt; &amp;nbsp; &lt;a href=\"&#123;&#123;url_for('home.index')&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=2&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-default\"&gt;&lt;span class=\"glyphicon glyphicon-time\"&gt;&lt;/span&gt;&amp;nbsp;更早&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;播放数量&lt;/td&gt; &lt;td&gt; &lt;a href=\"&#123;&#123;url_for('home.index')&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=1&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-success\"&gt;&lt;span class=\"glyphicon glyphicon-arrow-down\"&gt;&lt;/span&gt;&amp;nbsp;从高到底&lt;/span&gt;&lt;/a&gt; &amp;nbsp; &lt;a href=\"&#123;&#123;url_for('home.index')&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=2&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-danger\"&gt;&lt;span class=\"glyphicon glyphicon-arrow-up\"&gt;&lt;/span&gt;&amp;nbsp;从低到高&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;评论数量&lt;/td&gt; &lt;td&gt; &lt;a href=\"&#123;&#123;url_for('home.index')&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=1\" class=\"label label-success\"&gt;&lt;span class=\"glyphicon glyphicon-arrow-down\"&gt;&lt;/span&gt;&amp;nbsp;从高到底&lt;/span&gt;&lt;/a&gt; &amp;nbsp; &lt;a href=\"&#123;&#123;url_for('home.index')&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=2\" class=\"label label-danger\"&gt;&lt;span class=\"glyphicon glyphicon-arrow-up\"&gt;&lt;/span&gt;&amp;nbsp;从低到高&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 测试显示标签数据以及对应标签请求参数 3.电影分页 在视图函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 首页@home.route('/&lt;int:page&gt;/', methods=['GET'])def index(page): tags = Tag.query.all() page_data = Movie.query tid = request.args.get('tid', 0) # 标签 if int(tid) != 0: page_data = page_data.filter_by(tag_id=int(tid)) star = request.args.get('star', 0) # 星级 if int(star) != 0: page_data = page_data.filter_by(star=int(star)) time = request.args.get(\"time\", 0) # 时间 if int(time) != 0: if int(time) == 1: page_data = page_data.order_by(Movie.addtime.desc()) else: page_data = page_data.order_by(Movie.addtime.asc()) pm = request.args.get(\"pm\", 0) # 播放量 if int(pm) != 0: if int(pm) == 1: page_data = page_data.order_by(Movie.playnum.desc()) else: page_data = page_data.order_by(Movie.playnum.asc()) cm = request.args.get(\"cm\", 0) # 评论量 if int(cm) != 0: if int(cm) == 1: page_data = page_data.order_by(Movie.commentnum.desc()) else: page_data = page_data.order_by(Movie.commentnum.asc()) # 分页 if page is None: page =1 page_data = page_data.paginate(page=page, per_page=10) p = dict( tid=tid, star=star, time=time, pm=pm, cm=cm ) return render_template(\"home/index.html\", tags=tags, p=p, page_data=page_data) 填写模板数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;div class=\"container\"&gt; &lt;div class=\"row wow fadeIn\" data-wow-delay=\"0.6s\"&gt; &lt;div class=\"col-md-12 table-responsive\"&gt; &lt;table class=\"table text-left table-bordered\" id=\"movietags\"&gt; &lt;tr&gt; &lt;td style=\"width:10%;\"&gt;电影标签&lt;/td&gt; &lt;td style=\"width:90%;\"&gt; &#123;% for t in tags %&#125; &lt;a href=\"&#123;&#123;url_for('home.index', page=1)&#125;&#125;?tid=&#123;&#123;t.id&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-info\"&gt;&lt;span class=\"glyphicon glyphicon-tag\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;t.name&#125;&#125;&lt;/a&gt; &amp;nbsp; &#123;% endfor %&#125; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;电影星级&lt;/td&gt; &lt;td&gt; &#123;% for i in range(1,6) %&#125; &lt;a href=\"&#123;&#123;url_for('home.index', page=1)&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;i&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-warning\"&gt;&lt;span class=\"glyphicon glyphicon-star\"&gt;&lt;/span&gt;&amp;nbsp;&#123;&#123;i&#125;&#125;星&lt;/a&gt; &amp;nbsp; &#123;% endfor %&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;上映时间&lt;/td&gt; &lt;td&gt; &lt;a href=\"&#123;&#123;url_for('home.index', page=1)&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=1&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-default\"&gt;&lt;span class=\"glyphicon glyphicon-time\"&gt;&lt;/span&gt;&amp;nbsp;最近&lt;/span&gt;&lt;/a&gt; &amp;nbsp; &lt;a href=\"&#123;&#123;url_for('home.index', page=1)&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=2&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-default\"&gt;&lt;span class=\"glyphicon glyphicon-time\"&gt;&lt;/span&gt;&amp;nbsp;更早&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;播放数量&lt;/td&gt; &lt;td&gt; &lt;a href=\"&#123;&#123;url_for('home.index', page=1)&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=1&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-success\"&gt;&lt;span class=\"glyphicon glyphicon-arrow-down\"&gt;&lt;/span&gt;&amp;nbsp;从高到底&lt;/span&gt;&lt;/a&gt; &amp;nbsp; &lt;a href=\"&#123;&#123;url_for('home.index', page=1)&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=2&amp;cm=&#123;&#123;p['cm']&#125;&#125;\" class=\"label label-danger\"&gt;&lt;span class=\"glyphicon glyphicon-arrow-up\"&gt;&lt;/span&gt;&amp;nbsp;从低到高&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;评论数量&lt;/td&gt; &lt;td&gt; &lt;a href=\"&#123;&#123;url_for('home.index', page=1)&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=1\" class=\"label label-success\"&gt;&lt;span class=\"glyphicon glyphicon-arrow-down\"&gt;&lt;/span&gt;&amp;nbsp;从高到底&lt;/span&gt;&lt;/a&gt; &amp;nbsp; &lt;a href=\"&#123;&#123;url_for('home.index', page=1)&#125;&#125;?tid=&#123;&#123;p['tid']&#125;&#125;&amp;star=&#123;&#123;p['star']&#125;&#125;&amp;time=&#123;&#123;p['time']&#125;&#125;&amp;pm=&#123;&#123;p['pm']&#125;&#125;&amp;cm=2\" class=\"label label-danger\"&gt;&lt;span class=\"glyphicon glyphicon-arrow-up\"&gt;&lt;/span&gt;&amp;nbsp;从低到高&lt;/span&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &#123;% for r in page_data.items%&#125; &lt;div class=\"col-md-3\"&gt; &lt;div class=\"movielist text-center\"&gt; &lt;img src=\"&#123;&#123;url_for('static', filename='uploads/'+r.logo)&#125;&#125;\" height=\"700px\" class=\"img-responsive center-block\" alt=\"\"&gt; &lt;div class=\"text-left\" style=\"margin-left:auto;margin-right:auto;width:210px;\"&gt; &lt;span style=\"color:#999;font-style: italic;\"&gt;&#123;&#123;r.title&#125;&#125;&lt;/span&gt;&lt;br&gt; &lt;div&gt; &#123;% for val in range(1,r.star+1) %&#125; &lt;span class=\"glyphicon glyphicon-star\" style=\"color:#FFD119\"&gt;&lt;/span&gt; &#123;% endfor %&#125; &#123;% for val in range(1,5-r.star+1) %&#125; &lt;span class=\"glyphicon glyphicon-star-empty\" style=\"color:#FFD119\"&gt;&lt;/span&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;a href=\"&#123;&#123;url_for('home.play')&#125;&#125;\" class=\"btn btn-primary\" target=\"_blank\" role=\"button\"&gt;&lt;span class=\"glyphicon glyphicon-play\"&gt;&lt;/span&gt;&amp;nbsp;播放&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;div class=\"col-md-12\"&gt; &#123;&#123;pg.page(page_data, 'home.index')&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 测试主页显示后台电影管理模块数据以及数据分页显示 4.电影搜索（很简单使用数据库模糊查询进行检索） 定义视图函数 1234567891011# 电影搜索@home.route('/search/&lt;int:page&gt;/')def search(page=None): if page is None: page = 1 key = request.args.get('key', '') # 获取请求地址参数中的key值 page_data = Movie.query.filter( Movie.title.ilike(\"%\" + key + \"%\") ).order_by(Movie.addtime.desc()).paginate(page=page, per_page=10) # 根据获取到的key值在数据库中进行模糊查询 movie_count = Movie.query.filter(Movie.title.ilike(\"%\" + key + \"%\")).count() return render_template(\"home/search.html\", key=key, page_data=page_data, movie_count=movie_count) 定义搜索框点击事件跳转地址（home.html以及layout.html） 1234567891011121314151617&lt;div class=\"form-group input-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"请输入电影名！\" id=\"key_movie\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;a class=\"btn btn-default\" id=\"do_search\"&gt;&lt;span class=\"glyphicon glyphicon-search\"&gt;&lt;/span&gt;&amp;nbsp;搜索&lt;/a&gt; &lt;/span&gt;&lt;/div&gt;&lt;script&gt; $(document).ready(function() &#123; $(\"img.lazy\").lazyload(&#123; effect: \"fadeIn\" &#125;); $('#do_search').click(function () &#123; var key = $('#key_movie').val(); location.href=\"&#123;&#123;url_for('home.search', page=1)&#125;&#125;?key=\" + key &#125;) &#125;);&lt;/script&gt; 填写模板数据（search.html） 12345678910111213141516171819202122232425&lt;div class=\"row\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;ol class=\"breadcrumb\" style=\"margin-top:6px;\"&gt; &lt;li&gt;与\"&#123;&#123;key&#125;&#125;\"有关的电影，共&#123;&#123;movie_count&#125;&#125;部&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;div class=\"col-md-12\"&gt; &#123;% for s in page_data.items %&#125; &lt;div class=\"media\"&gt; &lt;div class=\"media-left\"&gt; &lt;a href=\"&#123;&#123;url_for('home.play')&#125;&#125;\"&gt; &lt;img class=\"media-object\" style=\"width: 200px;height: 300px\" src=\"&#123;&#123;url_for('static', filename='uploads/' + s.logo)&#125;&#125;\" alt=\"&#123;&#123;s.title&#125;&#125;\"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;&#123;&#123;s.title&#125;&#125;&lt;a href=\"&#123;&#123;url_for('home.play')&#125;&#125;\" class=\"label label-primary pull-right\"&gt;&lt;span class=\"glyphicon glyphicon-play\"&gt;&lt;/span&gt;播放影片&lt;/a&gt;&lt;/h4&gt; &#123;&#123;s.info&#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12 text-center\"&gt; &#123;&#123;pg.page(page_data, 'home.search')&#125;&#125; &lt;/div&gt;&lt;/div&gt; 测试电影搜索功能 5.电影详情页（播放页） 定义视图函数 12345678# 电影播放页@home.route('/play/&lt;int:id&gt;/')def play(id=None): movie = Movie.query.join(Tag).filter( Tag.id == Movie.tag_id, Movie.id == int(id) ).first_or_404() return render_template(\"home/play.html\", movie=movie) 修改电影播放链接地址（需传递电影id，在search.html和index.html模板中进行播放地址修改） 1href=\"&#123;&#123;url_for('home.play', id=r.id)&#125;&#125;\" 填写模板数据（play.html） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;table class=\"table\"&gt; &lt;tr&gt; &lt;td style=\"width:30%;color:#ccc;font-weight:bold;font-style:italic;\"&gt; &lt;span class=\"glyphicon glyphicon-film\"&gt;&lt;/span&gt;&amp;nbsp;片名 &lt;/td&gt; &lt;td&gt;&#123;&#123;movie.title&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"color:#ccc;font-weight:bold;font-style:italic;\"&gt; &lt;span class=\"glyphicon glyphicon-tag\"&gt;&lt;/span&gt;&amp;nbsp;标签 &lt;/td&gt; &lt;td&gt;&#123;&#123;movie.tag.name&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"color:#ccc;font-weight:bold;font-style:italic;\"&gt; &lt;span class=\"glyphicon glyphicon-time\"&gt;&lt;/span&gt;&amp;nbsp;片长 &lt;/td&gt; &lt;td&gt;&#123;&#123;movie.length&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"color:#ccc;font-weight:bold;font-style:italic;\"&gt; &lt;span class=\"glyphicon glyphicon-map-marker\"&gt;&lt;/span&gt;&amp;nbsp;地区 &lt;/td&gt; &lt;td&gt;&#123;&#123;movie.area&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"color:#ccc;font-weight:bold;font-style:italic;\"&gt; &lt;span class=\"glyphicon glyphicon-star\"&gt;&lt;/span&gt;&amp;nbsp;星级 &lt;/td&gt; &lt;td&gt; &lt;div&gt; &#123;% for val in range(1,movie.star+1) %&#125; &lt;span class=\"glyphicon glyphicon-star\" style=\"color:#FFD119\"&gt;&lt;/span&gt; &#123;% endfor %&#125; &#123;% for val in range(1,5-movie.star+1) %&#125; &lt;span class=\"glyphicon glyphicon-star-empty\" style=\"color:#FFD119\"&gt;&lt;/span&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"color:#ccc;font-weight:bold;font-style:italic;\"&gt; &lt;span class=\"glyphicon glyphicon-calendar\"&gt;&lt;/span&gt;&amp;nbsp;上映时间 &lt;/td&gt; &lt;td&gt;&#123;&#123;movie.release_time&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"color:#ccc;font-weight:bold;font-style:italic;\"&gt; &lt;span class=\"glyphicon glyphicon-play\"&gt;&lt;/span&gt;&amp;nbsp;播放数量 &lt;/td&gt; &lt;td&gt;&#123;&#123;movie.playnum&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"color:#ccc;font-weight:bold;font-style:italic;\"&gt; &lt;span class=\"glyphicon glyphicon-comment\"&gt;&lt;/span&gt;&amp;nbsp;评论数量 &lt;/td&gt; &lt;td&gt;&#123;&#123;movie.commentnum&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"color:#ccc;font-weight:bold;font-style:italic;\"&gt; &lt;span class=\"glyphicon glyphicon-picture\"&gt;&lt;/span&gt;&amp;nbsp;影片介绍 &lt;/td&gt; &lt;td&gt; &#123;&#123;movie.info&#125;&#125; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 测试电影播放功能 三丶前台管理（电影评论及统计）1.电影评论 在电影播放页面判断用户是否登录，如果未登录则显示请登录即跳转到登录页面 123456789&#123;% if 'user' not in session %&#125;&lt;div class=\"alert alert-danger alert-dismissible\" role=\"alert\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\"&gt; &lt;span aria-hidden=\"true\"&gt;×&lt;/span&gt; &lt;span class=\"sr-only\"&gt;Close&lt;/span&gt; &lt;/button&gt; &lt;strong&gt;请先&lt;a href=\"&#123;&#123;url_for('home.login')&#125;&#125;\" target=\"_blank\" class=\"text-info\"&gt;登录&lt;/a&gt;，才可参与评论！&lt;/strong&gt;&lt;/div&gt;&#123;% endif %&#125; 在电影播放页面判断用户是否登录，如果未登录则不显示出评论框 1234567891011121314&#123;% if 'user' in session %&#125;&lt;form role=\"form\" style=\"margin-bottom:6px;\"&gt; &lt;div class=\"form-group\"&gt; &lt;div&gt; &lt;label for=\"input_content\"&gt;内容&lt;/label&gt; &lt;textarea id=\"input_content\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"col-xs-12\" id=\"error_content\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;a class=\"btn btn-success\" id=\"btn-sub\"&gt;&lt;span class=\"glyphicon glyphicon-edit\"&gt;&lt;/span&gt;&amp;nbsp;提交评论&lt;/a&gt; &amp;nbsp; &lt;a class=\"btn btn-danger\" id=\"btn-col\"&gt;&lt;span class=\"glyphicon glyphicon-heart\"&gt;&lt;/span&gt;&amp;nbsp;收藏电影&lt;/a&gt;&lt;/form&gt;&#123;% endif %&#125; 测试未登录状态播放电影 定义电影评论表单 12345678910111213141516171819class CommentForm(FlaskForm): \"\"\"电影评论表单\"\"\" content = TextAreaField( label=\"内容\", validators=[ DataRequired(\"请输入内容！\"), ], description=\"内容\", render_kw=&#123; \"id\": \"input_content\" &#125; ) submit = SubmitField( '提交评论', render_kw=&#123; \"class\": \"btn btn-success\", \"id\": \"btn-sub\" &#125; ) 修改模板数据块内容 123456789101112131415161718&lt;form novalidate role=\"form\" style=\"margin-bottom:6px;\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;div&gt; &lt;label for=\"input_content\"&gt;&#123;&#123;form.content.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.content&#125;&#125; &#123;% for error in form.content.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;span style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-xs-12\" id=\"error_content\"&gt;&lt;/div&gt; &lt;/div&gt; &#123;&#123;form.submit&#125;&#125; &#123;&#123;form.csrf_token&#125;&#125; &amp;nbsp; &lt;a class=\"btn btn-danger\" id=\"btn-col\"&gt;&lt;span class=\"glyphicon glyphicon-heart\"&gt;&lt;/span&gt;&amp;nbsp;收藏电影&lt;/a&gt;&lt;/form&gt; 在视图函数play中进行评论数据保存以及数据分页，需要注意的是分页需要在请求地址中接收page参数，需要注意的是播放页面的评论是看所有人的评论，即User.id == Comment.user_id而不是session中保存的user_id 123456789101112131415161718192021222324252627282930313233343536# 电影播放页@home.route('/play/&lt;int:id&gt;/&lt;int:page&gt;/', methods=['GET', 'POST'])def play(id=None, page=None): movie = Movie.query.join(Tag).filter( Tag.id == Movie.tag_id, Movie.id == int(id) ).first_or_404() # 评论数据分页处理 if page == None: page = 1 page_data = Comment.query.join(Movie).join(User).filter( Movie.id == movie.id, User.id == Comment.user_id ).order_by(Comment.addtime.desc()).paginate(page=page, per_page=5) # 播放量+1 movie.playnum += 1 form = CommentForm() # 保存评论内容信息到数据库 if 'user' in session and form.validate_on_submit(): data = form.data comment = Comment( content=data['content'], movie_id=movie.id, user_id=session['user_id'] ) db.session.add(comment) db.session.commit() # 评论量需要+1 movie.commentnum += 1 db.session.add(movie) db.session.commit() flash(\"评论成功\", 'ok') return redirect(url_for('home.play', id=movie.id, page=1)) db.session.add(movie) db.session.commit() return render_template(\"home/play.html\", movie=movie ,form=form, page_data=page_data) 因播放页面中的评论列表数据需要进行分页显示处理，则需要模板文件中跳转到播放页面的地址中添加page参数 1&lt;a href=\"&#123;&#123;url_for('home.play', id=r.id, page=1)&#125;&#125;\" class=\"btn btn-primary\" target=\"_blank\" role=\"button\"&gt;&lt;span class=\"glyphicon glyphicon-play\"&gt;&lt;/span&gt;&amp;nbsp;播放&lt;/a&gt; 拷贝ui目录下的admin_page.html模板文件到当前路径下并命名为comment_page.html，内容如下，需要接收id 123456789101112131415161718192021222324252627&#123;% macro page(data, url, id) %&#125;&#123;% if data %&#125;&lt;ul class=\"pagination pagination-sm no-margin pull-right\"&gt; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=1, id=id)&#125;&#125;\"&gt;首页&lt;/a&gt;&lt;/li&gt; &#123;% if data.has_prev %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=data.prev_num, id=id)&#125;&#125;\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% else%&#125; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% for p in data.iter_pages() %&#125; &#123;% if p == data.page %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;&#123;&#123;p&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=p, id=id)&#125;&#125;\"&gt;&#123;&#123;p&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if data.has_next %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=data.next_num, id=id)&#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% else%&#125; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=data.pages, id=id)&#125;&#125;\"&gt;尾页&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&#123;% endif %&#125;&#123;% endmacro %&#125; 最后在play模板文件中填写数据块内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;div class=\"panel-body\"&gt; &#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% if 'user' not in session %&#125; &lt;div class=\"alert alert-danger alert-dismissible\" role=\"alert\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\"&gt; &lt;span aria-hidden=\"true\"&gt;×&lt;/span&gt; &lt;span class=\"sr-only\"&gt;Close&lt;/span&gt; &lt;/button&gt; &lt;strong&gt;请先&lt;a href=\"&#123;&#123;url_for('home.login')&#125;&#125;\" target=\"_blank\" class=\"text-info\"&gt;登录&lt;/a&gt;，才可参与评论！&lt;/strong&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;ol class=\"breadcrumb\" style=\"margin-top:6px;\"&gt; &lt;li&gt;全部评论(&#123;&#123;movie.commentnum&#125;&#125;)&lt;/li&gt; &lt;/ol&gt; &#123;% if 'user' in session %&#125; &lt;form novalidate role=\"form\" style=\"margin-bottom:6px;\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;div&gt; &lt;label for=\"input_content\"&gt;&#123;&#123;form.content.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.content&#125;&#125; &#123;% for error in form.content.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;span style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-xs-12\" id=\"error_content\"&gt;&lt;/div&gt; &lt;/div&gt; &#123;&#123;form.submit&#125;&#125; &#123;&#123;form.csrf_token&#125;&#125; &amp;nbsp; &lt;a class=\"btn btn-danger\" id=\"btn-col\"&gt;&lt;span class=\"glyphicon glyphicon-heart\"&gt;&lt;/span&gt;&amp;nbsp;收藏电影&lt;/a&gt; &lt;/form&gt; &#123;% endif %&#125; &lt;ul class=\"commentList\"&gt; &#123;% for c in page_data.items %&#125; &lt;li class=\"item cl\"&gt; &lt;a&gt; &lt;i class=\"avatar size-L radius\"&gt; &lt;img alt=\"50x50\" src=\"&#123;&#123;url_for('static', filename='uploads/users/'+ c.user.face)&#125;&#125;\" class=\"img-circle\" style=\"border:1px solid #abcdef;width: 50px\"&gt; &lt;/i&gt; &lt;/a&gt; &lt;div class=\"comment-main\"&gt; &lt;header class=\"comment-header\"&gt; &lt;div class=\"comment-meta\"&gt; &lt;a class=\"comment-author\" href=\"user.html\"&gt;&#123;&#123;c.user.name&#125;&#125;&lt;/a&gt; 评论于 &lt;time title=\"&#123;&#123;c.addtime&#125;&#125;\" datetime=\"&#123;&#123;c.addtime&#125;&#125;\"&gt;&#123;&#123;c.addtime&#125;&#125;&lt;/time&gt; &lt;/div&gt; &lt;/header&gt; &lt;div class=\"comment-body\"&gt; &lt;p&gt;&#123;&#123;c.content | safe&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;div class=\"col-md-12 text-center\"&gt; &#123;&#123;pg.page(page_data, 'home.play',movie.id)&#125;&#125; &lt;/div&gt;&lt;/div&gt; 测试电影评论功能 2.分页显示会员评论记录 在会员模块中有个评论记录，该评论记录为用户的所有评论 定义视图函数 1234567891011# 会员评论记录@home.route('/comments/&lt;int:page&gt;/')@user_login_requireddef comments(page=None): if page == None: page = 1 page_data = Comment.query.join(Movie).join(User).filter( Movie.id == Comment.movie_id, User.id == session['user_id'] ).order_by(Comment.addtime.desc()).paginate(page=page, per_page=5) return render_template(\"home/comments.html\", page_data=page_data) 填写模板数据（博主在会员评论模板中另添加了该评论对应点电影名，点击电影名可跳转到此电影播放页面） 123456789101112131415161718192021222324252627&lt;ul class=\"commentList\"&gt;&#123;% for c in page_data.items %&#125;&lt;li class=\"item cl\"&gt; &lt;a&gt; &lt;i class=\"avatar size-L radius\"&gt; &lt;img alt=\"50x50\" src=\"&#123;&#123;url_for('static', filename='uploads/users/'+ c.user.face)&#125;&#125;\" class=\"img-circle\" style=\"border:1px solid #abcdef;width: 50px\"&gt; &lt;/i&gt; &lt;/a&gt; &lt;div class=\"comment-main\"&gt; &lt;header class=\"comment-header\"&gt; &lt;div class=\"comment-meta\"&gt; &lt;a class=\"comment-author\" href=\"&#123;&#123;url_for('home.user')&#125;&#125;\"&gt;&#123;&#123;c.user.name&#125;&#125;&lt;/a&gt; 评论于 &lt;time title=\"&#123;&#123;c.addtime&#125;&#125;\" datetime=\"&#123;&#123;c.addtime&#125;&#125;\"&gt;&#123;&#123;c.addtime&#125;&#125;&lt;/time&gt; 电影《&lt;a href=\"&#123;&#123;url_for('home.play', id=c.movie_id, page=1)&#125;&#125;\"&gt;&#123;&#123;c.movie.title&#125;&#125;&lt;/a&gt;》 &lt;/div&gt; &lt;/header&gt; &lt;div class=\"comment-body\"&gt; &lt;p&gt;&#123;&#123;c.content | safe&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt;&lt;div class=\"col-md-12 text-center\"&gt; &#123;&#123;pg.page(page_data, 'home.comments')&#125;&#125;&lt;/div&gt; 测试会员评论记录显示以及跳转评论的电影 四丶前台管理（电影收藏）1.添加电影收藏 在play模板文件中使用ajax get请求方式调用添加收藏电影视图函数 1234567891011121314151617&lt;script&gt; $(document).ready(function () &#123; $(\"#btn-col\").click(function () &#123; var mid = &#123;&#123;movie.id&#125;&#125;; var uid = &#123;&#123;session['user_id']&#125;&#125;; $.ajax(&#123; url:\"&#123;&#123;url_for('home.moviecol_add')&#125;&#125;\", type:\"GET\", data:\"mid=\"+mid+\"&amp;uid=\"+uid, dataType:\"json\", success:function (res) &#123; &#125; &#125;) &#125;); &#125;);&lt;/script&gt; 定义视图函数，首先获取ajax 发起的请求参数，根据参数查询数据库模型表中是否存在，再进行如下判断，返回模板响应数据 123456789101112131415161718192021222324# 添加电影收藏@home.route('/moviecol/add/', methods=['GET'])@user_login_requireddef moviecol_add(): mid = request.args.get('mid', '') uid = request.args.get('uid', '') moviecol = MovieCol.query.filter_by( movie_id=int(mid), user_id=int(uid) ).count() if moviecol == 1: # 已收藏 data = dict(ok=0) if moviecol == 0: # 未收藏 moviecol = MovieCol( movie_id=int(mid), user_id=int(uid) ) db.session.add(moviecol) db.session.commit() data = dict(ok=1) import json return json.dumps(data) 在play模板文件中根据后端返回的data字典数据，显示页面提示信息，需在收藏电影下定义两种提示样式 1234567891011121314151617181920212223242526272829303132&lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:green;font-size: 18px\" id=\"show_col_msg\"&gt;&lt;/p&gt; &lt;/div&gt;&lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red;font-size: 18px\" id=\"show_col_msg1\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=\"clearfix\"&gt;&lt;/div&gt;&lt;script&gt; $(document).ready(function () &#123; $(\"#btn-col\").click(function () &#123; var mid = &#123;&#123;movie.id&#125;&#125;; var uid = &#123;&#123;session['user_id']&#125;&#125;; $.ajax(&#123; url:\"&#123;&#123;url_for('home.moviecol_add')&#125;&#125;\", type:\"GET\", data:\"mid=\"+mid+\"&amp;uid=\"+uid, dataType:\"json\", success:function (res) &#123; if(res.ok == 1)&#123; $(\"#show_col_msg\").empty(); $(\"#show_col_msg\").append(\"收藏成功！\"); &#125;else&#123; $(\"#show_col_msg1\").empty(); $(\"#show_col_msg1\").append(\"您已收藏！\"); &#125; &#125; &#125;) &#125;); &#125;);&lt;/script&gt; 测试收藏电影功能 2.收藏电影页面数据显示 定义视图函数 1234567891011# 电影收藏@home.route('/moviecol/&lt;int:page&gt;/')@user_login_requireddef moviecol(page=None): if page == None: page = 1 page_data = MovieCol.query.join(Movie).join(User).filter( Movie.id == MovieCol.movie_id, User.id == session['user_id'] ).order_by(MovieCol.addtime.desc()).paginate(page=page, per_page=10) return render_template(\"home/moviecol.html\", page_data=page_data) 修改会员菜单栏收藏电影地址，添加page值 123&lt;a id=\"m-5\" href=\"&#123;&#123;url_for('home.moviecol', page=1)&#125;&#125;\" class=\"list-group-item\"&gt; &lt;span class=\"glyphicon glyphicon-heart\"&gt;&lt;/span&gt;&amp;nbsp;收藏电影&lt;/a&gt; 填写模板数据 1234567891011121314151617181920&lt;div class=\"panel-body\"&gt; &lt;div class=\"col-md-12\"&gt; &#123;% for m in page_data.items %&#125; &lt;div class=\"media\"&gt; &lt;div class=\"media-left\"&gt; &lt;a href=\"&#123;&#123;url_for('home.play', id=m.movie_id, page=1)&#125;&#125;\"&gt; &lt;img class=\"media-object\" src=\"&#123;&#123;url_for('static', filename='uploads/'+m.movie.logo)&#125;&#125;\" width=\"200px\" height=\"280px\" alt=\"&#123;&#123;m.movie.title&#125;&#125;\"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;&#123;&#123;m.movie.title&#125;&#125;&lt;a href=\"&#123;&#123;url_for('home.play', id=m.movie_id, page=1)&#125;&#125;\" class=\"label label-primary pull-right\"&gt;&lt;span class=\"glyphicon glyphicon-play\"&gt;&lt;/span&gt;播放影片&lt;/a&gt;&lt;/h4&gt; &#123;&#123;m.movie.info&#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col-md-12 text-center\" style=\"margin-top:6px;\"&gt; &#123;&#123;pg.page(page_data, 'home.moviecol')&#125;&#125; &lt;/div&gt;&lt;/div&gt; 测试显示收藏电影数据 五丶前台管理（电影弹幕）1.下载插件以及安装flask-redis包 下载弹幕播放器插件 https://github.com/MoePlayer/DPlayer，下载后该文件拷贝到static静态目录下 安装flask-redis包 2.配置flask连接redis数据库，将弹幕消息存储在redis中 在app/init.py中进行如下配置 12app.config['REDIS_URL'] = 'redis://localhost:6379/1'rd = FlaskRedis(app) 3.定义弹幕播放器视图函数（将paly视图代码复制后，将play替换成video） 123456789101112131415161718192021222324252627282930313233343536# 弹幕播放器@home.route('/video/&lt;int:id&gt;/&lt;int:page&gt;/', methods=['GET', 'POST'])def video(id=None, page=None): movie = Movie.query.join(Tag).filter( Tag.id == Movie.tag_id, Movie.id == int(id) ).first_or_404() # 评论数据分页处理 if page == None: page = 1 page_data = Comment.query.join(Movie).join(User).filter( Movie.id == movie.id, User.id == Comment.user_id ).order_by(Comment.addtime.desc()).paginate(page=page, per_page=5) # 播放量+1 movie.playnum += 1 form = CommentForm() # 保存评论内容信息到数据库 if 'user' in session and form.validate_on_submit(): data = form.data comment = Comment( content=data['content'], movie_id=movie.id, user_id=session['user_id'] ) db.session.add(comment) db.session.commit() # 评论量需要+1 movie.commentnum += 1 db.session.add(movie) db.session.commit() flash(\"评论成功\", 'ok') return redirect(url_for('home.video', id=movie.id, page=1)) db.session.add(movie) db.session.commit() return render_template(\"home/video.html\", movie=movie, form=form, page_data=page_data) 4.定义video.html模板文件（复制paly.html模板内容，进行如下修改） 在模板中引入dplayer的配置文件 1234&lt;link rel=\"stylesheet\" href=\"&#123;&#123; url_for('static',filename='dplayer/dist/DPlayer.min.css') &#125;&#125;\"&gt;&lt;script src=\"&#123;&#123; url_for('static',filename='dplayer/plugin/flv.min.js') &#125;&#125;\"&gt;&lt;/script&gt;&lt;script src=\"&#123;&#123; url_for('static',filename='dplayer/plugin/hls.min.js') &#125;&#125;\"&gt;&lt;/script&gt;&lt;script src=\"&#123;&#123; url_for('static',filename='dplayer/dist/DPlayer.min.js') &#125;&#125;\"&gt;&lt;/script&gt; 使用内联式定义样式 12345678&lt;style&gt; .col-lg-1, .col-lg-10, .col-lg-11, .col-lg-12, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-md-1, .col-md-10, .col-md-11, .col-md-12, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-sm-1, .col-sm-10, .col-sm-11, .col-sm-12, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-xs-1, .col-xs-10, .col-xs-11, .col-xs-12, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9&#123; padding-right: 3px; padding-left: 3px; &#125; .dplayer-comment-setting-type&gt;label&#123; display: inline;&#125;&lt;/style&gt; 定义播放器高宽 123&lt;div class=\"col-md-8\"&gt; &lt;div id=\"dplayer1\" style=\"height:500px;width: 774px;\"&gt;&lt;/div&gt;&lt;/div&gt; 定义弹幕js 123456789101112&lt;script&gt; var dp1 = new DPlayer(&#123; element: document.getElementById('dplayer1'), video: &#123; url: \"&#123;&#123; url_for('static',filename='uploads/'+movie.url) &#125;&#125;\", &#125;, danmaku: &#123; id: '&#123;&#123; movie.id &#125;&#125;', api: \"/dm/\" &#125; &#125;);&lt;/script&gt; 5.定义弹幕消息视图 12345678910111213141516171819202122232425262728293031323334353637383940414243# 弹幕@home.route(\"/dm/\", methods=[\"GET\", \"POST\"])def dm(): import json if request.method == \"GET\": #获取弹幕消息队列 id = request.args.get('id') key = \"movie\" + str(id) if rd.llen(key): msgs = rd.lrange(key, 0, 2999) res = &#123; \"code\": 1, \"danmaku\": [json.loads(v) for v in msgs] &#125; else: res = &#123; \"code\": 1, \"danmaku\": [] &#125; resp = json.dumps(res) if request.method == \"POST\": #添加弹幕 data = json.loads(request.get_data()) msg = &#123; \"__v\": 0, \"author\": data[\"author\"], \"time\": data[\"time\"], \"text\": data[\"text\"], \"color\": data[\"color\"], \"type\": data['type'], \"ip\": request.remote_addr, \"_id\": datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\") + uuid.uuid4().hex, \"player\": [ data[\"player\"] ] &#125; res = &#123; \"code\": 1, \"data\": msg &#125; resp = json.dumps(res) rd.lpush(\"movie\" + str(data[\"player\"]), json.dumps(msg)) return Response(resp, mimetype='application/json') 6.测试电影弹幕功能 在浏览器中访问http://127.0.0.1:5000/video/1/1/（跟之前播放地址不同于video和play http://127.0.0.1:5000/play/1/1/），因为没有进行发送弹幕操作，所以弹幕消息队列为空 发送弹幕后查看danmaku的值 查看redis数据库存储的movie1弹幕消息 博主自己发了很多弹幕消息，最终效果如下 六丶代码优化以及bug处理1.头像判断 说明：因为当进行用户注册成功后，不会有用户头像，那么在显示头像的页面中，就需要进行如下判断 play.html以及video.html 1234567&lt;i class=\"avatar size-L radius\"&gt; &#123;% if c.user.face %&#125; &lt;img alt=\"50x50\" src=\"&#123;&#123;url_for('static', filename='uploads/users/'+ c.user.face)&#125;&#125;\" class=\"img-circle\" style=\"border:1px solid #abcdef;width: 50px\"&gt; &#123;% else %&#125; &lt;img alt=\"50x50\" data-src=\"holder.js/50x50\" class=\"img-circle\" style=\"border:1px solid #abcdef;width: 50px\"&gt; &#123;% endif %&#125;&lt;/i&gt; user_list.html 1234567&lt;td&gt; &#123;% if u.face %&#125;&#125; &lt;img src=\"&#123;&#123;url_for('static', filename='uploads/users/'+u.face)&#125;&#125;\" width=\"80\" class=\"img-responsive center-block\" alt=\"\"&gt; &#123;% else %&#125; &lt;img alt=\"50x50\" data-src=\"holder.js/50x50\" class=\"img-circle\" style=\"border:1px solid #abcdef;width: 50px\"&gt; &#123;% endif %&#125;&lt;/td&gt; user_view.html 1234567&lt;td&gt; &#123;% if u.face %&#125;&#125; &lt;img src=\"&#123;&#123;url_for('static', filename='uploads/users/'+user.face)&#125;&#125;\" width=\"50\" class=\"img-responsive\" alt=\"\"&gt; &#123;% else %&#125; &lt;img alt=\"50x50\" data-src=\"holder.js/100x100\" class=\"img-circle\" style=\"border:1px solid #abcdef;width: 50px\"&gt; &#123;% endif %&#125;&lt;/td&gt; 2.关键字搜索分页 说明：当进行电影搜索户，显示与”复仇”有关的电影，共2部，点击分页上的首页或者尾页时，则充值搜索条件，导致显示全部电影与””有关的电影，共15部 在ui目录下创建search_page.html分页模板文件，将admin_page.html内容拷贝进入，修改后如下 123456789101112131415161718192021222324252627&#123;% macro page(data, url) %&#125;&#123;% if data %&#125;&lt;ul class=\"pagination pagination-sm no-margin pull-right\"&gt; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=1)&#125;&#125;?key=&#123;&#123;data.key&#125;&#125;\"&gt;首页&lt;/a&gt;&lt;/li&gt; &#123;% if data.has_prev %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=data.prev_num)&#125;&#125;?key=&#123;&#123;data.key&#125;&#125;\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% else%&#125; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% for p in data.iter_pages() %&#125; &#123;% if p == data.page %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;&#123;&#123;p&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=p)&#125;&#125;\"&gt;&#123;&#123;p&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if data.has_next %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=data.next_num)&#125;&#125;?key=&#123;&#123;data.key&#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% else%&#125; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=data.pages)&#125;&#125;?key=&#123;&#123;data.key&#125;&#125;\"&gt;尾页&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&#123;% endif %&#125;&#123;% endmacro %&#125; 在search.html模板中修改导入的分页模板 1&#123;% import \"ui/search_page.html\" as pg %&#125; 在home/views中找到搜索的视图函数，需要在分页数据page_data中添加名key的键值，这样就不会导致点击首页尾页以及上下页而导致去除掉搜索关键字条件 1page_data.key = key 3.电影右侧播放页面滚动条 说明：当影片内容简介很多时，则出现如下图显示，导致格式扭曲内容显示不全，需要加上滚动条来进行优化 在play.html以及video.html中电影介绍div容器中添加style滚动条属性 1&lt;div class=\"panel-body\" style=\"height:459px;overflow:scroll;\"&gt; 测试显示影片介绍信息 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/89574562","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战","slug":"Flask网站实战","permalink":"https://hellotaogang.github.io/tags/Flask网站实战/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之个性化微电影网站的实战开发（三）","slug":"Flask项目之个性化微电影网站的实战开发（三）","date":"2019-11-12T02:06:54.546Z","updated":"2019-11-13T14:34:37.228Z","comments":true,"path":"2019/11/12/Flask项目之个性化微电影网站的实战开发（三）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/12/Flask项目之个性化微电影网站的实战开发（三）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶后台管理（会员管理） 二丶后台管理（评论管理） 三丶后台管理（收藏管理） 四丶后台管理（修改密码） 五丶后台管理（日志管理） 六丶后台管理（权限管理） 七丶后台管理（角色管理） 八丶后台管理（管理员管理） 九丶访问权限控制","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶后台管理（会员管理） 二丶后台管理（评论管理） 三丶后台管理（收藏管理） 四丶后台管理（修改密码） 五丶后台管理（日志管理） 六丶后台管理（权限管理） 七丶后台管理（角色管理） 八丶后台管理（管理员管理） 九丶访问权限控制 一丶后台管理（会员管理）1.数据准备 导入user表数据 123456789101112insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('鼠','1231','1231@123.com','13888888881','鼠','1f401.png','d32a72bdac524478b7e4f6dfc8394fc0',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('牛','1232','1232@123.com','13888888882','牛','1f402.png','d32a72bdac524478b7e4f6dfc8394fc1',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('虎','1233','1233@123.com','13888888883','虎','1f405.png','d32a72bdac524478b7e4f6dfc8394fc2',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('兔','1234','1234@123.com','13888888884','兔','1f407.png','d32a72bdac524478b7e4f6dfc8394fc3',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('龙','1235','1235@123.com','13888888885','龙','1f409.png','d32a72bdac524478b7e4f6dfc8394fc4',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('蛇','1236','1236@123.com','13888888886','蛇','1f40d.png','d32a72bdac524478b7e4f6dfc8394fc5',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('马','1237','1237@123.com','13888888887','马','1f434.png','d32a72bdac524478b7e4f6dfc8394fc6',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('羊','1238','1238@123.com','13888888888','羊','1f411.png','d32a72bdac524478b7e4f6dfc8394fc7',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('猴','1239','1239@123.com','13888888889','猴','1f412.png','d32a72bdac524478b7e4f6dfc8394fc8',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('鸡','1240','1240@123.com','13888888891','鸡','1f413.png','d32a72bdac524478b7e4f6dfc8394fc9',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('狗','1241','1241@123.com','13888888892','狗','1f415.png','d32a72bdac524478b7e4f6dfc8394fd0',now());insert into user(name,pwd,email,phone,info,face,uuid,addtime) values('猪','1242','1242@123.com','13888888893','猪','1f416.png','d32a72bdac524478b7e4f6dfc8394fd1',now()); 查看表user数据 将会员头像图片文件拷贝到uploads目录下 2.会员列表页数据显示（项目做到这里，如果看明白的话，列表页的逻辑分分钟搞定） 定义视图函数 12345678# 会员列表@admin.route('/user/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef user_list(page=None): if page == None: page = 1 page_data = User.query.order_by(User.addtime.desc()).paginate(page=page, per_page=5) return render_template(\"admin/user_list.html\", page_data=page_data) 编写列表页链接地址 1234567&lt;ul class=\"treeview-menu\"&gt; &lt;li id=\"g-5-1\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.user_list', page=1)&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 会员列表 &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 在模板文件中进行数据块填写以及分页 123456789101112131415161718192021222324252627282930 &#123;% for u in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;u.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;u.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;u.email&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;u.phone&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;img src=\"&#123;&#123;url_for('static', filename='uploads/users/'+u.face)&#125;&#125;\" width=\"80\" class=\"img-responsive center-block\" alt=\"\"&gt; &lt;/td&gt; &lt;td&gt;正常/冻结&lt;/td&gt; &lt;td&gt;&#123;&#123;u.addtime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"label label-success\" href=\"&#123;&#123;url_for('admin.user_view')&#125;&#125;\"&gt;查看&lt;/a&gt; &amp;nbsp; &lt;a class=\"label label-info\"&gt;解冻&lt;/a&gt; &amp;nbsp; &lt;a class=\"label label-warning\"&gt;冻结&lt;/a&gt; &amp;nbsp; &lt;a class=\"label label-danger\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &lt;ul class=\"pagination pagination-sm no-margin pull-right\"&gt; &#123;&#123;pg.page(page_data, 'admin.user_list')&#125;&#125; &lt;/ul&gt;&lt;/div&gt; 测试会员列表页数据显示 3.会员详情页面数据显示 定义视图函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 会员详情@admin.route('/user/view/&lt;int:id&gt;/', methods=['GET', 'POST'])@admin_login_requireddef user_view(id): user = User.query.filter_by(id=id).first_or_404() return render_template(\"admin/user_view.html\", user=user)填写摸吧数据块&lt;table class=\"table table-hover\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"td_bd\"&gt;编号：&lt;/td&gt; &lt;td&gt;&#123;&#123;user.id&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_bd\"&gt;昵称：&lt;/td&gt; &lt;td&gt;&#123;&#123;user.name&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_bd\"&gt;邮箱：&lt;/td&gt; &lt;td&gt;&#123;&#123;user.email&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_bd\"&gt;手机：&lt;/td&gt; &lt;td&gt;&#123;&#123;user.phone&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_bd\"&gt;头像：&lt;/td&gt; &lt;td&gt; &lt;img src=\"&#123;&#123;url_for('static', filename='uploads/users/'+user.face)&#125;&#125;\" width=\"50\" class=\"img-responsive\" alt=\"\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_bd\"&gt;注册时间：&lt;/td&gt; &lt;td&gt; &#123;&#123;user.addtime&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_bd\"&gt;唯一标志符：&lt;/td&gt; &lt;td&gt; &#123;&#123;user.uuid&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_bd\"&gt;个性简介：&lt;/td&gt; &lt;td&gt; &#123;&#123;user.info&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 定义查看按钮链接地址 1&lt;a class=\"label label-success\" href=\"&#123;&#123;url_for('admin.user_view', id=u.id)&#125;&#125;\"&gt;查看&lt;/a&gt; 测试显示会员详情页面数据 4.删除会员功能 定义视图函数 123456789# 删除会员@admin.route('/user/del/&lt;int:id&gt;/', methods=['GET'])@admin_login_requireddef user_del(id=None): user = User.query.filter_by(id=id).first_or_404() db.session.delete(user) db.session.commit() flash(\"删除会员成功！\", \"ok\") return redirect(url_for('admin.user_list', page=1)) 定义删除功能链接地址 1&lt;a class=\"label label-danger\" href=\"&#123;&#123;url_for('admin.user_del', id=u.id)&#125;&#125;\"&gt;删除&lt;/a&gt; 测试会员删除功能 二丶后台管理（评论管理）1.数据准备 导入comment表数据 123456789insert into comment(movie_id,user_id,content,addtime) values(7,1,\"好看\",now());insert into comment(movie_id,user_id,content,addtime) values(7,2,\"不错\",now());insert into comment(movie_id,user_id,content,addtime) values(7,3,\"经典\",now());insert into comment(movie_id,user_id,content,addtime) values(7,4,\"给力\",now());insert into comment(movie_id,user_id,content,addtime) values(8,5,\"难看\",now());insert into comment(movie_id,user_id,content,addtime) values(8,6,\"无聊\",now());insert into comment(movie_id,user_id,content,addtime) values(8,7,\"乏味\",now());insert into comment(movie_id,user_id,content,addtime) values(8,8,\"无感\",now());ALTER TABLE comment auto_increment=1; 查询数据库comment表数据 2.评论列表页数据显示 定义视图函数 1234567891011# 评论列表@admin.route('/comment/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef comment_list(page=None): if page == None: page = 1 page_data = Comment.query.join(Movie).join(User).filter( Movie.id == Comment.movie_id, User.id == Comment.user_id ).order_by(Comment.addtime.desc()).paginate(page=page, per_page=5) return render_template(\"admin/comment_list.html\", page_data=page_data) 修改列表页链接地址 1234567&lt;ul class=\"treeview-menu\"&gt; &lt;li id=\"g-6-1\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.comment_list', page=1)&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 评论列表 &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 填写模板数据块内容 1234567891011121314151617181920212223&lt;div class=\"box-body box-comments\"&gt; &#123;% for c in page_data.items%&#125; &lt;div class=\"box-comment\"&gt; &lt;img class=\"img-circle img-sm\" src=\"&#123;&#123;url_for('static', filename='uploads/users/'+c.user.face)&#125;&#125;\" alt=\"User Image\"&gt; &lt;div class=\"comment-text\"&gt; &lt;span class=\"username\"&gt; &#123;&#123;c.user.name&#125;&#125; &lt;span class=\"text-muted pull-right\"&gt; &lt;i class=\"fa fa-calendar\" aria-hidden=\"true\"&gt;&lt;/i&gt; &amp;nbsp; &#123;&#123;c.addtime&#125;&#125; &lt;/span&gt; &lt;/span&gt; 关于电影&lt;a&gt;《&#123;&#123;c.movie.title&#125;&#125;》&lt;/a&gt;的评论：&#123;&#123;c.content&#125;&#125; &lt;br&gt;&lt;a class=\"label label-danger pull-right\"&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.comment_list')&#125;&#125;&lt;/div&gt; 测试评论列表页数据显示 3.删除评论 定义视图函数 123456789# 删除评论@admin.route('/comment/del/&lt;int:id&gt;/', methods=['GET'])@admin_login_requireddef comment_del(id=None): comment = Comment.query.filter_by(id=id).first_or_404() db.session.delete(comment) db.session.commit() flash(\"删除评论成功！\", \"ok\") return redirect(url_for('admin.comment_list', page=1)) 定义删除按钮链接地址 1&lt;a href=\"&#123;&#123;url_for('admin.comment_del', id=c.id)&#125;&#125;\" class=\"label label-danger pull-right\"&gt;删除&lt;/a&gt; 测试删除评论功能（编辑功能没有意义） 三丶后台管理（收藏管理）1.数据准备 导入moviecol表数据 123456789insert into moviecol(movie_id,user_id,addtime) values(7,1,now());insert into moviecol(movie_id,user_id,addtime) values(7,2,now());insert into moviecol(movie_id,user_id,addtime) values(7,3,now());insert into moviecol(movie_id,user_id,addtime) values(7,4,now());insert into moviecol(movie_id,user_id,addtime) values(8,5,now());insert into moviecol(movie_id,user_id,addtime) values(8,6,now());insert into moviecol(movie_id,user_id,addtime) values(8,7,now());insert into moviecol(movie_id,user_id,addtime) values(8,8,now());ALTER TABLE moviecol auto_increment=1; 查看数据库moviecol表数据 2.收藏列表数据显示 定义视图函数 1234567891011# 收藏列表@admin.route('/moviecol/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef moviecol_list(page=None): if page == None: page = 1 page_data = MovieCol.query.join(Movie).join(User).filter( Movie.id == MovieCol.movie_id, User.id == MovieCol.user_id ).order_by(MovieCol.addtime.desc()).paginate(page=page, per_page=5) return render_template(\"admin/moviecol_list.html\", page_data=page_data) 修改收藏列表链接地址 1234567&lt;ul class=\"treeview-menu\"&gt; &lt;li id=\"g-7-1\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.moviecol_list', page=1)&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 收藏列表 &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 填充模板数据块 1234567891011121314151617181920212223242526272829&lt;div class=\"box-body table-responsive no-padding\"&gt; &lt;table class=\"table table-hover\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;电影&lt;/th&gt; &lt;th&gt;用户&lt;/th&gt; &lt;th&gt;添加时间&lt;/th&gt; &lt;th&gt;操作事项&lt;/th&gt; &lt;/tr&gt; &#123;% for m in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;m.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.movie.title&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.user.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.addtime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"label label-success\"&gt;编辑&lt;/a&gt; &amp;nbsp; &lt;a class=\"label label-danger\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.moviecol_list')&#125;&#125;&lt;/div&gt; 测试显示收藏列表页面数 3.删除电影收藏 定义视图函数 123456789# 删除收藏@admin.route('/moviecol/del/&lt;int:id&gt;/', methods=['GET'])@admin_login_requireddef moviecol_del(id=None): moviecol = MovieCol.query.filter_by(id=id).first_or_404() db.session.delete(moviecol) db.session.commit() flash(\"删除收藏成功！\", \"ok\") return redirect(url_for('admin.moviecol_list', page=1)) 定义删除按钮链接地址 1&lt;a href=\"&#123;&#123;url_for('admin.moviecol_del', id=m.id)&#125;&#125;\" class=\"label label-danger\"&gt;删除&lt;/a&gt; 测试删除收藏功能（编辑功能这里没有存在的意义） 四丶后台管理（修改密码）1.修改密码页面数据显示 定义视图函数 12345678# 修改密码@admin.route('/pwd/', methods=['GET', 'POST'])@admin_login_requireddef pwd(): form = PwdForm() if form.validate_on_submit(): data = form.data return render_template(\"admin/pwd.html\", form=form) 定义表单类 123456789101112131415161718192021222324252627282930class PwdForm(FlaskForm): \"\"\"修改密码表单\"\"\" old_pwd = PasswordField( label=\"旧密码\", validators=[ DataRequired(\"请输入旧密码！\") ], description=\"旧密码\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入旧密码！\", &#125; ) new_pwd = PasswordField( label=\"新密码\", validators=[ DataRequired(\"请输入新密码！\") ], description=\"新密码\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入新密码！\", &#125; ) submit = SubmitField( '修改', render_kw=&#123; \"class\": \"btn btn-primary\", &#125; ) 填写模板数据块数据 1234567891011121314151617181920212223242526&lt;form novalidate method=\"post\" role=\"form\"&gt; &lt;div class=\"box-body\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_pwd\"&gt;&#123;&#123;form.old_pwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.old_pwd&#125;&#125; &#123;% for error in form.old_pwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;span style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_newpwd\"&gt;&#123;&#123;form.new_pwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.new_pwd&#125;&#125; &#123;% for error in form.new_pwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;span style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123; form.submit &#125;&#125; &#123;&#123; form.csrf_token &#125;&#125; &lt;/div&gt;&lt;/form&gt; 测试显示修改密码页面数据 四丶后台管理（修改密码）1.修改密码页面数据显示 定义视图函数 12345678# 修改密码@admin.route('/pwd/', methods=['GET', 'POST'])@admin_login_requireddef pwd(): form = PwdForm() if form.validate_on_submit(): data = form.data return render_template(\"admin/pwd.html\", form=form) 定义表单类 123456789101112131415161718192021222324252627282930class PwdForm(FlaskForm): \"\"\"修改密码表单\"\"\" old_pwd = PasswordField( label=\"旧密码\", validators=[ DataRequired(\"请输入旧密码！\") ], description=\"旧密码\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入旧密码！\", &#125; ) new_pwd = PasswordField( label=\"新密码\", validators=[ DataRequired(\"请输入新密码！\") ], description=\"新密码\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入新密码！\", &#125; ) submit = SubmitField( '修改', render_kw=&#123; \"class\": \"btn btn-primary\", &#125; ) 填写模板数据块数据 1234567891011121314151617181920212223242526&lt;form novalidate method=\"post\" role=\"form\"&gt; &lt;div class=\"box-body\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_pwd\"&gt;&#123;&#123;form.old_pwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.old_pwd&#125;&#125; &#123;% for error in form.old_pwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;span style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_newpwd\"&gt;&#123;&#123;form.new_pwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.new_pwd&#125;&#125; &#123;% for error in form.new_pwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;span style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123; form.submit &#125;&#125; &#123;&#123; form.csrf_token &#125;&#125; &lt;/div&gt;&lt;/form&gt; 测试显示修改密码页面数据 2.校验旧密码 在PwdFrom表单类中定义校验密码函数 123456789def validate_old_pwd(self, field): from flask import session pwd = field.data name = session[\"admin\"] admin = Admin.query.filter_by( name=name ).first() if not admin.check_pwd(pwd): raise ValidationError(\"旧密码错误！\") 测试旧密码校验（第一次输入正确密码第二次输入错误密码） 3.修改密码 定义视图函数，修改密码成功则跳转执行的是退出视图而不是登录视图，因为退出logout视图函数会清空session的值，并跳转到登录页，这才是符合逻辑的 1234567891011121314# 修改密码@admin.route('/pwd/', methods=['GET', 'POST'])@admin_login_requireddef pwd(): form = PwdForm() if form.validate_on_submit(): data = form.data admin = Admin.query.filter_by(name=session['admin']).first() admin.pwd = generate_password_hash(data['new_pwd']) db.session.add(admin) db.session.commit() flash(\"修改密码成功，请重新登录\", \"ok\") return redirect(url_for('admin.logout')) return render_template(\"admin/pwd.html\", form=form) 在login.html模板中获取闪现成功消息，因为修改成功后立即跳转到登录页，所以要在登录页面显示修改密码成功的消息，那么对于登录功能来说，只需要显示错误提示即可，因为即使你定义了捕获成功ok的筛选器，也不会在登录页页面显示出登录成功提示信息，以为一旦登录成功则立即跳转的主页index 1234567&#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;&#123;% endfor %&#125; 测试修改密码功能 五丶后台管理（日志管理）1.更改admin.html模板中的数据（用户名丶头像以及面板时间） 在views中构建上下文处理器（全局），用于显示面板时间 1234567# 上下应用处理器@admin.context_processordef tpl_extra(): data = dict( online_time=datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") ) return data 在admin.html模板文件中进行数据填坑（以下为示例代码，其他坑对应都是一样的） 12345678&lt;li class=\"user-header\"&gt; &lt;img src=\"&#123;&#123;url_for('static', filename='admin/dist/img/tg.jpg')&#125;&#125;\" class=\"img-circle\" alt=\"User Image\"&gt; &lt;p&gt; &#123;&#123;session['admin']&#125;&#125; &lt;small&gt;&#123;&#123;online_time&#125;&#125;&lt;/small&gt; &lt;/p&gt;&lt;/li&gt; 刷新后台管理页面http://127.0.0.1:5000/admin/ 2.操作日志列表 保存登录的管理员编号id到session中，登出时需要删除管理员id 12session['admin_id'] = admin.idsession.pop(\"admin_id\", None) 博主这里演示将标签管理中的增删改操作保存到操作日志表中（其他的管理基本逻辑一样，在目标视图函数中添加以下代码即可） 123456789101112131415161718192021222324# 添加标签oplog = OpLog( admin_id = session['admin_id'], ip = request.remote_addr, reason = \"添加标签&lt;%s&gt;\" % data['name'])db.session.add(oplog)db.session.commit()# 删除标签oplog = OpLog( admin_id=session['admin_id'], ip=request.remote_addr, reason=\"删除标签&lt;%s&gt;\" % tag.name)db.session.add(oplog)db.session.commit()# 修改标签oplog = OpLog( admin_id=session['admin_id'], ip=request.remote_addr, reason=\"修改标签&lt;%s&gt;\" % tag.name)db.session.add(oplog)db.session.commit() 测试对标签管理中的数据进行增删改操作，是否写入到数据库oplog表中 定义视图函数，显示操作日志列表页数据 12345678910# 操作日志@admin.route('/oplog/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef oplog_list(page=None): if page == None: page = 1 page_data = OpLog.query.join(Admin).filter( Admin.id == OpLog.admin_id, ).order_by(OpLog.addtime.desc()).paginate(page=page, per_page=5) return render_template(\"admin/oplog_list.html\", page_data=page_data) 修改操作日志列表页链接地址 12345&lt;li id=\"g-8-1\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.oplog_list', page=1)&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 操作日志列表 &lt;/a&gt;&lt;/li&gt; 填写模板数据 12345678910111213141516171819202122232425&lt;div class=\"box-body table-responsive no-padding\"&gt; &lt;table class=\"table table-hover\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;管理员&lt;/th&gt; &lt;th&gt;操作时间&lt;/th&gt; &lt;th&gt;操作原因&lt;/th&gt; &lt;th&gt;操作IP&lt;/th&gt; &lt;/tr&gt; &#123;% for o in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;o.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;o.admin.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;o.addtime&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;o.reason&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;o.ip&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.oplog_list')&#125;&#125;&lt;/div&gt; 测试显示操作日志列表页数据 3.管理员登录日志列表 在登录视图函数中保存数据到amdinlog表中 123456adminlog = AdminLog( admin_id=admin.id, ip=request.remote_addr,)db.session.add(adminlog)db.session.commit() 测试退出登录后，查看数据库adminlog表数据是否生成 定义视图函数，显示管理员登录日志列表页数据 12345678910# 管理员登录日志列表@admin.route('/adminloginlog/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef adminloginlog_list(page=None): if page == None: page = 1 page_data = AdminLog.query.join(Admin).filter( Admin.id == AdminLog.admin_id ).order_by(AdminLog.addtime.desc()).paginate(page=page, per_page=5) return render_template(\"admin/adminloginlog_list.html\", page_data=page_data) 修改管理员登录日志列表页链接地址 12345&lt;li id=\"g-8-2\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.adminloginlog_list', page=1)&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 管理员登录日志列表 &lt;/a&gt;&lt;/li&gt; 填写模板数据 1234567891011121314151617181920212223&lt;div class=\"box-body table-responsive no-padding\"&gt; &lt;table class=\"table table-hover\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;管理员&lt;/th&gt; &lt;th&gt;登录时间&lt;/th&gt; &lt;th&gt;登录IP&lt;/th&gt; &lt;/tr&gt; &#123;% for a in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;a.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.admin.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.addtime&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.ip&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.adminloginlog_list')&#125;&#125;&lt;/div&gt; 测试显示管理员登录日志列表页数据 4.会员登录日志列表 向userlog表导入测试数据 123456789insert into userlog(user_id,ip,addtime) values(1,\"192.168.4.1\",now());insert into userlog(user_id,ip,addtime) values(2,\"192.168.4.2\",now());insert into userlog(user_id,ip,addtime) values(3,\"192.168.4.3\",now());insert into userlog(user_id,ip,addtime) values(4,\"192.168.4.4\",now());insert into userlog(user_id,ip,addtime) values(5,\"192.168.4.5\",now());insert into userlog(user_id,ip,addtime) values(6,\"192.168.4.6\",now());insert into userlog(user_id,ip,addtime) values(7,\"192.168.4.7\",now());insert into userlog(user_id,ip,addtime) values(8,\"192.168.4.8\",now());insert into userlog(user_id,ip,addtime) values(9,\"192.168.4.9\",now()); 查看数据库userlog表数据 定义视图函数，显示会员登录日志列表页数据 12345678910# 会员登录日志@admin.route('/userloginlog/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef userloginlog_list(page=None): if page == None: page=1 page_data = UserLog.query.join(User).filter( User.id == UserLog.user_id ).order_by(UserLog.addtime.desc()).paginate(page=page, per_page=10) return render_template(\"admin/userloginlog_list.html\", page_data=page_data) 修改会员登录日志列表页链接地址 12345&lt;li id=\"g-8-3\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.userloginlog_list', page=1)&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 会员登录日志列表 &lt;/a&gt;&lt;/li&gt; 填写模板数据 1234567891011121314151617181920212223&lt;div class=\"box-body table-responsive no-padding\"&gt; &lt;table class=\"table table-hover\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;会员&lt;/th&gt; &lt;th&gt;登录时间&lt;/th&gt; &lt;th&gt;登录IP&lt;/th&gt; &lt;/tr&gt; &#123;% for a in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;a.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.user.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.addtime&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.ip&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.userloginlog_list')&#125;&#125;&lt;/div&gt; 测试显示会员登录日志列表页数据 六丶后台管理（权限管理）1.添加权限 定义form表单 123456789101112131415161718192021222324252627282930class AuthForm(FlaskForm): \"\"\"权限管理表单\"\"\" name = StringField( label=\"权限名称\", validators=[ DataRequired(\"请输入权限名称！\") ], description=\"权限名称\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入权限名称！\" &#125; ) url = StringField( label=\"权限地址\", validators=[ DataRequired(\"请输入权限地址！\") ], description=\"权限地址\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入权限地址！\" &#125; ) submit = SubmitField( '提交', render_kw=&#123; \"class\": \"btn btn-primary\", &#125; ) 定义视图函数 12345678# 添加权限@admin.route('/auth/add', methods=['GET', 'POST'])@admin_login_requireddef auth_add(): form = AuthForm() if form.validate_on_submit(): data = form.data return render_template(\"admin/auth_add.html\", form=form) 修改模板数据 1234567891011121314151617181920212223242526&lt;form novalidate role=\"form\" method=\"post\"&gt; &lt;div class=\"box-body\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_name\"&gt;&#123;&#123;form.name.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.name&#125;&#125; &#123;% for error in form.name.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_url\"&gt;&#123;&#123;form.url.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.url&#125;&#125; &#123;% for error in form.url.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123; form.submit &#125;&#125; &#123;&#123; form.csrf_token &#125;&#125; &lt;/div&gt;&lt;/form&gt; 测试显示添加权限页面 视图函数中编写添加权限逻辑代码 123456789101112131415# 添加权限@admin.route('/auth/add', methods=['GET', 'POST'])@admin_login_requireddef auth_add(): form = AuthForm() if form.validate_on_submit(): data = form.data auth = Auth( name=data['name'], url=data['url'] ) db.session.add(auth) db.session.commit() flash(\"添加权限成功！\", \"ok\") return render_template(\"admin/auth_add.html\", form=form) 测试添加标签功能 2.显示权限列表页数据（权限管理的增删改查与权限管理一模一样） 定义视图函数 12345678# 权限列表@admin.route('/auth/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef auth_list(page=None): if page is None: page = 1 page_data = Auth.query.order_by(Auth.addtime.desc()).paginate(page=page, per_page=5) return render_template(\"admin/auth_list.html\", page_data=page_data) 修改权限列表页链接地址 12345&lt;li id=\"g-9-2\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.auth_list', page=1)&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 权限列表 &lt;/a&gt;&lt;/li&gt; 定义模板数据 123456789101112131415161718192021222324252627282930313233343536&lt;div class=\"box-body table-responsive no-padding\"&gt; &#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;table class=\"table table-hover\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;th&gt;添加时间&lt;/th&gt; &lt;th&gt;操作事项&lt;/th&gt; &lt;/tr&gt; &#123;% for a in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;a.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.url&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.addtime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"label label-success\"&gt;编辑&lt;/a&gt; &amp;nbsp; &lt;a class=\"label label-danger\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.auth_list')&#125;&#125;&lt;/div&gt; 测试显示权限列表页数据 3.删除权限 定义视图函数 12345678910111213141516# 删除权限@admin.route('/auth/del/&lt;int:id&gt;/', methods=['GET'])@admin_login_requireddef auth_del(id=None): auth = Auth.query.filter_by(id=id).first_or_404() db.session.delete(auth) db.session.commit() flash(\"删除权限成功！\", \"ok\") oplog = OpLog( admin_id=session['admin_id'], ip=request.remote_addr, reason=\"删除权限&lt;%s&gt;\" % auth.name ) db.session.add(oplog) db.session.commit() return redirect(url_for('admin.auth_list', page=1)) 定义删除权限功能链接地址 1&lt;a href=\"&#123;&#123;url_for('admin.auth_del', id=a.id)&#125;&#125;\" class=\"label label-danger\"&gt;删除&lt;/a&gt; 测试删除权限功能 4.修改权限 定义视图函数 12345678910111213141516171819202122232425# 修改权限@admin.route('/auth/update/&lt;int:id&gt;', methods=['GET', 'POST'])@admin_login_requireddef auth_update(id): auth = Auth.query.get_or_404(id) form = AuthForm() if form.validate_on_submit(): data = form.data auth_count = Auth.query.filter_by(name=data[\"name\"]).count() if auth_count == 1 and auth.name == data['name']: flash(\"名称已经存在！\", \"err\") return redirect(url_for('admin.auth_update', id=id)) auth.name = data['name'] db.session.add(auth) db.session.commit() flash(\"修改权限成功！\", \"ok\") oplog = OpLog( admin_id=session['admin_id'], ip=request.remote_addr, reason=\"修改权限&lt;%s&gt;\" % auth.name ) db.session.add(oplog) db.session.commit() return redirect(url_for(\"admin.auth_list\", page=1)) return render_template(\"admin/auth_update.html\", form=form, auth=auth) 创建auth_update.html模板文件（将添加权限模板文件内容拷贝过来进行名称修改即可） 12345678910111213141516171819202122232425262728293031323334353637383940&lt;form novalidate role=\"form\" method=\"post\"&gt; &lt;div class=\"box-body\"&gt; &#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% for msg in get_flashed_messages(category_filter=[\"err\"]) %&#125; &lt;div class=\"alert alert-danger alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_name\"&gt;&#123;&#123;form.name.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.name(value=auth.name)&#125;&#125; &#123;% for error in form.name.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_url\"&gt;&#123;&#123;form.url.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.url(value=auth.url)&#125;&#125; &#123;% for error in form.url.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123; form.submit &#125;&#125; &#123;&#123; form.csrf_token &#125;&#125; &lt;/div&gt;&lt;/form&gt; 定义修改权限功能链接地址 1&lt;a href=\"&#123;&#123;url_for('admin.auth_update', id=a.id)&#125;&#125;\" class=\"label label-success\"&gt;编辑&lt;/a&gt; 测试修改权限功能 七丶后台管理（角色管理）1.添加角色 定义视图函数 1234567891011121314151617# 添加角色@admin.route('/role/add', methods=['GET', 'POST'])@admin_login_requireddef role_add(): form = RoleForm() if form.validate_on_submit(): data = form.data # print(data) # &#123;'name': '标签管理员', 'auths': [1, 2, 3], 'submit': True, 'csrf_token': 'IjA.....'&#125; role = Role( name=data['name'], auths=','.join(str(a) for a in data['auths']) ) db.session.add(role) db.session.commit() flash(\"添加角色成功！\", \"ok\") return render_template(\"admin/role_add.html\", form=form) 填写模板数据 1234567891011121314151617181920212223242526272829303132333435&lt;form novalidate role=\"form\" method=\"post\"&gt; &lt;div class=\"box-body\"&gt; &#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_name\"&gt;&#123;&#123;form.name.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.name&#125;&#125; &#123;% for error in form.name.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\" id=\"auth_list\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;label&gt;&#123;&#123;form.auths.label&#125;&#125;&lt;/label&gt; &lt;/div&gt; &#123;&#123;form.auths&#125;&#125; &#123;% for error in form.auths.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123; form.submit &#125;&#125; &#123;&#123; form.csrf_token &#125;&#125; &lt;/div&gt;&lt;/form&gt; 测试添加角色功能 2.显示角色列表页数据 定义视图函数 12345678# 角色列表@admin.route('/role/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef role_list(page=None): if page is None: page = 1 page_data = Role.query.order_by(Role.addtime.desc()).paginate(page=page, per_page=5) return render_template(\"admin/role_list.html\", page_data=page_data) 修改角色列表页链接地址 12345&lt;li id=\"g-10-2\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.role_list', page=1)&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 角色列表 &lt;/a&gt;&lt;/li&gt; 填写模板数据 123456789101112131415161718192021222324252627&lt;div class=\"box-body table-responsive no-padding\"&gt; &lt;table class=\"table table-hover\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;角色名称&lt;/th&gt; &lt;th&gt;添加时间&lt;/th&gt; &lt;th&gt;操作事项&lt;/th&gt; &lt;/tr&gt; &#123;% for r in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;r.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;r.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;r.addtime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"label label-success\"&gt;编辑&lt;/a&gt; &amp;nbsp; &lt;a class=\"label label-danger\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.role_list')&#125;&#125;&lt;/div&gt; 测试显示角色列表页数据 3.角色删除功能 定义视图函数 12345678910111213141516# 删除角色@admin.route('/role/del/&lt;int:id&gt;/', methods=['GET'])@admin_login_requireddef role_del(id=None): role = Role.query.filter_by(id=id).first_or_404() db.session.delete(role) db.session.commit() flash(\"删除角色成功！\", \"ok\") oplog = OpLog( admin_id=session['admin_id'], ip=request.remote_addr, reason=\"删除角色&lt;%s&gt;\" % role.name ) db.session.add(oplog) db.session.commit() return redirect(url_for('admin.role_list', page=1)) 定义删除功能链接地址 1&lt;a href=\"&#123;&#123;url_for('admin.role_del', id=r.id)&#125;&#125;\" class=\"label label-danger\"&gt;删除&lt;/a&gt; 测试删除角色功能 4.角色修改功能 定义视图函数 12345678910111213141516171819202122232425# 修改角色@admin.route('/role/update/&lt;int:id&gt;', methods=['GET', 'POST'])@admin_login_requireddef role_update(id): role = Role.query.get_or_404(id) form = RoleForm() if request.method == 'GET': nums = role.auths.split(',') #['1','2','3'] form.auths.data = [int(x) for x in nums] #[1,2,3] if form.validate_on_submit(): data = form.data role.name = data['name'] role.auths = ','.join(str(a) for a in data['auths']) db.session.add(role) db.session.commit() flash(\"修改角色成功！\", \"ok\") oplog = OpLog( admin_id=session['admin_id'], ip=request.remote_addr, reason=\"修改角色&lt;%s&gt;\" % role.name ) db.session.add(oplog) db.session.commit() return redirect(url_for(\"admin.role_list\", page=1)) return render_template(\"admin/role_update.html\", form=form, role=role) 定义修改角色功能链接地址 1&lt;a href=\"&#123;&#123;url_for('admin.role_update', id=r.id)&#125;&#125;\" class=\"label label-success\"&gt;编辑&lt;/a&gt; 创建role_update.html模板文件 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;form novalidate role=\"form\" method=\"post\"&gt; &lt;div class=\"box-body\"&gt; &#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% for msg in get_flashed_messages(category_filter=[\"err\"]) %&#125; &lt;div class=\"alert alert-danger alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_name\"&gt;&#123;&#123;form.name.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.name(value=role.name)&#125;&#125; &#123;% for error in form.name.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\" id=\"auth_list\"&gt; &lt;div class=\"col-md-12\"&gt; &lt;label&gt;&#123;&#123;form.auths.label&#125;&#125;&lt;/label&gt; &lt;/div&gt; &#123;&#123;form.auths&#125;&#125; &#123;% for error in form.auths.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123; form.submit &#125;&#125; &#123;&#123; form.csrf_token &#125;&#125; &lt;/div&gt;&lt;/form&gt; 测试角色修改功能 八丶后台管理（管理员管理）1.添加管理员 定义视图函数 12345678# 添加管理员@admin.route('/admin/add', methods=['GET', 'POST'])@admin_login_requireddef admin_add(): form = AdminForm() if form.validate_on_submit(): data = form.data return render_template(\"admin/admin_add.html\", form=form) 填写模板数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;form novalidate role=\"form\" method=\"post\"&gt; &lt;div class=\"box-body\"&gt; &#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_name\"&gt;&#123;&#123;form.name.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.name&#125;&#125; &#123;% for error in form.name.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_pwd\"&gt;&#123;&#123;form.pwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.pwd&#125;&#125; &#123;% for error in form.pwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_re_pwd\"&gt;&#123;&#123;form.repwd.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.repwd&#125;&#125; &#123;% for error in form.repwd.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_role_id\"&gt;&#123;&#123;form.role_id.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.role_id&#125;&#125; &#123;% for error in form.role_id.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123; form.submit &#125;&#125; &#123;&#123; form.csrf_token &#125;&#125; &lt;/div&gt;&lt;/form&gt; 刷新添加管理员页面 在视图函数中完成添加管理员代码逻辑 1234567891011121314151617# 添加管理员@admin.route('/admin/add', methods=['GET', 'POST'])@admin_login_requireddef admin_add(): form = AdminForm() if form.validate_on_submit(): data = form.data admin = Admin( name=data['name'], pwd=generate_password_hash(data['pwd']), role_id=data['role_id'], is_super=1 ) db.session.add(admin) db.session.commit() flash(\"添加管理员成功！\", \"ok\") return render_template(\"admin/admin_add.html\", form=form) 测试添加管理员功能 2.显示管理员列表页数据 定义视图函数 12345678910# 管理员列表@admin.route(&apos;/admin/list/&lt;int:page&gt;/&apos;, methods=[&apos;GET&apos;])@admin_login_requireddef admin_list(page=None): if page is None: page = 1 page_data = Admin.query.join(Role).filter( Role.id == Admin.role_id ).order_by(Admin.addtime.desc()).paginate(page=page, per_page=5) return render_template(&quot;admin/admin_list.html&quot;, page_data=page_data) 修改管理员列表页链接地址 12345&lt;li id=\"g-11-2\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.admin_list', page=1)&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 管理员列表 &lt;/a&gt;&lt;/li&gt; 填写模板数据 1234567891011121314151617181920212223242526272829&lt;div class=\"box-body table-responsive no-padding\"&gt; &lt;table class=\"table table-hover\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;管理员名称&lt;/th&gt; &lt;th&gt;管理员类型&lt;/th&gt; &lt;th&gt;管理员角色&lt;/th&gt; &lt;th&gt;添加时间&lt;/th&gt; &lt;/tr&gt; &#123;% for a in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;a.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.name&#125;&#125;&lt;/td&gt; &#123;% if a.is_super == 1 %&#125; &lt;td&gt;普通管理员&lt;/td&gt; &#123;% else %&#125; &lt;td&gt;超级管理员&lt;/td&gt; &#123;% endif %&#125; &lt;td&gt;&#123;&#123;a.role.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;a.addtime&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.admin_list')&#125;&#125;&lt;/div&gt; 测试显示管理员列表页数据 九丶访问权限控制1.定义访问权限控制器 123456789101112131415161718# 权限控制装饰器def admin_auth(f): @wraps(f) def decorated_function(*args, **kwargs): admin = Admin.query.join(Role).filter( Role.id == Admin.role_id, Admin.id == session[\"admin_id\"] ).first() auths = admin.role.auths nums = auths.split(',') auths = [int(x) for x in nums] auth_list = Auth.query.all() urls = [v.url for v in auth_list for val in auths if val == v.id] rule = request.url_rule if str(rule) not in urls: abort(404) return f(*args, **kwargs) return decorated_function 2.在视图函数上添加访问权限控制器（例如标签管理中添加修改删除以及列表） 12345# 添加标签@admin.route('/tag/add', methods=['GET', 'POST'])@admin_login_required@admin_authdef tag_add(): 3.查看数据库表 4.使用test1管理员账号进行测试（从数据库表字段中可以知道该账号只能添加标签获取删除标签，无法修改以及访问标签列表） ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/89445426","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战","slug":"Flask网站实战","permalink":"https://hellotaogang.github.io/tags/Flask网站实战/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之个性化微电影网站的实战开发（二）","slug":"Flask项目之个性化微电影网站的实战开发（二）","date":"2019-11-11T09:42:57.973Z","updated":"2019-11-13T14:33:21.290Z","comments":true,"path":"2019/11/11/Flask项目之个性化微电影网站的实战开发（二）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/11/Flask项目之个性化微电影网站的实战开发（二）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶搭建后台页面 二丶后台管理（管理员登录及退出） 三丶后台管理（标签管理） 四丶后台管理（电影管理） 五丶后台管理（预告管理）","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶搭建后台页面 二丶后台管理（管理员登录及退出） 三丶后台管理（标签管理） 四丶后台管理（电影管理） 五丶后台管理（预告管理） 一丶搭建后台页面1.管理员登录和退出页面搭建 在admin/views中定义视图函数 123456789# 登录@admin.route('/login/')def login(): return render_template(\"admin/login.html\") # 登出@admin.route('/logout/')def logout(): return redirect(url_for('admin.login')) 复制static/tpl/3-admin目录下的login.html模板文件到templates/admin目录下，并修改模板中使用的静态资源路径 1&lt;link rel=\"shortcut icon\" href=\"&#123;&#123; url_for('static',filename='base/images/logo.png')&#125;&#125;\"&gt; 测试管理员登录与登出 2.管理员页面搭建（后台主页） 定义视图函数 123@admin.route('/')def index(): return render_template(\"admin/index.html\") 复制static/tpl/3-admin目录下的admin.html模板文件到templates/admin目录下，修改静态资源地址以及定义数据块（三处） 在templates/admin目录下创建grid.html模板，将admin.html模板中管理菜单标签内容剪贴到grid.html模板文件中（复用比较多的内容），并在admin.html模板中将grid.html模板包含进来 1&#123;% include \"admin/grid.html\"%&#125; -在templates/admin目录下创建index.html模板文件，继承与admin.html，并填写数据块content内容，用于显示后台管理页面 1234&#123;% extends \"admin/admin.html\"%&#125;&#123;% block content%&#125;&lt;h1&gt;hello admin&lt;/h1&gt;&#123;% endblock %&#125; 测试显示后台管理页面 3.修改密码丶控制面板丶标签管理页面搭建 修改密码 定义视图函数 123@admin.route('/pwd/')def pwd(): return render_template(\"admin/pwd.html\") 定义模板文件 测试显示修改密码页面 控制面板（也就是后台主页面index.html） 定义模板文件 定义控制面板按钮激活active，编辑grid.html管理菜单模块，给li块添加id属性 1234567891011121314&lt;li class=\"treeview\" id=\"g-1\"&gt; &lt;a href=\"#\"&gt; &lt;i class=\"fa fa-home\" aria-hidden=\"true\"&gt;&lt;/i&gt; &lt;span&gt;首页&lt;/span&gt; &lt;span class=\"label label-primary pull-right\"&gt;1&lt;/span&gt; &lt;/a&gt; &lt;ul class=\"treeview-menu\"&gt; &lt;li id=\"g-1-1\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.index')&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 控制面板 &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; 在admin/index.html模板下方添加js代码 123456&lt;script&gt; $(document).ready(function () &#123; $('#g-1').addClass('active') $('#g-1-1').addClass('active') &#125;)&lt;/script&gt; 测试控制面板页面（主页面内容） 标签管理（添加标签以及标签列表） 定义视图函数 123456789# 添加标签@admin.route('/tag/add')def tag_add(): return render_template(\"admin/tag_add.html\") # 标签列表@admin.route('/tag/list')def tag_list(): return render_template(\"admin/tag_list.html\") 修改grid.html模板中的地址以及添加li块的id属性 定义模板文件（tag_add.html以及tag_list.html） 测试标签管理页面 4.电影管理以及预告管理页面搭建 电影管理（添加电影以及电影列表） 定义视图函数 123456789# 添加电影@admin.route('/movie/add')def movie_add(): return render_template(\"admin/movie_add.html\") # 电影列表@admin.route('/movie/list')def movie_list(): return render_template(\"admin/movie_list.html\") 修改grid.html模板中的地址以及添加li块的id属性 定义模板文件（movie_add.html以及movie_list.html） 测试电影管理页面 预告管理（添加预告以及预告列表） 定义视图函数 123456789# 添加预告@admin.route('/preview/add')def preview_add(): return render_template(\"admin/preview_add.html\") # 预告列表@admin.route('/preview/list')def preview_list(): return render_template(\"admin/preview_list.html\") 修改grid.html模板中的地址以及添加li块的id属性 定义模板文件（preview_add.html以及preview_list.html） 测试预告管理页面 5.会员管理丶评论管理以及收藏管理页面搭建 会员管理（会员列表以及会员信息） 定义视图函数 123456789# 会员列表@admin.route('/user/list')def user_list(): return render_template(\"admin/user_list.html\") # 会员信息@admin.route('/user/view')def user_view(): return render_template(\"admin/user_view.html\") 修改grid.html模板中的地址以及添加li块的id属性 定义模板文件（user_list.html以及user_view.html） 测试会员管理页面 评论管理 定义视图函数 1234# 评论管理@admin.route('/comment/list')def comment_list(): return render_template(\"admin/comment_list.html\") 修改grid.html模板中的地址以及添加li块的id属性 定义模板文件（comment_list.html） 测试评论管理页面 收藏管理 定义视图函数 1234# 收藏管理@admin.route('/moviecol/list')def moviecol_list(): return render_template(\"admin/moviecol_list.html\") 修改grid.html模板中的地址以及添加li块的id属性 定义模板文件（moviecol_list.html） 测试收藏管理页面 6.日志管理丶权限管理丶角色管理页面搭建 日志管理（操作日志列表和管理员登录日志列表以及会员登录日志列表） 定义视图函数 1234567891011121314# 操作日志列表@admin.route('/oplog/list')def oplog_list(): return render_template(\"admin/oplog_list.html\") # 管理员登录日志列表@admin.route('/adminloginlog/list')def adminloginlog_list(): return render_template(\"admin/adminloginlog_list.html\") # 会员登录日志列表@admin.route('/userloginlog/list')def userloginlog_list(): return render_template(\"admin/userloginlog_list.html\") 修改grid.html模板中的地址以及添加li块的id属性 定义模板文件（oplog_list.html和adminloginlog_list.html以及userloginlog_list.html） 测试日志管理页面 权限管理（添加权限以及权限列表） 定义视图函数 123456789# 添加权限@admin.route('/auth/add')def auth_add(): return render_template(\"admin/auth_add.html\") # 权限列表@admin.route('/auth/list')def auth_list(): return render_template(\"admin/auth_list.html\") 修改grid.html模板中的地址以及添加li块的id属性 定义模板文件（auth_add.html以及auth_list.html） 测试权限管理页面 角色管理（添加角色以及角色列表） 定义视图函数 123456789# 添加角色@admin.route('/role/add')def role_add(): return render_template(\"admin/role_add.html\") # 角色列表@admin.route('/role/list')def role_list(): return render_template(\"admin/role_list.html\") 修改grid.html模板中的地址以及添加li块的id属性 定义模板文件（auth_add.html以及auth_list.html） 测试角色管理页面 7.管理员管理页面搭建（添加管理员以及管理员列表） 定义视图函数 123456789# 添加管理员@admin.route('/admin/add')def admin_add(): return render_template(\"admin/admin_add.html\") # 管理员列表@admin.route('/admin/list')def admin_list(): return render_template(\"admin/admin_list.html\") 修改grid.html模板中的地址以及添加li块的id属性 定义模板文件（admin_add.html以及admin_list.html） 测试管理员管理页面 二丶后台管理（管理员登录及退出）1.管理员登录 代码优化，将models模块中的导入数据库连接配置放在init初始化文件中，在models模块中只需要导入db对象即可 在admin/forms.py文件中创建管理员登录表单 1234567891011121314151617181920212223242526272829303132class LoginForm(FlaskForm): \"\"\"管理员登录表单\"\"\" account = StringField( label=\"账号\", validators=[ DataRequired(\"请输入账号！\") ], description=\"账号\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入账号！\", \"required\": \"required\" &#125; ) pwd = PasswordField( label=\"密码\", validators=[ DataRequired(\"请输入密码！\") ], description=\"密码\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入密码！\", \"required\": \"required\" &#125; ) submit = SubmitField( '登录', render_kw=&#123; \"class\": \"btn btn-primary btn-block btn-flat\", &#125; ) 在admin/views下的login视图中创建form对象，并传递给模板中 1234@admin.route('/login/', methods=['GET', 'POST'])def login(): form = LoginForm() return render_template(\"admin/login.html\", form=form) 替换登录模板中表单数据账号密码以及提交所在的标签为LoginFrom类的account和pwd以及sublime实例属性；修改form表单提交方式为POST 12345678910111213141516171819&lt;form method=\"POST\" id=\"form-data\"&gt; &lt;div class=\"form-group has-feedback\"&gt; &#123;&#123; form.account &#125;&#125; &lt;span class=\"glyphicon glyphicon-envelope form-control-feedback\"&gt;&lt;/span&gt; &lt;div class=\"col-md-12\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group has-feedback\"&gt; &#123;&#123; form.pwd &#125;&#125; &lt;span class=\"glyphicon glyphicon-lock form-control-feedback\"&gt;&lt;/span&gt; &lt;div class=\"col-md-12\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-8\"&gt; &lt;/div&gt; &lt;div class=\"col-xs-4\"&gt; &#123;&#123; form.submit &#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 设置SECRET_KEY用户表单提交免受CSRF威胁，并在模板中填写{{ form.csrf_token }} 1app.config[\"SECRET_KEY\"] = '*#%cnusadq***cdtaogang8a9dwqn' 刷新页面成功显示登录页 在models/Admin模型类中定义check_pwd方法用于检查判断用户密码输入是否正确，正确则返回True否则返回False 123def check_pwd(self, pwd): from werkzeug.security import check_password_hash return check_password_hash(self.pwd, pwd) 在视图函数中获取表单提交参数，通过调用Admin类中的check_pwd方法来判断用户输入的密码与数据库中模型类中密码是否一致，验证成功返回True可根据返回结果进行重定向到不同的地址，flash闪现显示错误提示信息 ，验证通过将用户对象信息保存在session会话中 123456789101112@admin.route('/login/', methods=['GET', 'POST'])def login(): form = LoginForm() if form.validate_on_submit(): data = form.data admin =Admin.query.filter_by(name=data['account']).first() if not admin.check_pwd(data['pwd']): flash(\"密码错误！\") return redirect(url_for('admin.login')) session['admin'] = data['account'] return redirect(request.args.get('next') or url_for('admin.index')) return render_template(\"admin/login.html\", form=form) 要在页面显示flash闪现信息，需要在模板文件中进行遍历显示 123&#123;% for msg in get_flashed_messages() %&#125;&lt;p class=\"login-box-msg\" style=\"color:red;\"&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125; 测试后台管理员登录 2.管理员退出 在logout视图函数中删除session会话中的用户信息 1234@admin.route('/logout/')def logout(): session.pop(\"admin\", None) return redirect(url_for('admin.login')) 测试管理员退出 在浏览器中直接访问http://127.0.0.1:5000/admin/一样可以进入管理页面并且管理菜单的标签是可以进行查看的，所以需要定义装饰器来控制页面的访问 12345678# 登录装饰器def admin_login_required(f): @wraps(f) def decorated_function(*args, **kwargs): if \"admin\" not in session: return redirect(url_for(\"admin.login\", next=request.url)) return f(*args, **kwargs) return decorated_function 后台管理页面中除了登录页都需要添加验证登录装饰器 1234@admin.route('/')@admin_login_requireddef index(): return render_template(\"admin/index.html\") 测试页面访问控制 三丶后台管理（标签管理）1.添加标签 在forms.py文件中定义添加标签表单类 1234567891011121314151617181920class TagFrom(FlaskForm): \"\"\"添加标签表单\"\"\" name = StringField( label=\"名称\", validators=[ DataRequired(\"请输入标签！\") ], description=\"标签\", render_kw=&#123; \"class\": \"form-control\", \"id\": \"input_name\", \"placeholder\": \"请输入标签名称！\" &#125; ) submit = SubmitField( '提交', render_kw=&#123; \"class\": \"btn btn-primary\", &#125; ) 在tag_add.html模板中替换表单中的name以及submit 123456789101112&lt;form role=\"form\" method=\"post\"&gt; &lt;div class=\"box-body\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_name\"&gt;&#123;&#123;form.name.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.name&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123;form.submit&#125;&#125; &#123;&#123;form.csrf_token&#125;&#125; &lt;/div&gt;&lt;/form&gt; 在视图函数中向模板传递表单form对象 123456# 添加标签@admin.route('/tag/add')@admin_login_requireddef tag_add(): form = TagFrom() return render_template(\"admin/tag_add.html\", form=form) 刷新页面添加标签页面显示正常 在视图函数tag_add中进行逻辑处理，根据管理员输入的标签名到数据库表中查询记录，记录不存在时，则保存到数据库中，并闪现成功消息，反之错误则提示用户失败信息，逻辑很简单 12345678910111213141516171819# 添加标签@admin.route('/tag/add', methods=['GET', 'POST'])@admin_login_requireddef tag_add(): form = TagFrom() if form.validate_on_submit(): data = form.data tag = Tag.query.filter_by(name=data[\"name\"]).count() if tag == 1: flash(\"名称已经存在！\", \"err\") return redirect(url_for('admin.tag_add')) tag = Tag( name=data[\"name\"] ) db.session.add(tag) db.session.commit() flash(\"添加标签成功！\", \"ok\") redirect(url_for('admin.tag_add')) return render_template(\"admin/tag_add.html\", form=form) 紧接着在tag_add.html模板中定义正确提示信息以及错误提示信息，需要注意的是需使用flash分类闪现操作 12345678910111213141516&#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &lt;h4&gt;&lt;i class=\"icon fa fa-check\"&gt;&lt;/i&gt; 操作成功&lt;/h4&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;&#123;% endfor %&#125;&#123;% for msg in get_flashed_messages(category_filter=[\"err\"]) %&#125; &lt;div class=\"alert alert-danger alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &lt;h4&gt;&lt;i class=\"icon fa fa-ban\"&gt;&lt;/i&gt; 操作失败&lt;/h4&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;&#123;% endfor %&#125; 测试添加标签功能 查看数据库tag表数据 2.标签列表数据显示 在视图函数tag_list中，定义路由接收页码page参数，从数据中查询tag表数据并按照添加时间倒序排序，将查询结果通过sqlalchemy中的paginate方法进行分页，最终将分页结果集传递给前端模板 12345678# 标签列表@admin.route('/tag/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef tag_list(page=None): if page is None: page = 1 page_data = Tag.query.order_by(Tag.addtime.desc()).paginate(page=page, per_page=1) return render_template(\"admin/tag_list.html\", page_data=page_data) 在模板文件中遍历后端传递的结果集，获取每个tag对象，填写模板数据 123456789101112&#123;% for t in page_data.items%&#125;&lt;tr&gt; &lt;td&gt;&#123;&#123;t.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;t.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;t.addtime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"label label-success\"&gt;编辑&lt;/a&gt; &amp;nbsp; &lt;a class=\"label label-danger\"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt;&#123;% endfor %&#125; 因为视图函数tag_list修改了路由，所以需要在grid.html模板中修改标签列表的地址，传递page参数 1&lt;a href=\"&#123;&#123;url_for('admin.tag_list', page=1)&#125;&#125;\"&gt; 测试标签列表页 目前只能根据请求地址中page参数来控制页面数据的显示，而页面中的分页点击没有任何作用，所以需要进行修改，因为网站页面中所有的分页都是一样的，所以这里将tag_list模板中的分页代码剪切出来，在templates目录下新建ui目录，在该目录下创建admin_page.html文件，将剪切出来的代码拷贝至此，进行如下编写，请参考分页文档 123456789101112131415161718192021222324252627&#123;% macro page(data, url) %&#125;&#123;% if data %&#125;&lt;ul class=\"pagination pagination-sm no-margin pull-right\"&gt; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=1)&#125;&#125;\"&gt;首页&lt;/a&gt;&lt;/li&gt; &#123;% if data.has_prev %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=data.prev_num)&#125;&#125;\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% else%&#125; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% for p in data.iter_pages() %&#125; &#123;% if p == data.page %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;&#123;&#123;p&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=p)&#125;&#125;\"&gt;&#123;&#123;p&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if data.has_next %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=data.next_num)&#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% else%&#125; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;li&gt;&lt;a href=\"&#123;&#123;url_for(url, page=data.pages)&#125;&#125;\"&gt;尾页&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&#123;% endif %&#125;&#123;% endmacro %&#125; 回到tag_list模板中，调用上一步写的分页，该分页需接收两个参数一个是数据库查询的分页集数据，另一个是页面地址 123&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.tag_list')&#125;&#125;&lt;/div&gt; 测试标签列表页分页显示数据 3.删除标签 在views中定义删除标签视图函数，需要接收前端传递商品的id，使用flask sqlalchemy 删除方法，查看参考文档，以及视图查询中的first_or_404方法，捕获404页面，删除标签成功，跳转到标签列表页，需要注意列表页需要传递page参数，否则报错 12345678@admin.route('/tag/del/&lt;int:id&gt;/', methods=['GET'])@admin_login_requireddef tag_del(id=None): tag = Tag.query.filter_by(id=id).first_or_404() db.session.delete(tag) db.session.commit() flash(\"删除标签成功！\", \"ok\") return redirect(url_for('admin.tag_list', page=1)) 在tag_list模板文件中需要编写删除按钮的地址，以及模板中删除成功信息提示框（跟添加标签时一样） 12345678910&lt;a href=\"&#123;&#123;url_for('admin.tag_del', id=t.id)&#125;&#125;\" class=\"label label-danger\"&gt;删除&lt;/a&gt; &#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &lt;h4&gt;&lt;i class=\"icon fa fa-check\"&gt;&lt;/i&gt; 操作成功&lt;/h4&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;&#123;% endfor %&#125; 测试删除标签功能（说明博主这里将tag_list视图函数中分页数据显示为5条） 4.修改标签 同样在视图中定义修改标签的视图函数，跟添加标签逻辑大同小异，首先获取前端传递过来的标签id，在后端根据该标签id从数据表中查询到对应的标签对象tag；当管理员点击提交按钮则获取表单数据，根据表单数据中的name属性的值从数据库获取对应的结果数，判断当结果数为1并且数据库中对象的name值与管理员填写的name值一致，则表示名称已存在数据库；反之则设置tag对象的name属性值为管理员修改的name值，保存至数据库，需要注意的是在调用tag_update视图函数需要传递id值 123456789101112131415161718# 修改标签@admin.route('/tag/update/&lt;int:id&gt;', methods=['GET', 'POST'])@admin_login_requireddef tag_update(id): tag = Tag.query.get_or_404(id) form = TagFrom() if form.validate_on_submit(): data = form.data tag_count = Tag.query.filter_by(name=data[\"name\"]).count() if tag_count == 1 and tag.name == data['name']: flash(\"名称已经存在！\", \"err\") return redirect(url_for('admin.tag_update', id=id)) tag.name = data['name'] db.session.add(tag) db.session.commit() flash(\"添加标签成功！\", \"ok\") redirect(url_for('admin.tag_update', id=id)) return render_template(\"admin/tag_update.html\", form=form, tag=tag) 在admin目录下创建tag_update.html模板文件，用于进行修改标签页面显示，需要将标签对象的name值赋值到此模板中input name value中，用于显示将要修改的标签名，将tag_add.html模板内容复制到tag_update.html中，需要将添加标签标题修改为修改标签以及在模板中input框name值需要赋值 1&#123;&#123;form.name(value=tag.name)&#125;&#125; 测试修改标签功能 四丶后台管理（电影管理）1.添加电影 创建form表单类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class MovieForm(FlaskForm): \"\"\"添加电影表单\"\"\" title = StringField( label=\"片名\", validators=[ DataRequired(\"片名不能为空\") ], description=\"片名\", render_kw=&#123; \"class\": \"form-control\", \"id\": \"input_title\", \"placeholder\": \"请输入片名！！\" &#125; ) url = FileField( label=\"文件\", validators=[ DataRequired(\"请上传文件！\") ], description=\"文件\", ) info = TextAreaField( label=\"简介\", validators=[ DataRequired(\"简介不能为空\") ], description=\"简介\", render_kw=&#123; \"class\": \"form-control\", \"rows\": 5, &#125; ) logo = FileField( label=\"封面\", validators=[ DataRequired(\"请上传封面！\") ], description=\"封面\", ) star = SelectField( label=\"星级\", validators=[ DataRequired(\"请选择星级！\") ], # 星级是整数型 coerce=int, # 采用下拉选择的方式进行星级的选择 choices=[(1, \"1星级\"), (2, \"2星级\"), (3, \"3星级\"), (4, \"4星级\"), (5, \"5星级\")], description=\"星级\", render_kw=&#123; \"class\": \"form-control\", &#125; ) tag_id = SelectField( label=\"所属标签\", validators=[ DataRequired(\"请选择标签！\") ], # 标签id也是整数型 coerce=int, # 采用列表递归式来取出所有的标签 choices=[(t.id, t.name)for t in Tag.query.all()], description=\"标签\", render_kw=&#123; \"class\": \"form-control\", &#125; ) area = StringField( label=\"上映地区\", validators=[ DataRequired(\"请输入地区！\") ], description=\"地区\", render_kw=&#123; \"class\": \"form-control\", \"id\": \"input_area\", \"placeholder\": \"请输入地区！\" &#125; ) length = StringField( label=\"电影片长\", validators=[ DataRequired(\"请输入片长！\") ], description=\"片长\", render_kw=&#123; \"class\": \"form-control\", \"id\": \"input_length\", \"placeholder\": \"请输入片长！\" &#125; ) release_time = StringField( label=\"上映时间\", validators=[ DataRequired(\"请输入上映时间！\") ], description=\"上映时间\", render_kw=&#123; \"class\": \"form-control\", \"id\": \"input_release_time\", \"placeholder\": \"请输入上映时间！\" &#125; ) submit = SubmitField( '编辑', render_kw=&#123; \"class\": \"btn btn-primary\", &#125; ) 修改movie_add.html模板文件（也就是替换表单数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;form role=\"form\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;div class=\"box-body\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_title\"&gt;&#123;&#123;form.title.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.title&#125;&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_url\"&gt;&#123;&#123;form.url.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.url&#125;&#125; &lt;div style=\"margin-top:5px;\"&gt; &lt;div id=\"moviecontainer\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_info\"&gt;&#123;&#123;form.info.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.info&#125;&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_logo\"&gt;&#123;&#123;form.logo.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.logo&#125;&#125; &lt;img data-src=\"holder.js/262x166\" style=\"margin-top:5px;\" class=\"img-responsive\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_star\"&gt;&#123;&#123;form.star.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.star&#125;&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_tag_id\"&gt;&#123;&#123;form.tag_id.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.tag_id&#125;&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_area\"&gt;&#123;&#123;form.area.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.area&#125;&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_length\"&gt;&#123;&#123;form.length.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.length&#125;&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_release_time\"&gt;&#123;&#123;form.release_time.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.release_time&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123;form.submit&#125;&#125; &#123;&#123;form.csrf_token&#125;&#125; &lt;/div&gt;&lt;/form&gt; 测试显示添加电影页面 在views/movie_add视图函数中获取表单数据字段并添加到Movie数据表中，url表示视图链接地址logo表示视频封面图片 12345678910111213141516171819202122232425# 添加电影@admin.route('/movie/add', methods=['GET', 'POST'])@admin_login_requireddef movie_add(): form = MovieForm() if form.validate_on_submit(): data = form.data movie = Movie( title=data[\"title\"], url=url, info=data[\"info\"], logo=logo, star=int(data[\"star\"]), playnum=0, commentnum=0, tag_id=int(data[\"tag_id\"]), area=data['area'], release_time=data[\"release_time\"], length=data[\"length\"], ) db.session.add(movie) db.session.commit() flash(\"添加电影成功！\", \"ok\") return redirect(url_for(\"admin.movie_add\")) return render_template(\"admin/movie_add.html\", form=form) 在配置文件app/init.py中配置电影文件上传的路径为static/uploads目录下，添加当前配置文件所在的绝对路径在path中（就是init.py文件所在路径，改路径与static目录路径同级都是在app目录下） 1app.config[\"UP_DIR\"] = os.path.join(os.path.abspath(os.path.dirname(__file__)), \"static/uploads/\") 从werkzeug.utils工具中导入secure_filename方法，该方法可以将上传文件名修改为合法名（返回的ASCII码的文件名），在movie_add视图函数中通过表单对象url中的data数据中的filename来获取上传的电影文件名，同理获取上传的图片文件名 12file_url = secure_filename(form.url.data.filename) # 获取上传的电影文件名file_logo = secure_filename(form.logo.data.filename) # 获取上传图片文件名 在views中定义change_filename方法，用于对上传的文件名进行加密（也就是在原有的文件名中加上当前的年月日时分秒和随机uuid的值） 1234def change_filename(filename): fileinfo = os.path.splitext(filename) filename = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\") + str(uuid.uuid4().hex) + fileinfo[-1] # 文件后缀 return filename 回到movie_add视图函数中，调用change_filename方法，返回加密后的文件名，通过form表单对象url字段和logo字段data数据写入到/static/uploads目录下的filename文件中 1234567891011121314151617181920212223242526272829303132333435# 添加电影@admin.route('/movie/add', methods=['GET', 'POST'])@admin_login_requireddef movie_add(): form = MovieForm() if form.validate_on_submit(): data = form.data file_url = secure_filename(form.url.data.filename) # 获取上传的电影文件名 file_logo = secure_filename(form.logo.data.filename) # 获取上传图片文件名 if not os.path.exists(app.config[\"UP_DIR\"]): # 文件夹不存在 os.makedirs(app.config[\"UP_DIR\"]) # 创建多级目录 os.chmod(app.config[\"UP_DIR\"], \"rw\") # 赋予文件读写的权限 url = change_filename(file_url) # 返回加密后的电影文件名 logo = change_filename(file_logo) # 返回加密后的图片文件名 # 将url和logo数据写入到static/uploads/目录的filename文件中 form.url.data.save(app.config[\"UP_DIR\"] + url) form.logo.data.save(app.config[\"UP_DIR\"] + logo) movie = Movie( title=data[\"title\"], url=url, info=data[\"info\"], logo=logo, star=int(data[\"star\"]), playnum=0, commentnum=0, tag_id=int(data[\"tag_id\"]), area=data['area'], release_time=data[\"release_time\"], length=data[\"length\"], ) db.session.add(movie) db.session.commit() flash(\"添加电影成功！\", \"ok\") return redirect(url_for(\"admin.movie_add\")) return render_template(\"admin/movie_add.html\", form=form) 测试添加电影功能 查看数据库movie表数据（X战警为博主前面测试添加的） 查看项目static目录下生成的数据 补充添加电影失败（即片名一致）跟添加标签一样，只需要在movie_add视图函数中，添加如下代码即可 1234movie_count = Movie.query.filter_by(title=data[\"title\"]).count()if movie_count == 1: flash(\"名称已经存在！\", \"err\") return redirect(url_for('admin.movie_add')) 2.电影列表数据显示 在视图函数movie_list中编写逻辑代码，逻辑和标签列表基本一样，唯一不同的就是这里查询时涉及到关联查询（movie表和tag表），关联查询使用的是filter而不是filter_by 1234567@admin.route('/movie/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef movie_list(page): if page is None: page = 1 page_data = Movie.query.join(Tag).filter(Movie.tag_id==Tag.id).order_by(Movie.addtime.desc()).paginate(page=page, per_page=5) return render_template(\"admin/movie_list.html\", page_data=page_data) 在grid.html模板文件中更新电影列表的链接地址 12345&lt;li id=\"g-3-2\"&gt; &lt;a href=\"&#123;&#123;url_for('admin.movie_list', page=1)&#125;&#125;\"&gt; &lt;i class=\"fa fa-circle-o\"&gt;&lt;/i&gt; 电影列表 &lt;/a&gt;&lt;/li&gt; 在movie_add.html模板文件中获取后端传递的movie表的分页数据集，并进行表数据和页面分页数据替换 123456789101112131415161718192021222324&#123;% for m in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;m.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.title&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.length&#125;&#125;分钟&lt;/td&gt; &lt;td&gt;&#123;&#123;m.tag.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.area&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.star&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.playnum&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.commentnum&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;m.release_time&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"label label-success\"&gt;编辑&lt;/a&gt; &amp;nbsp; &lt;a class=\"label label-danger\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.movie_list')&#125;&#125;&lt;/div&gt; 测试电影列表页分页数据显示（数据只有两天，所以只显示1页） 3.删除电影 定义删除电影视图函数，该函数代码逻辑简单与删除标签视图一致 123456789# 删除电影@admin.route('/movie/del/&lt;int:id&gt;/', methods=['GET'])@admin_login_requireddef movie_del(id=None): movie = Movie.query.filter_by(id=id).first_or_404() db.session.delete(movie) db.session.commit() flash(\"删除电影成功！\", \"ok\") return redirect(url_for('admin.movie_list', page=1)) 设置删除按钮超链接地址 1&lt;a href=\"&#123;&#123;url_for('admin.movie_del', id=m.id)&#125;&#125;\" class=\"label label-danger\"&gt;删除&lt;/a&gt; 测试删除电影功能 4.修改电影 定义修改电影视图函数，接收要修改电影的id编号，根据id编号从数据库中获取对应movie对象；获取电影表单数据对象form，返回movie_update模板 123456789# 修改电影@admin.route('/movie/update/&lt;int:id&gt;/', methods=['GET', 'POST'])@admin_login_requireddef movie_update(id): form = MovieForm() movie = Movie.query.get_or_404(id) if form.validate_on_submit(): data = form.data return render_template(\"admin/movie_update.html\", form=form, movie=movie) 在grid.html模板中更新编辑功能跳转链接地址 1&lt;a href=\"&#123;&#123;url_for('admin.movie_update', id=m.id)&#125;&#125;\" class=\"label label-success\"&gt;编辑&lt;/a&gt; 在admin目录下创建movie_update.html模板文件，将movie_add.html模板中数据拷贝到此模板中，进行如下修改（部分代码演示，数据比较多），主要是三个点，在修改电影页面输入框选择框初始值显示，url（电影）显示，logo（海报）显示 1234567891011121314151617181920212223242526&#123;&#123;form.title(value=movie.title)&#125;&#125; # 添加初始值&lt;img src=\"&#123;&#123;url_for('static', filename='uploads/'+movie.logo)&#125;&#125;\" width=\"200\" style=\"margin-top:5px;\" class=\"img-responsive\"&gt; # logo&lt;script type=\"text/javascript\"&gt; # url jwplayer(\"moviecontainer\").setup(&#123; flashplayer: \"&#123;&#123;url_for('static', filename='jwplayer/jwplayer.flash.swf')&#125;&#125;\", playlist: [&#123; file: \"&#123;&#123;url_for('static', filename='uploads/'+movie.url)&#125;&#125;\", title: \"&#123;&#123;movie.title&#125;&#125;\" &#125;], modes: [&#123; type: \"html5\" &#125;, &#123; type: \"flash\", src: \"&#123;&#123;url_for('static', filename='jwplayer/jwplayer.flash.swf')&#125;&#125;\" &#125;, &#123; type: \"download\" &#125;], skin: &#123; name: \"vapor\" &#125;, \"playlist.position\": \"left\", \"playlist.size\": 200, height: 400, width: 800, &#125;);&lt;/script&gt; 测试修改页面数据显示（页面上的电影简介和星级以及标签是错误的） 在movie_update.html模板文件中修改电影简介和星级以及标签，不在模板中设置其初始值，而是在视图中直接进行赋值处理 1234if request.method == 'GET': form.info.data = movie.info form.tag_id.data = movie.tag_id form.star.data = movie.star 刷新修改页面正确显示出电影简介和星级以及标签 说明：gif动图制作的质量比较差，所以看到的画面是比较劣质的（只能上传5M以内的文件），截图对比一下 在movie_update视图函数中定义修改电影业务逻辑，代码中有注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 修改电影@admin.route('/movie/update/&lt;int:id&gt;/', methods=['GET', 'POST'])@admin_login_requireddef movie_update(id): form = MovieForm() movie = Movie.query.get_or_404(id) # 因为url视频和logo图片是存在的不用设置表单数据，所以定义为空 form.url.validators = [] form.logo.validators = [] # 设置修改页面电影简介和星级以及标签的初始值 if request.method == 'GET': form.info.data = movie.info form.tag_id.data = movie.tag_id form.star.data = movie.star if form.validate_on_submit(): data = form.data movie_count = Movie.query.filter_by(title=data[\"title\"]).count() # 管理员填写的片面已存在于数据中时，修改电影失败 if movie_count == 1 and movie.title == data['title']: flash(\"名称已经存在！\", \"err\") return redirect(url_for('admin.movie_update', id=id)) if not os.path.exists(app.config[\"UP_DIR\"]): # 文件夹不存在 os.makedirs(app.config[\"UP_DIR\"]) # 创建多级目录 os.chmod(app.config[\"UP_DIR\"], \"rw\") # 赋予文件读写的权限 # 当url数据中filename不为空时，说明已经选择了上传的文件 if form.url.data.filename != '': file_url = secure_filename(form.url.data.filename) # 获取上传的电影文件名 movie.url = change_filename(file_url) # 更新对象中的url为返回加密后的电影文件名 # 将url写入到static/uploads/目录的对应的filename文件中 form.url.data.save(app.config[\"UP_DIR\"] + movie.url) # 当logo数据中filename不为空时，说明已经选择了上传的文件 if form.logo.data.filename != '': file_logo = secure_filename(form.logo.data.filename) # 获取上传图片文件名 movie.logo = change_filename(file_logo) # 更新对象中的logo为返回加密后的图片文件名 # 将logo写入到static/uploads/目录的对应的filename文件中 form.logo.data.save(app.config[\"UP_DIR\"] + movie.logo) # 将页面上的数据分别设置到数据库对应表字段中 movie.title = data['title'] movie.info = data['info'] movie.star = data['star'] movie.tag_id = data['tag_id'] movie.area = data['area'] movie.length = data['length'] movie.release_time = data['release_time'] db.session.add(movie) db.session.commit() flash(\"修改电影成功！\", \"ok\") return redirect(url_for(\"admin.movie_list\", page=1)) return render_template(\"admin/movie_update.html\", form=form, movie=movie) 注重说明一点，博主这里遇到个bug那就是在模板中渲染错误消息，不能覆盖掉DataRequired验证器的提示信息，所以博主这里将设置url（电影）以及logo（图片）中的required=False，进行禁用提示“请填写此字段”，结果还是不提示模板中的渲染的错误消息，注重啥也不提示 最终通过https://cloud.tencent.com/developer/ask/150670 中的在模板form标签中加入novalidate属性 然后就渲染了错误信息，删除上一步定义的{{ form.url(required=False) }}和{{ form.logo(required=False) }} 1&lt;form novalidate role=\"form\" method=\"post\" enctype=\"multipart/form-data\"&gt; 测试修改电影功能 五丶后台管理（预告管理）1.添加预告 在admin/forms下定义表单 1234567891011121314151617181920212223242526class PreviewForm(FlaskForm): \"\"\"添加电影预告表单\"\"\" title = StringField( label=\"预告标题\", validators=[ DataRequired(\"请输入预告标题！\") ], description=\"预告标题\", render_kw=&#123; \"class\": \"form-control\", \"placeholder\": \"请输入预告标题！\" &#125; ) logo = FileField( label=\"预告封面\", validators=[ DataRequired(\"请上传预告封面！\") ], description=\"预告封面\", ) submit = SubmitField( '提交', render_kw=&#123; \"class\": \"btn btn-primary\", &#125; ) 编辑视图函数 12345678# 添加预告@admin.route('/preview/add', methods=['GET', 'POST'])@admin_login_requireddef preview_add(): form = PreviewForm() if form.validate_on_submit(): data = form.data return render_template(\"admin/preview_add.html\", form=form) 编辑preview_add.html模板文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;form novalidate role=\"form\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;div class=\"box-body\"&gt; &#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &lt;h4&gt;&lt;i class=\"icon fa fa-check\"&gt;&lt;/i&gt; 操作成功&lt;/h4&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% for msg in get_flashed_messages(category_filter=[\"err\"]) %&#125; &lt;div class=\"alert alert-danger alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &lt;h4&gt;&lt;i class=\"icon fa fa-ban\"&gt;&lt;/i&gt; 操作失败&lt;/h4&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_title\"&gt;&#123;&#123;form.title.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.title&#125;&#125; &#123;% for error in form.title.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_logo\"&gt;&#123;&#123;form.logo.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.logo&#125;&#125; &#123;% for error in form.logo.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;img data-src=\"holder.js/700x320\" style=\"margin-top:5px;\" class=\"img-responsive\" alt=\"\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123;form.submit&#125;&#125; &#123;&#123;form.csrf_token&#125;&#125; &lt;/div&gt;&lt;/form&gt; 添加预告页面数据测试（点击提交按钮） 测试添加预告功能 2.预告列表页数据显示 跟电影列表一样，数据库查询数据并进行分页，传递分页数据集到模板中 12345678# 预告列表@admin.route('/preview/list/&lt;int:page&gt;/', methods=['GET'])@admin_login_requireddef preview_list(page=None): if page == None: page = 1 page_data = Preview.query.order_by(Preview.addtime.desc()).paginate(page=page, per_page=5) return render_template(\"admin/preview_list.html\", page_data=page_data) 在grid.html模板中修改列表链接地址（也就是添加page的值） 1&lt;a href=\"&#123;&#123;url_for('admin.preview_list', page=1)&#125;&#125;\"&gt; 在preview.html模板文件中进行如下修改，需要导入ui目录下的分页模板{% import \"ui/admin_page.html\" as pg %} 123456789101112131415161718192021 &#123;% for p in page_data.items%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;p.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;p.title&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;img src=\"&#123;&#123;url_for('static', filename='uploads/'+p.logo)&#125;&#125;\" width=\"100\" class=\"img-responsive center-block\" alt=\"\"&gt; &lt;/td&gt; &lt;td&gt;&#123;&#123;p.addtime &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"label label-success\"&gt;编辑&lt;/a&gt; &amp;nbsp; &lt;a class=\"label label-danger\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;div class=\"box-footer clearfix\"&gt; &#123;&#123;pg.page(page_data, 'admin.preview_list')&#125;&#125;&lt;/div&gt; 测试预告列表页数据显示 3.删除预告 跟之前电影管理一样逻辑，这里直接上代码，定义视图 123456789# 删除预告@admin.route('/preview/del/&lt;int:id&gt;/', methods=['GET'])@admin_login_requireddef preview_del(id=None): preview = Preview.query.filter_by(id=id).first_or_404() db.session.delete(preview) db.session.commit() flash(\"删除电影成功！\", \"ok\") return redirect(url_for('admin.preview_list', page=1)) 在preview.html模板中进行进行添加删除按钮链接地址 1&lt;a href=\"&#123;&#123;url_for('admin.preview_del', id=p.id)&#125;&#125;\" class=\"label label-danger\"&gt;删除&lt;/a&gt; 测试删除功能 4.修改预告（跟修改电影逻辑一样，直接上代码） 定义视图函数 123456789101112131415161718192021222324252627# 修改预告@admin.route('/preview/update/&lt;int:id&gt;/', methods=['GET', 'POST'])@admin_login_requireddef preview_update(id): form = PreviewForm() form.logo.validators = [] preview = Preview.query.filter_by(id=id).first_or_404() if request.method == 'GET': form.title.data = preview.title # 赋值 if form.validate_on_submit(): data = form.data preview_count = Preview.query.filter_by(title=data[\"title\"]).count() if preview_count == 1: flash(\"名称已经存在！\", \"err\") return redirect(url_for('admin.preview_update', id=id)) # 当logo数据中filename不为空时，说明已经选择了上传的文件 if form.logo.data.filename != '': file_logo = secure_filename(form.logo.data.filename) # 获取上传图片文件名 preview.logo = change_filename(file_logo) # 更新对象中的logo为返回加密后的图片文件名 # 将logo写入到static/uploads/目录的对应的filename文件中 form.logo.data.save(app.config[\"UP_DIR\"] + preview.logo) preview.title = data['title'] db.session.add(preview) db.session.commit() flash(\"修改预告成功！\", \"ok\") return redirect(url_for(\"admin.preview_list\",page=1)) return render_template(\"admin/preview_update.html\", form=form, preview=preview) 新建preview_update.html模板（将preview_add.html内容复制进去并进行修改） 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;form novalidate role=\"form\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;div class=\"box-body\"&gt; &#123;% for msg in get_flashed_messages(category_filter=[\"ok\"]) %&#125; &lt;div class=\"alert alert-success alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &lt;h4&gt;&lt;i class=\"icon fa fa-check\"&gt;&lt;/i&gt; 操作成功&lt;/h4&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% for msg in get_flashed_messages(category_filter=[\"err\"]) %&#125; &lt;div class=\"alert alert-danger alert-dismissible\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\"&gt;× &lt;/button&gt; &lt;h4&gt;&lt;i class=\"icon fa fa-ban\"&gt;&lt;/i&gt; 操作失败&lt;/h4&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_title\"&gt;&#123;&#123;form.title.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.title&#125;&#125; &#123;% for error in form.title.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_logo\"&gt;&#123;&#123;form.logo.label&#125;&#125;&lt;/label&gt; &#123;&#123;form.logo&#125;&#125; &#123;% for error in form.logo.errors %&#125; &lt;div class=\"col-md-12\"&gt; &lt;p style=\"color:red\"&gt;&#123;&#123; error &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;img src=\"&#123;&#123;url_for('static', filename='uploads/'+preview.logo)&#125;&#125;\" style=\"margin-top:5px;\" class=\"img-responsive\" alt=\"\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &#123;&#123;form.submit&#125;&#125; &#123;&#123;form.csrf_token&#125;&#125; &lt;/div&gt;&lt;/form&gt; 测试修改预告功能 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/89340922","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战","slug":"Flask网站实战","permalink":"https://hellotaogang.github.io/tags/Flask网站实战/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之个性化微电影网站的实战开发（一）","slug":"Flask项目之个性化微电影网站的实战开发（一）","date":"2019-11-11T02:13:06.120Z","updated":"2019-11-16T03:32:41.717Z","comments":true,"path":"2019/11/11/Flask项目之个性化微电影网站的实战开发（一）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/11/Flask项目之个性化微电影网站的实战开发（一）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶叙述 二丶Windows环境搭建 三丶项目分析丶搭建目录以及模型设计 四丶搭建前台页面","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶叙述 二丶Windows环境搭建 三丶项目分析丶搭建目录以及模型设计 四丶搭建前台页面 一丶叙述1.项目中使用到的知识点 使用整型丶浮点型丶路径型丶字符串型正则表达式以及路由转换器 使用get与post请求丶上传文件丶cookie获取与响应丶404页面处理 使用模板自动转义丶定义过滤器丶定义全局上下文处理器丶Jinjia2语法丶包含丶继承丶定义宏 使用flask_wtf定义表单模型丶字段类型丶字段验证丶视图处理表单丶模板使用表单 使用flask_sqlachemy定义数据库模型丶添加数据丶修改数据丶查询数据丶删除数据丶数据库事件丶数据库迁移 使用蓝图优化项目结构丶实现微电影网站前台与后台业务逻辑 通过nginx反向代理对视频流媒体限制下载速率丶限制单个ip能发起的播放连接数 微内核以及flask拓展插件，其中微内核包括werkzug工具箱丶pymysql数据库驱动sqlachemy数据库orm丶wtforms表单验证工具jinja2模板引擎丶flask-script命令行脚本丶functools定义高阶函数；插件包括jwplayer播放器插件丶视频限速限ip访问丶flv以及mp4视频格式支持丶nginx点播实现 2.环境搭建与工具 搭建开发环境依赖包丶virtuanlven虚拟化环境的使用 pycharm编辑器 3.项目优化与模型设计 使用flask蓝图Blueprint规划项目结构 使用flask_sqlachemy定义和业务需求相关的数据库模型 结合mysql数据库生成项目所需的数据表 4.前端搭建 实现前台后台html布局页面搭建 使用jinjia2引擎 引入静态资源文件丶404错误页面处理 5.后端开发 使用flask sqlachemy结合mysql数据表进行增删改查操作 flask数据分页查询丶路由装饰器定义丶模板中变量调用丶登录回话机制丶上传文件 flask wtforms表单验证丶flask自定义应用上下文丶自定义权限权限装饰器对管理系统进行基于角色权限的访问控制 flask多表关联查询丶关键字模糊查询 6.网站部署 实现在centos服务器上搭建nginx+mysql+python环境 使用nginx反向代理多端口多进程部署微电影网站 配置nginx流媒体访问限制参数 7.前台静态主页面效果预览 8.后台管理静态主页面效果预览 9.微电影网站组成 10.开发及生产环境 生产环境：Centos7 开发语言：Python3 数据库：MySQL 前端：HTML5及BootStrap框架（AdminLTE：一个基于bootstrap框架的轻量级后台模板） Web开发框架：Flask Web服务器：Nginx 编程工具：PyCharm 二丶Windows环境搭建说明：博主这里使用Python3.6开发语言 数据库Mysql5.7 PyCharm编程工具（这三个就不进行演示了）以及安装虚拟环境 安装项目虚拟环境 创建虚拟环境 配置项目解释器 安装Flask包成功后，查看当前环境下的包 三丶项目分析丶搭建目录以及模型设计1.前台项目目录分析 前台（home） 数据模型：models.py 表单处理：home/forms.py 模板目录：templates/home 2.后台项目目录分析 后台（admin） 数据模型：models.py 表单处理：admin/forms.py 模板目录：templates/admin 静态目录：static 3.前后台项目目录分析 manage.py &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;入口启动脚本 app &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;项目APP &ensp;&ensp;&ensp;&ensp;_init_.py &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;初始化文件 &ensp;&ensp;&ensp;&ensp;models.py &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;数据库模型文件 &ensp;&ensp;&ensp;&ensp;static &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;静态目录 &ensp;&ensp;&ensp;&ensp;home/admin &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;前台/后台模块 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;_init_.py &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;初始化文件 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;views.py &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;视图处理文件 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;forms.py &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;表单处理文件 &ensp;&ensp;&ensp;&ensp;templates &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;模板目录 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;home/admin &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;前台/后台模板 4.搭建目录 5.搭建蓝图 在home/init.py文件中定义蓝图 1234# coding:utf-8from flask import Blueprinthome = Blueprint(\"home\", __name__)import app.home.views 在admin/init.py文件中定义蓝图 1234# coding:utf-8from flask import Blueprintadmin = Blueprint(\"admin\", __name__)import app.admin.views 在home/views.py文件中定义视图 12345# coding:utf-8from . import home@home.route('/')def index(): return \"&lt;h1 style='color:red'&gt;hello home&lt;/h1&gt;\" 在admin/views.py文件中定义视图 12345# coding:utf-8from . import admin@admin.route('/')def index(): return \"&lt;h1 style='color:green'&gt;hello admin&lt;/h1&gt;\" 在app/init.py文件中创建app对象并使用app对象注册蓝图 1234567891011#coding:utf-8from flask import Flask app = Flask(__name__)app.debug = Truefrom app.admin import admin as admin_blueprintfrom app.home import home as home_blueprint # 注册蓝图app.register_blueprint(admin_blueprint, url_prefix=\"/admin\")app.register_blueprint(home_blueprint) 在manage.py中定义启动脚本 12345# coding:utf-8from app import app if __name__ == '__main__': app.run() 运行项目后，在浏览器中分别输入http://127.0.0.1:5000/以及http://127.0.0.1:5000/admin/ 6.会员及会员登录日志数据模型设计 创建项目所需数据库 安装Flask-SQLAlchemy 1pip install flask-sqlalchemy 安装PyMySQL 1pip install pymysql 定义会员数据模型 1234567891011121314151617class User(db.Model): __tablename__ = \"user\" id = db.Column(db.Integer, primary_key=True) # 编号 name = db.Column(db.String(100), unique=True) # 昵称 pwd = db.Column(db.String(100)) # 密码 email = db.Column(db.String(100), unique=True) # 邮箱 phone = db.Column(db.String(11), unique=True) # 电话号码 info = db.Column(db.Text) # 个性简介 face = db.Column(db.String(255), unique=True) # 头像 addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 添加时间 uuid = db.Column(db.String(255), unique=True) # 唯一标志符 userlogs = db.relationship('UserLog', backref='user') # 会员日志外键关系 comments = db.relationship('Comment', backref='user') # 评论外键关系关联 moviecols = db.relationship('MovieCol', backref='user') # 电影收藏外键关系关联 def __str__(self): return \"&lt;User:%r&gt;\" % self.name 定义会员登录日志模型 123456789class UserLog(db.Model): __tablename__ = \"userlog\" id = db.Column(db.Integer, primary_key=True) # 编号 user_id = db.Column(db.Integer, db.ForeignKey('user.id')) # 所属会员 ip = db.Column(db.String(100)) # 登录IP addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 登录时间 def __repr__(self): return '&lt;UserLog %r&gt;' % self.id 7.标签丶电影丶上映预告数据模型设计 定义标签数据模型 123456789class Tag(db.Model): __tablename__ = \"tag\" id = db.Column(db.Integer, primary_key=True) # 编号 name = db.Column(db.String(100), unique=True) # 标题 addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 添加时间 movies = db.relationship('Movie', backref='tag') # 电影外键关系关联 def __repr__(self): return '&lt;Tag %r&gt;' % self.name 定义电影数据模型 1234567891011121314151617181920class Movie(db.Model): __tablename__ = \"movie\" id = db.Column(db.Integer, primary_key=True) # 编号 title = db.Column(db.String(255), unique=True) # 电影标题 url = db.Column(db.String(255), unique=True) # 电影地址 info = db.Column(db.Text) # 电影简介 logo = db.Column(db.String(255), unique=True) # 电影封面 star = db.Column(db.SmallInteger) # 星级 playnum = db.Column(db.BigInteger) # 电影播放量 commentnum = db.Column(db.BigInteger) # 电影评论量 tag_id = db.Column(db.Integer, db.ForeignKey('tag.id')) # 所属标签 area = db.Column(db.String(255)) # 地区 release_time = db.Column(db.Date) # 发布时间 length = db.Column(db.String(100)) # 电影长度 addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 添加时间 comments = db.relationship('Comment', backref='movie') # 电影评论外键关联 movieclos = db.relationship('MovieCol', backref='movie') # 电影收藏外键关联 def __repr__(self): return '&lt;Movie %r&gt;' % self.title 定义上映预告数据模型 123456789class Preview(db.Model): __tablename__ = \"preview\" id = db.Column(db.Integer, primary_key=True) # 编号 title = db.Column(db.String(255), unique=True) # 电影标题 logo = db.Column(db.String(255), unique=True) # 电影封面 addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 添加时间 def __repr__(self): return '&lt;Preview %r&gt;' % self.title 8.评论丶收藏丶权限丶角色丶管理员丶操作日志数据模型设计 定义评论数据模型 12345678910class Comment(db.Model): __tablename__ = \"comment\" id = db.Column(db.Integer, primary_key=True) # 编号 content = db.Column(db.Text) # 评论内容 movie_id = db.Column(db.Integer, db.ForeignKey('movie.id')) # 所属电影 user_id = db.Column(db.Integer, db.ForeignKey('user.id')) # 所属用户 addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 添加时间 def __repr__(self): return '&lt;Comment %r&gt;' % self.id 定义收藏电影数据模型 123456789class MovieCol(db.Model): __tablename__ = \"moviecol\" id = db.Column(db.Integer, primary_key=True) # 编号 movie_id = db.Column(db.Integer, db.ForeignKey('movie.id')) # 所属电影 user_id = db.Column(db.Integer, db.ForeignKey('user.id')) # 所属用户 addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 最近登录时间 def __repr__(self): return '&lt;MovieCol %r&gt;' % self.id 定义权限数据模型 123456789class Auth(db.Model): __tablename__ = \"auth\" id = db.Column(db.Integer, primary_key=True) # 编号 name = db.Column(db.String(100), unique=True) # 名称 url = db.Column(db.String(255), unique=True) # 电影地址 addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 添加时间 def __repr__(self): return '&lt;Auth %r&gt;' % self.name 定义角色数据模型 12345678910class Role(db.Model): __tablename__ = \"role\" id = db.Column(db.Integer, primary_key=True) # 编号 name = db.Column(db.String(100), unique=True) # 名称 auths = db.Column(db.String(600)) # 权限列表 admins = db.relationship(\"Admin\", backref='role') # 管理员外键关系关联 addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 添加时间 def __repr__(self): return '&lt;Role %r&gt;' % self.name 定义管理员数据模型 12345678910111213class Admin(db.Model): __tablename__ = \"admin\" id = db.Column(db.Integer, primary_key=True) # 编号 name = db.Column(db.String(100), unique=True) # 管理员名称 pwd = db.Column(db.String(100)) # 管理员密码 is_super = db.Column(db.SmallInteger) # 是否为超级管理员，0为超级管理员 role_id = db.Column(db.Integer, db.ForeignKey('role.id')) # 所属角色 addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 添加时间 adminlogs = db.relationship('AdminLog', backref='admin') # 管理员登录日志外键关系关联 oplogs = db.relationship('OpLog', backref='admin') # 管理员操作日志外键关系关联 def __repr__(self): return '&lt;Admin %r&gt;' % self.name 定义管理员登录日志数据模型 123456789class AdminLog(db.Model): __tablename__ = \"adminlog\" id = db.Column(db.Integer, primary_key=True) # 编号 admin_id = db.Column(db.Integer, db.ForeignKey('admin.id')) # 所属管理员 ip = db.Column(db.String(100)) # 登录IP addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 添加时间 def __repr__(self): return '&lt;AdminLog %r&gt;' % self.id 定义操作日志数据模型 12345678910class OpLog(db.Model): __tablename__ = \"oplog\" id = db.Column(db.Integer, primary_key=True) # 编号 admin_id = db.Column(db.Integer, db.ForeignKey('admin.id')) # 所属管理员 ip = db.Column(db.String(100)) # 登录IP reason = db.Column(db.String(600)) # 操作原因 addtime = db.Column(db.DateTime, index=True, default=datetime.now) # 添加时间 def __repr__(self): return '&lt;OpLog %r&gt;' % self.id 9.生成数据表 调用db对象中create_all方法 12if __name__ == '__main__': db.create_all() 运行models.py文件，提示如下错误 解决以上报错，导入pymysql并在配置uri中添加pymysql 12import pymysqlapp.config[\"SQLALCHEMY_DATABASE_URI\"] = \"mysql+pymysql://root:mysql@127.0.0.1:3306/movie\" 再次运行成功 查看数据库movie下的表 10.添加表数据 向角色表（role）添加数据 12345678if __name__ == '__main__': # db.create_all() role = Role( name=\"超级管理员\", auths=\"\" ) db.session.add(role) db.session.commit() 查看role表数据 向管理员表（admin）添加数据 12345678910if __name__ == '__main__': from werkzeug.security import generate_password_hash admin = Admin( name=\"taogangshow\", pwd=generate_password_hash(\"hellomovie\"), is_super=0, role_id=1 ) db.session.add(admin) db.session.commit() 查看admin表数据 四丶搭建前台页面1.会员登录退出页面搭建 将静态资源文件放在static目录下 将tpl/2-movie目录下的nav.html文件拷贝到templates/home目录下并命名为home.html，用作于父模板 将home.html中的静态文件引入方式全部修改为{{url_for('static', filename='xxx')}}，如下 1234&lt;link rel=\"shortcut icon\" href=\"&#123;&#123;url_for('static', filename='base/images/logo.png')&#125;&#125;\"&gt;&lt;link rel=\"stylesheet\" href=\"&#123;&#123;url_for('static', filename='base/css/bootstrap.min.css')&#125;&#125;\"&gt;&lt;link rel=\"stylesheet\" href=\"&#123;&#123;url_for('static', filename='base/css/bootstrap-movie.css')&#125;&#125;\"&gt;&lt;link rel=\"stylesheet\" href=\"&#123;&#123;url_for('static', filename='base/css/animate.css')&#125;&#125;\"&gt; 在内容div容器中挖坑（定义数据块） 123&lt;div class=\"container\" style=\"margin-top:76px\"&gt; &#123;% block content%&#125;&#123;% endblock %&#125;&lt;/div&gt; 在templates/home目录下新建index.html文件，继承与home.html 1234&#123;% extends \"/home/home.html\" %&#125;&#123;% block content %&#125;&lt;h1&gt;cdtaogang&lt;/h1&gt;&#123;% endblock%&#125; 在home/views.py文件中渲染出index.html模板文件 123@home.route('/')def index(): return render_template(\"home/index.html\") 启动项目，进入http://127.0.0.1:5000/显示页面 在home/views.py文件中定义登录以及退出视图 1234567@home.route('/login/')def login(): return render_template(\"home/login.html\") @home.route('/logout/')def logout(): return redirect(url_for(\"home.login\")) # 跳转到登录页 将tpl/2-movie目录下的login.html文件拷贝到templates/home目录下，其余部分删除只保留内容块继承父模板定义数据块 修改父模板home.html文件中登录和退出连接地址 12&lt;a class=\"curlink\" href=\"&#123;&#123;url_for('home.login')&#125;&#125;\"&gt;&lt;span class=\"glyphicon glyphicon-log-in\"&gt;&lt;/span&gt;&amp;nbsp;登录&lt;/a&gt;&lt;a class=\"curlink\" href=\"&#123;&#123;url_for('home.logout')&#125;&#125;\"&gt;&lt;span class=\"glyphicon glyphicon-log-out\"&gt;&lt;/span&gt;&amp;nbsp;退出&lt;/a&gt; 测试显示登录与退出页面 2.会员注册页面搭建 跟登录一样，首先定义视图函数 123@home.route('/register/')def register(): return render_template(\"home/register.html\") 然后模板文件register.html 修改父模板文件home.html中导航栏注册地址 1&lt;a class=\"curlink\" href=\"&#123;&#123;url_for('home.register')&#125;&#125;\"&gt;&lt;span class=\"glyphicon glyphicon-plus\"&gt;&lt;/span&gt;&amp;nbsp;注册&lt;/a&gt; 运行项目，成功显示注册页面 3.会员中心页面搭建 会员中心 定义视图函数 1234# 会员中心@home.route('/user/')def user(): return render_template(\"home/user.html\") 在templates/home目录下创建menu.html将注册页面中的菜单栏代码复制在该文件中 修改menu.html中代码，添加id属性，用于激活active 1234567891011121314151617&lt;div class=\"list-group\"&gt; &lt;a id=\"m-1\" href=\"&#123;&#123;url_for('home.user')&#125;&#125;\" class=\"list-group-item\"&gt; &lt;span class=\"glyphicon glyphicon-user\"&gt;&lt;/span&gt;&amp;nbsp;会员中心 &lt;/a&gt; &lt;a id=\"m-2\" href=\"&#123;&#123;url_for('home.pwd')&#125;&#125;\" class=\"list-group-item\"&gt; &lt;span class=\"glyphicon glyphicon-lock\"&gt;&lt;/span&gt;&amp;nbsp;修改密码 &lt;/a&gt; &lt;a id=\"m-3\" href=\"&#123;&#123;url_for('home.comments')&#125;&#125;\" class=\"list-group-item\"&gt; &lt;span class=\"glyphicon glyphicon-comment\"&gt;&lt;/span&gt;&amp;nbsp;评论记录 &lt;/a&gt; &lt;a id=\"m-4\" href=\"&#123;&#123;url_for('home.loginlog')&#125;&#125;\" class=\"list-group-item\"&gt; &lt;span class=\"glyphicon glyphicon-calendar\"&gt;&lt;/span&gt;&amp;nbsp;登录日志 &lt;/a&gt; &lt;a id=\"m-5\" href=\"&#123;&#123;url_for('home.moviecol')&#125;&#125;\" class=\"list-group-item\"&gt; &lt;span class=\"glyphicon glyphicon-heart\"&gt;&lt;/span&gt;&amp;nbsp;收藏电影 &lt;/a&gt;&lt;/div&gt; home.html模板文件中新建数据模块，用于存放注册页面独有的CSS代码 home.html模板文件底部新建数据模块，用于存放注册页面独有的JS代码 在templates/home目录下创建user.html将注册页面中的会员中心代码复制在该文件中，并继承父模板，需要将注册页面菜单栏menu.html文件包含在内容块中，以及填写css和js数据块数据 修改密码 定义视图函数 1234# 修改密码@home.route('/pwd/')def pwd(): return render_template(\"home/pwd.html\") 在templates/home目录下创建pwd.html将注册页面中的会员中心代码复制在该文件中，同上只需要更改修改密码内容块以及底部js也就是class=”col-md-9”和id属性值，因为除了独有部分不同其余部分相同 评论记录 定义视图函数 1234# 评论记录@home.route('/comments/')def comments(): return render_template(\"home/comments.html\") 在templates/home目录下创建pwd.html将注册页面中的会员中心代码复制在该文件中，同上只需要更改评论记录内容块以及底部js也就是class=”col-md-9”和id属性值，因为除了独有部分不同其余部分相同 登录日志 定义视图函数 1234# 登录日志@home.route('/loginlog/')def loginlog(): return render_template(\"home/loginlog.html\") 在templates/home目录下创建pwd.html将注册页面中的会员中心代码复制在该文件中，同上只需要更改登录日志内容块以及底部js也就是class=”col-md-9”和id属性值，因为除了独有部分不同其余部分相同 收藏电影 定义视图函数 1234# 收藏电影@home.route('/moviecol/')def moviecol(): return render_template(\"home/moviecol.html\") 在templates/home目录下创建pwd.html将注册页面中的会员中心代码复制在该文件中，同上只需要更改收藏电影内容块以及底部js也就是class=”col-md-9”和id属性值，因为除了独有部分不同其余部分相同 设定用户登录成功或者注册成功后进入会员中心页面，则在login.html以及register.html模板文件中修改链接地址 12&lt;a href=\"&#123;&#123;url_for('home.user')&#125;&#125;\" class=\"btn btn-lg btn-success btn-block\"&gt;登录&lt;/a&gt;&lt;a href=\"&#123;&#123;url_for('home.user')&#125;&#125;\" class=\"btn btn-lg btn-success btn-block\"&gt;注册&lt;/a&gt; 测试会员中心页面显示以及登录注册后页面跳转显示 4.电影列表页以及搜索页面搭建 电影列表页 定义视图函数 123456789# 列表@home.route('/')def index(): return render_template(\"home/index.html\") # 动画@home.route('/animation/')def animation(): return render_template(\"home/animation.html\") 在templates/home目录下新建layout.html文件，将home.html内容复制到layout.html文件中，因为列表页面与其他页面不一样，需要单独使用一个父模板，修改layout.html中的数据块，去除div标签 1&#123;% block content%&#125;&#123;% endblock %&#125; 编辑templates/home目录下的index.html文件，继承与layout.html，并将热门电影以及电影列表放在数据块中 将static/tpl目录下的animation.html文件拷贝到templates/home目录下，用于存放热门电影模块中的幻灯片动画，修改animation.html文件中的地址 修改home/index.html文件中动画地址 1&lt;iframe class=\"wow fadeIn\" width=\"100%\" height=\"375px\" frameborder=0 scrolling=no src=\"&#123;&#123;url_for('home.animation')&#125;&#125;\"&gt;&lt;/iframe&gt; 测试显示主页 搜索页面 定义视图 123@home.route('/search/')def search(): return render_template(\"home/search.html\") 将static/tpl/2-movie目录下的search.html文件拷贝到templates/home的目录下，并保留搜索内容块，其他地方继承home.html模板即可 测试显示搜索页面 5.电影播放页与404页面搭建 播放页面 定义视图函数 123@home.route('/play/')def play(): return render_template(\"home/play.html\") 复制static/tpl/2-movie下的play.html文件到templates/home目录下，完成该页面的继承的数据块，并修改静态资源地址 在搜索页面（search.html）收藏电影页面（moviecol.html）以及主页（index.html）中将电影播放地址play.html全部修改为{{url_for('home.play')}}，执行home下的play视图函数名 12345678910&lt;!-- 搜索页面 --&gt;&lt;a href=\"&#123;&#123;url_for('home.play')&#125;&#125;\"&gt; &lt;img class=\"media-object\" src=\"holder.js/131x83\" alt=\"环太平洋\"&gt;&lt;/a&gt;&lt;!-- 收藏电影页面 --&gt;&lt;a href=\"&#123;&#123;url_for('home.play')&#125;&#125;\"&gt; &lt;img class=\"media-object\" src=\"holder.js/131x83\" alt=\"环太平洋\"&gt;&lt;/a&gt;&lt;!-- 主页面 --&gt;&lt;a href=\"&#123;&#123;url_for('home.play')&#125;&#125;\" class=\"btn btn-primary\" target=\"_blank\" role=\"button\"&gt;&lt;span class=\"glyphicon glyphicon-play\"&gt;&lt;/span&gt;&amp;nbsp;播放&lt;/a&gt; 测试视频播放页面 404页面搭建 在app/init.py初始化文件中定义404错误机制视图函数 123@app.errorhandler(404)def page_not_found(error): return render_template(\"home/404.html\"), 404 复制static/tpl/4-404目录下的404.html文件到templates/home目录下，并修改模板中的静态资源路径 测试404页面 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/89297099","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战","slug":"Flask网站实战","permalink":"https://hellotaogang.github.io/tags/Flask网站实战/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目之Web端电商网站的实战开发（完结）","slug":"Django项目之Web端电商网站的实战开发（完结）","date":"2019-11-07T08:51:58.531Z","updated":"2019-11-13T14:27:45.836Z","comments":true,"path":"2019/11/07/Django项目之Web端电商网站的实战开发（完结）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/07/Django项目之Web端电商网站的实战开发（完结）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶订单生成 二丶订单支付 三丶订单评论 四丶项目部署 五丶项目总结","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶订单生成 二丶订单支付 三丶订单评论 四丶项目部署 五丶项目总结 一丶订单生成1.显示订单提交页面 step1 在df_order/views中定义类视图post方法，显示订单提交页面 123456# /order/placeclass OrderPlaceView(LoginRequiredMixin, View): \"\"\"提交订单\"\"\" def post(self, request): \"\"\"显示提交订单页面\"\"\" return render(request, 'place_order.html') step2 在df_order/urls中定义路由规则 1url(r\"^place$\", OrderPlaceView.as_view(), name='place'), # 显示订单页 step3 在place_order.html模板文件中，设置复选框checkbox的name为sku_ids以及value值为sku.id也就是商品id，因为当进行表单提交时，复选框的状态为未勾选状态时，则在headers from data表单数据中不会显示该商品的value值，即可以利用该点再后端获取提交订单页面中所有的数据 1234&lt;form method=\"post\" action=\"/order/place\"&gt; &lt;li class=\"col01\"&gt;&lt;input type=\"checkbox\" name=\"sku_ids\" value=\"&#123;&#123; sku.id &#125;&#125;\" checked&gt;&lt;/li&gt; &lt;li class=\"col04\"&gt;&lt;input type=\"submit\" value=\"去结算\"&gt;&lt;/li&gt;&lt;/form&gt; step4 在我的购物车页面点击去结算提交按钮，成功跳转到到提交订单页面 2.获取提交订单页面中的数据 step1 判断用户是否登录状态，如果没有登录则跳转到登录页面 123user = request.userif not user.is_authenticated(): return redirect(reverse('user:login')) step2 获取表单中的sku_ids数据并进行校验 12345#1 获取表单中的sku_ids参数sku_ids = request.POST.getlist(\"sku_ids\") #[11,19,39,41]#2 校验参数if not sku_ids: return redirect(reverse('cart:cart_show')) step3 获取redis连接对象，通过遍历sku_ids获取商品的信息，并获取数据库中商品的数量，计算出商品的小计，总计和总件数 123456789101112131415161718192021conn = get_redis_connection(\"default\")cart_key = \"cart_%d\" % user.idskus = []total_price = 0 # 总金额total_count = 0 # 总件数# 遍历sku_ids获取每个商品的信息for sku_id in sku_ids: # 根据商品id获取商品的信息 sku = GoodsSKU.objects.get(id=sku_id) # 根据商品id获取商品的数量 count = conn.hget(cart_key, sku_id) # 计算商品的小计 amount = sku.price*int(count) # 动态保存购买商品的数量和小计 sku.count = count sku.amount = amount # 商品信息对象保存到列表中 skus.append(sku) # 累加金额与件数 total_count += int(count) total_price += amount step4 设定运费金额，计算订单总金额组织模板上下文，返回给前端模板中 1234567891011121314# 运费，一般在实际开发中需要单独创建一张表，当金额超过多少时免运费或者是多少钱,这里直接写死为10块transit_price = 10# 实际付款金额total_pay = total_price + transit_price# 获取收件人地址addrs = Address.objects.filter(user=user) # 组织模板上下文context = &#123; 'skus':skus,'total_count':total_count, 'total_price':total_price, 'transit_price':transit_price, 'total_pay':total_pay, 'addrs':addrs&#125;return render(request, 'place_order.html', context) step5 在模板文件place_order.html中进行数据填坑 12345678910111213141516171819202122232425&lt;div class=\"common_list_con clearfix\"&gt; &lt;dl&gt; &lt;dt&gt;寄送到：&lt;/dt&gt; &#123;% for addr in addrs %&#125; &lt;dd&gt;&lt;input type=\"radio\" name=\"\" checked=\"\"&gt;&#123;&#123; addr.addr &#125;&#125; （&#123;&#123; addr.receiver &#125;&#125; 收） &#123;&#123; addr.phone &#125;&#125;&lt;/dd&gt; &#123;% endfor %&#125; &lt;/dl&gt; &lt;a href=\"&#123;% url 'user:address' %&#125;\" class=\"edit_site\"&gt;编辑收货地址&lt;/a&gt;&lt;/div&gt;&#123;% for sku in skus %&#125;&lt;ul class=\"goods_list_td clearfix\"&gt; &lt;li class=\"col01\"&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/li&gt; &lt;li class=\"col02\"&gt;&lt;img src=\"&#123;&#123; sku.image.url &#125;&#125;\"&gt;&lt;/li&gt; &lt;li class=\"col03\"&gt;&#123;&#123; sku.name &#125;&#125;&lt;/li&gt; &lt;li class=\"col04\"&gt;&#123;&#123; sku.unite &#125;&#125;&lt;/li&gt; &lt;li class=\"col05\"&gt;&#123;&#123; sku.price &#125;&#125;元&lt;/li&gt; &lt;li class=\"col06\"&gt;&#123;&#123; sku.count &#125;&#125;&lt;/li&gt; &lt;li class=\"col07\"&gt;&#123;&#123; sku.amount &#125;&#125;元&lt;/li&gt;&lt;/ul&gt;&#123;% endfor %&#125;&lt;div class=\"settle_con\"&gt; &lt;div class=\"total_goods_count\"&gt;共&lt;em&gt;&#123;&#123; total_count &#125;&#125;&lt;/em&gt;件商品，总金额&lt;b&gt;&#123;&#123; total_price &#125;&#125;元&lt;/b&gt;&lt;/div&gt; &lt;div class=\"transit\"&gt;运费：&lt;b&gt;&#123;&#123; transit_price &#125;&#125;元&lt;/b&gt;&lt;/div&gt; &lt;div class=\"total_pay\"&gt;实付款：&lt;b&gt;&#123;&#123; total_pay &#125;&#125;元&lt;/b&gt;&lt;/div&gt;&lt;/div&gt; step6 测试点击去结算按钮 step7 在提交订单页面上的收货地址，应该将数据库中默认的收货地址is_default字段为1的复选框checkbox状态为checked，而不应该全部地址都是勾选状态，所以在place_order.html中进行如下判断显示 1&lt;dd&gt;&lt;input type=\"radio\" name=\"addr_id\" value=\"&#123;&#123; addr.id &#125;&#125;\" &#123;% if addr.is_default %&#125;checked&#123;% endif %&#125;&gt;&#123;&#123; addr.addr &#125;&#125; （&#123;&#123; addr.receiver &#125;&#125; 收） &#123;&#123; addr.phone &#125;&#125;&lt;/dd&gt; step8 刷新页面 3.创建订单 step1 在提交订单页面，点击提交订单按钮，需要向后端传递提交订单页面中的收获地址和支付方式以及商品的id，即在place_order.html模板文件中需要手动去添加支付方式的value值对应后端订单模型类中的df_order_info表,收获地址前面已经进行设置了，所以不需要设置 12345678&lt;input type=\"radio\" name=\"pay_style\" value=\"1\" checked&gt;&lt;label class=\"cash\"&gt;货到付款&lt;/label&gt;&lt;input type=\"radio\" name=\"pay_style\" value=\"2\"&gt;&lt;label class=\"weixin\"&gt;微信支付&lt;/label&gt;&lt;input type=\"radio\" name=\"pay_style\" value=\"3\"&gt;&lt;label class=\"zhifubao\"&gt;&lt;/label&gt;&lt;input type=\"radio\" name=\"pay_style\" value=\"4\"&gt;&lt;label class=\"bank\"&gt;银行卡支付&lt;/label&gt; step2 收货地址和支付方式已经在前端模板中设置好了，最后需要设置的就是商品的id，需要在后端中进行组织好传递到前端模板文件的数据格式，提交订单页面中的商品id已经保存到厚度那中skus列表中了，现在将该列表保存的商品id以逗号进行拼接，传递到前端模板中 12345678sku_ids = ','.join(sku_ids) # 11,19,39,41# 组织模板上下文context = &#123; 'skus':skus,'total_count':total_count, 'total_price':total_price, 'transit_price':transit_price, 'total_pay':total_pay, 'addrs':addrs, 'sku_ids':sku_ids&#125; step3 在前端模板中提交订单按钮中，定义标签属性sku_ids 1&lt;a href=\"javascript:;\" sku_ids=&#123;&#123; sku_ids &#125;&#125; id=\"order_btn\"&gt;提交订单&lt;/a&gt; step4 在place_order.html模板文件中进行提交订单js代码编写，获取用户选择的收货地址，支付方式以及购买的商品id，并通过ajax post方式向后端发送请求 1234567891011$('#order_btn').click(function() &#123; // 获取用户选择的收货地址和支付方式以及商品id addr_id = $('input[name=\"addr_id\"]:checked').val(); pay_method = $('input[name=\"pay_style\"]:checked').val(); sku_ids = $(this).attr('sku_ids'); csrf = $('input[name=\"csrfmiddlewaretoken\"]').val(); params = &#123;\"addr_id\":addr_id, \"pay_method\":pay_method, \"sku_ids\":sku_ids, \"csrfmiddlewaretoken\":csrf&#125;; // 向后端/order/commit地址发送ajax post请求 $.post('/order/commit',params, function (data) &#123; &#125;); step5 紧接着在后端中定义类视图post方法，配置url路由 123456# /order/commitclass OrderCommitView(View): \"\"\"创建订单\"\"\" def post(self, request): passurl(r\"^commit$\", OrderCommitView.as_view(), name='commit'), # 创建订单 step6 判断用户是否登录，获取参数以及校验参数完整性 12345678910user = request.userif not user.is_authenticated(): return JsonResponse(&#123;\"errno\": 0, \"error_msg\": \"请先登录\"&#125;)# 获取参数addr_id = request.POST.get(\"addr_id\")pay_method = request.POST.get(\"pay_method\")sku_ids = request.POST.get(\"sku_ids\")# 校验参数if not all([addr_id, pay_method, sku_ids]): return JsonResponse(&#123;\"errno\": 1, \"error_msg\": \"参数不完整\"&#125;) step7 判断传递的支付方式以及收货地址是否合法 123456789# 判断前端传递过来的支付方式是否存在if pay_method not in OrderInfo.pay_method.key(): return JsonResponse(&#123;\"errno\": 2, \"error_msg\": \"非法的支付方式\"&#125;) # 判断前端传递过来的收货地址是否存在try: addr = Address.objects.get(id=addr_id)except Address.DoesNotExist: return JsonResponse(&#123;\"errno\": 3, \"error_msg\": \"非法的收货地址\"&#125;) step8 向df_order_info表中插入记录，提交订单会在df_order_info以及df_order_goods这两张表中各产生一条记录，由于df_order_goods表外键为df_order_info表，所以需要先在df_order_info表中产生订单记录，在df_order_info表字段中，还需要去获取order_id，total_count，total_price，transit_price 1234567891011121314#1 自定义order_id 20190408174330+用户id（作为唯一标识）order_id = datetime.now().strftime(\"%Y%m%d%H%M%S\") + str(user.id)#2 总件数和总金额初始设置为0total_count = 0total_price = 0#3 运费transit_price = 10 # todo: 向df_order_info表中插入记录order = OrderInfo.objects.create( order_id=order_id, user=user, addr=addr, pay_method=pay_method, total_count=total_count, total_price=total_price, transit_price=transit_price) step9 向df_order_goods表中插入记录，有多少种商品插入多少条记录 1234567891011121314151617181920212223242526conn = get_redis_connection(\"default\")cart_key = \"cart_%d\" % user.idsku_ids = sku_ids.split(',')for sku_id in sku_ids: # 获取商品信息 try: sku = GoodsSKU.objects.get(id=sku_id) except GoodsSKU.DoesNotExist: return JsonResponse(&#123;\"errno\": 4, \"error_msg\": \"商品不存在\"&#125;) # 从redis数据库中获取用户购买商品的数量 count = conn.hget(cart_key, sku_id) # todo:向df_order_goods表中添加记录 OrderGoods.objects.create( order=order,sku=sku, count=count,price=sku.price) # todo: 更新商品的库存和销量 sku.stock -= int(count) sku.sales += int(count) sku.save() # todo: 累加计算订单商品的总数量和总价格 amount = sku.price * int(count) total_count += int(count) total_price += amount step10 更新订单信息表df_order_info中的总件数和总金额 123order.total_count = total_countorder.total_price = total_priceorder.save() step11 清除用户购物车中的商品，最后返回给前端正确响应 123conn.hdel(cart_key, *sku_ids) # *sku_ids ---&gt; [1,2,3]变成1,2,3# 返回正确响应return JsonResponse(&#123;'errno':\"ok\", 'error_message':'订单创建成功'&#125;) step12 在place_order.html模板js中进行打印显示 12345678$.post('/order/commit',params, function (data) &#123; if(data.errno==\"ok\")&#123; alert(\"创建订单成功\") &#125; else &#123; alert(data.error_msg) &#125;&#125;); step13 创建订单测试 step14 查看数据库df_order_info表数据 step15 查看数据库df_order_goods表数据 4.订单生成使用mysql事务 step1 当某个商品库存只有2件时，有不止一个用户购物车添加了2个该商品，假设第一个用户提交订单，成功后，则后面的用户提交订单时，则应该提示用户商品库存不足 123# todo:判断用户购物车中商品的数量是否小于商品库存if int(count) &gt; sku.stock: return JsonResponse(&#123;\"errno\":\"5\", \"error_msg\":\"商品库存不足\"&#125;) step2 经过上面的判断后，当商品库存不足顾客订单上的商品数量时，则会提示商品库存不足，即不会在df_order_goods表中插入数据，但是会在df_order_info表中生成订单记录，这样肯定不对，商品不足的情况下即使生成了订单，那么订单的数据肯定是错误的，那么就需要使用事务的特性来帮助我们完成在插入数据时，要么成功，要么撤回，这是mysql事务原子性的体现，在django中使用数据库事务参考—Django数据库事务 123456from django.db import transaction @transaction.atomicdef viewfunc(request): # This code executes inside a transaction. do_stuff() step3 在df_order/views订单提交视图OrderCommitView中对post方法进行装饰，需要导入transaction模块 12@transaction.atomicdef post(self, request): step4 设置事务保存点，在进行数据库插入数据之前进行设置 12# 设置事务保存点save_id = transaction.savepoint() step5 在出现异常的时候，进行事务回滚 1transaction.savepoint_rollback(save_id) step6 将post函数中关于数据库操作的代码放在try中，当在任何地方出现异常时，全部进行回滚操作 1234567891011121314try: order = OrderInfo.objects.create( order_id=order_id, user=user, addr=addr, pay_method=pay_method, total_count=total_count, total_price=total_price, transit_price=transit_price) # 中间代码省略 order.total_count = total_count order.total_price = total_price order.save()except Exception as e: # 将整个关于数据操作的代码，放在try里面，任何地方出现异常，立即做事务回滚 transaction.savepoint_rollback(save_id) return JsonResponse(&#123;&quot;errno&quot;:6, &quot;error_msg&quot;:e &#125;) step7 在异常外面进行事务的提交操作 12# 没有出现异常则进行事务的提交操作transaction.savepoint_commit(save_id) 5.订单并发问题 悲观锁 说明：电商网站在做秒杀活动时，就会出现大量用户对同一商品进行购买，当该秒杀商品库存只有1个时，如果很多顾客同时进行点击购买，就会出现一个库存的商品卖了好几百个情况，导致并发生成订单问题 step1 使用悲观锁进行订单并发处理，悲观锁获取数据时对数据行了锁定，其他事务要想获取锁，必须等原事务结束，换句话说就是当用户1在做sql查询时，进行加锁，那么期间用户2使用同sql语句进行查询时，需要等待用户1事务提交或者回滚事务结束后解锁，才能进行操作；在数据库中对查询语句加锁就是在后面加上for update，如select * from df_goods_sku where id = 41 for update；在django中则在objects下有个select_for_update方法，等价于上面 1sku = GoodsSKU.objects.select_for_update().get(id=sku_id) step2 查看数据库中商品库存前五商品，库存最少的为商品id为8的盒装草莓 step3 进行测试，在查询商品信息代码后秒加上以下代码，打印出用户的id和商品库存信息，休眠10秒是为了演示效果，博主使用两个浏览器对商品id为8库存为1的盒装草莓进行购买 123print(\"用户id:%d,商品库存:%d\"%(user.id, sku.stock))import timetime.sleep(3) step4 查看数据库中该商品的库存与销量 乐观锁 说明：在查询数据的时候不加锁，在进行数据更新时判断更新时的库存和之前查出数据库的库存是否一致 step1 乐观锁，在更新商品库存时，条件为该商品的id以及商品的库存必须与更新之前的商品库存一致，才进行库存的更新，如update df_goods_sku set stock=0, sales=1 where id=8 and stock=1；当用户1购买商品成功则执行update语句那么就会修改stock的库存为0，那么用户2在购买商品时执行update语句时就不会成功，因为此时的where条件中的stock库存与购买前商品库存不一致导致条件不成立，就不会往下执行 12345678910# todo: 更新商品的库存和销量orgin_stock = sku.stocknew_stock = orgin_stock - int(count)new_sales = sku.sales + int(count)# update df_goods_sku set stock=0, sales=1 where id=8 and stock=1;res = GoodsSKU.objects.filter(id=sku_id, stock=orgin_stock).update(stock=new_stock, sales=new_sales)if res == 0: # 表示没有修改成功,进行事务的回滚操作 transaction.savepoint_rollback(save_id) return JsonResponse(&#123;\"errno\":6, \"error_msg\":\"下单失败\"&#125;) step2 进行测试前将数据库中商品id为8的商品库存设置为1 step3 进行测试，其中某个账户完成创建订单成功时，则原始库存与更新后的库存肯定不一致，另一个用户在执行到update语句时，则会出现无法修改，因为条件中的库存不等于原始库存 step4 当库存不止为1时，也就是说足够两个用户同时下单时，如果以原有库存与现有库存进行sql修改条件判断时，那么也同样会出现一个客户下单成功，另一个客户下单失败 解决方法 ①在mysql配置文件中（windows—my.ini linux—-mysqld.cnf）添加如下配置读取提交内容 12# 设置mysql数据库隔离级别transaction-isolation = READ-COMMITTED ②在视图中对逻辑代码进行三次尝试判断，当用户1创建订单成功，更新了库存，从头开始去执行查询最新库存进行判断，这样就不会出现在商品库存充足的情况下，多个顾客在同一时间对同一商品进行下单操作，出现只有一个用户下单成功的情况 123456789101112for sku_id in sku_ids: for i in range(3): # 代码省略 if res == 0: if i == 2: # 第三次尝试如果不成功执行下面代码 # 表示没有修改成功,进行事务的回滚操作 transaction.savepoint_rollback(save_id) return JsonResponse(&#123;\"errno\":6, \"error_msg\":\"下单失败\"&#125;) continue # 代码省略 # 一次成功则跳出循环 break 二丶订单支付1.在订单提交页面点击提交订单按钮，提交订单成功后应该跳转到用户中心—订单页面中 step1 在place_order.html模板文件中，当后端发回来的data数据errno值为ok表示提交成功，那么在js中进行如下编写，在页面显示出订单提交成功的提示，并跳转到用户中心订单页 12345678910111213141516$.post('/order/commit',params, function (data) &#123;if(data.errno==\"ok\")&#123; &#123;#alert(\"创建订单成功\")#&#125; localStorage.setItem('order_finish',2); $('.popup_con').fadeIn('fast', function() &#123; setTimeout(function () &#123; $('.popup_con').fadeOut('fast', function () &#123; window.open(data.pay_url) &#125;); &#125;, 3000) &#125;);&#125;else &#123; alert(data.error_msg)&#125;&#125;); step2 测试，当进行提交订单时，提示提交订单成功并跳转到用户中心订单页 2.获取并显示我的订单页面的数据 step1 因为在我的订单页面中需要用到分页，所以需要修改df_user/urls中订单的正则 1url(r\"^order/(?P&lt;page&gt;\\d+)$\", UserOrderView.as_view(), name=\"order\"), # 用户中心-订单 step2 将所有的页面涉及链接到我的订单页面的地址进行修改 12&lt;a href=\"&#123;% url 'user:order' 1 %&#125;\"&gt;我的订单&lt;/a&gt;&lt;li&gt;&lt;a href=\"&#123;% url 'user:order' 1 %&#125;\"&#123;% if page == 'order' %&#125;class=\"active\"&#123;% endif %&#125;&gt;· 全部订单&lt;/a&gt;&lt;/li&gt; step3 在df_user/views中UserOrderView类视图get中接收参数page 123456# /user/orderclass UserOrderView(LoginRequiredMixin, View): \"\"\"用户中心-订单\"\"\" def get(self, request, page): \"\"\"显示页面\"\"\" return render(request, \"user_center_order.html\", &#123;\"page\":\"order\"&#125;) step4 获取用户的所有订单信息 12user = request.userorders = OrderInfo.objects.filter(user=user) step5 遍历用户订单集获取 123456789for order in orders: order_skus = OrderGoods.objects.filter(order_id=order.order_id) for order_sku in order_skus: # 商品小计 amount = order_sku.count * order_sku.price # 动态的添加属性 order_sku.amount = amount # 动态添加属性 order.order_skus = order_skus step6 对数据进行分页显示 12345678910111213141516171819202122# 对数据进行分页paginator = Paginator(orders, 2) # Show 25 contacts per page# 获取页数try: page = int(page)except Exception as e: page = 1# 判断用户传递过来的页数，是否小于总页数，大于总页数则设置第一页if page &gt; paginator.num_pages: page = 1 order_page = paginator.page(page) num_pages = paginator.num_pagesif num_pages &lt; 5: pages = range(1, num_pages + 1)elif page &lt;= 3: pages = range(1, 6)elif num_pages - page &lt;= 2: pages = range(num_pages - 4, num_pages + 1)else: pages = range(page - 2, page + 3) step7 组织模板上下文，返回给前端模板 123456# 组织模板上下文context=&#123; \"order_page\":order_page,\"pages\":pages, \"page\": \"order\"&#125; return render(request, \"user_center_order.html\",context) step8 在user_center_order.html中进行数据填坑 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div class=\"right_content clearfix\"&gt; &lt;h3 class=\"common_title2\"&gt;全部订单&lt;/h3&gt; &#123;% for order in order_page %&#125; &lt;ul class=\"order_list_th w978 clearfix\"&gt; &lt;li class=\"col01\"&gt;&#123;&#123; order.create_time &#125;&#125;&lt;/li&gt; &lt;li class=\"col02\"&gt;订单号：&#123;&#123; order.order_id &#125;&#125;&lt;/li&gt; &lt;li class=\"col02 stress\"&gt;&#123;&#123; order.order_status &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;table class=\"order_list_table w980\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width=\"55%\"&gt; &#123;% for order_sku in order.order_skus %&#125; &lt;ul class=\"order_goods_list clearfix\"&gt; &lt;li class=\"col01\"&gt;&lt;img src=\"&#123;&#123; order_sku.sku.image.url &#125;&#125;\"&gt;&lt;/li&gt; &lt;li class=\"col02\"&gt;&#123;&#123; order_sku.sku.name &#125;&#125;&lt;em&gt;&#123;&#123; order_sku.price &#125;&#125;元/&#123;&#123; order_sku.sku.unite &#125;&#125;g&lt;/em&gt;&lt;/li&gt; &lt;li class=\"col03\"&gt;&#123;&#123; order_sku.count &#125;&#125;&lt;/li&gt; &lt;li class=\"col04\"&gt;&#123;&#123; order_sku.amount &#125;&#125;元&lt;/li&gt; &lt;/ul&gt; &#123;% endfor %&#125; &lt;/td&gt; &#123;% comment %&#125;add过滤器作加法计算&#123;% endcomment %&#125; &lt;td width=\"15%\"&gt;&#123;&#123; order.total_price |add:order.transit_price&#125;&#125;(含运费:&#123;&#123; order.transit_price &#125;&#125;)元&lt;/td&gt; &lt;td width=\"15%\"&gt;&#123;&#123; order.order_status &#125;&#125;&lt;/td&gt; &lt;td width=\"15%\"&gt;&lt;a href=\"#\" class=\"oper_btn\"&gt;去付款&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &#123;% endfor %&#125; &lt;div class=\"pagenation\"&gt; &#123;% if order_page.has_previous%&#125; &lt;a href=\"&#123;% url 'user:order' order_page.previous_page_number %&#125;\"&gt;&lt;上一页&lt;/a&gt; &#123;% endif %&#125; &#123;% for pindex in pages %&#125; &#123;% if pindex == order_page.number %&#125; &lt;a href=\"&#123;% url 'user:order' pindex %&#125;\" class=\"active\"&gt;&#123;&#123; pindex &#125;&#125;&lt;/a&gt; &#123;% else %&#125; &lt;a href=\"&#123;% url 'user:order' pindex %&#125;\"&gt;&#123;&#123; pindex &#125;&#125;&lt;/a&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if order_page.has_next %&#125; &lt;a href=\"&#123;% url 'user:order' order_page.next_page_number %&#125;\"&gt;下一页&gt;&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt;&lt;/div&gt; step9 刷新页面成功将数据库数据显示到页面上 step10 在上图中会发现订单状态一栏显示的并不是未支付已支付已完成等状态，而是显示的数字1，因为订单创建到数据库中状态栏保存的就是为数字，这里需要进行获取订单状态信息；在视图中向order对象中动态添加对应模型中的状态名 12# 动态添加属性，保存订单状态order.status_name = OrderInfo.ORDER_STATUS[order.order_status] step11 然后紧接着在user_center_order.html模板中将替换成即可，刷新页面成功显示出状态名 step12 一般来说在我的订单页面中，第一页显示的肯定是最新创建的，所以需要按照创建时间进行排序 1orders = OrderInfo.objects.filter(user=user).order_by('-create_time') step13 细节就是在js中，当创建订单成功即跳转到我的订单页，因为之前显示订单页时，没有做分页，不需要传递page页数 1window.location.href = '/user/order/1'; step14 刷新页面则按照创建订单倒序进行显示，也就是显示出最新创建的订购单 3.接入支付宝进行订单支付 step1 进入支付宝开放平台https://open.alipay.com/platform/home.htm，在开发中心—沙箱中，创建应用，详细说明请查看https://blog.csdn.net/qq_41782425/article/details/86699086 step2 网站向支付宝平台发送支付请求，采用的是网络请求方式，下图为应用于支付宝平台秘钥验证导图 step3 进入电脑网站支付，查看开发说明文档 step4 因为支付宝官方没有提供python语言的SDK，需要在https://github.com/fzlee/alipay/blob/master/README.zh-hans.md上去使用他人封装好的python编写的支付宝SDK，在df_order/views中创建OrderPayView类视图post方法 12345# /order/payclass OrderPayView(View): \"\"\"订单支付\"\"\" def post(self, request): pass step5 判断用户是否登录并接收参数 12345user = request.userif not user.is_authenticated(): return redirect(reverse('user:login'))# 接收参数order_id = request.POST.get(\"order_id\") step6 校验参数 123456if not order_id: return JsonResponse(&#123;\"errno\":1, \"error_msg\":\"参数不完整\"&#125;)try: order = OrderInfo.objects.get(order_id=order_id, user=user, pay_method=3, order_status=1)except OrderInfo.DoesNotExist: return JsonResponse(&#123;\"errno\":2, \"error_msg\":\"无效订单\"&#125;) step7 调用支付宝接口，并传递必要参数，最后向模板返回响应数据 123456789101112131415161718192021222324# todo: 使用支付宝python SDK工具，调用支付宝支付接口# 初始化alipay = AliPay( appid=\"\", # 应用id app_notify_url=None, # 默认回调url app_private_key_path=os.path.join(settings.BASE_DIR, 'apps/df_order/app_private_key.pem'), # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥, alipay_public_key_path=os.path.join(settings.BASE_DIR, 'apps/df_order/alipay_public_key.pem'), sign_type=\"RSA2\", # RSA 或者 RSA2 debug = True # 默认False)# 电脑网站支付，需要跳转到https://openapi.alipay.com/gateway.do? + order_stringtotal_pay = order.total_price + order.transit_priceorder_string = alipay.api_alipay_trade_page_pay( out_trade_no=order_id, #订单编号 total_amount=str(total_pay), subject=u\"天天生鲜&lt;%s&gt;\" % order_id, return_url=None, notify_url=None # 可选, 不填则使用默认notify url)# 构造用户跳转的支付链接地址pay_url = \"https://openapi.alipaydev.com/gateway.do?\" + order_string return JsonResponse(&#123;\"errno\":\"ok\", \"pay_url\":pay_url&#125;) step8 配置支付路由 1url(r\"^pay$\", OrderPayView.as_view(), name='pay'), # 订单支付 step9 在user_center_order.html模板中编写js，需要在去支付按钮标签中获取订单编号以及订单的状态，当状态为1表示该订单为待支付状态，此时才会向后端接口发送ajax post请求，后端返回正确响应，则引导客户到支付宝支付界面，进行支付 123456789101112131415161718192021222324&lt;td width=\"15%\"&gt;&lt;a href=\"#\" order_id=\"&#123;&#123; order.order_id &#125;&#125;\" status=\"&#123;&#123; order.order_status &#125;&#125;\" class=\"oper_btn\"&gt;去付款&lt;/a&gt;&lt;/td&gt;&lt;script&gt; $('.oper_btn').click(function () &#123; // 获取页面上订单状态 status = $(this).attr('status') if(status == 1)&#123; // 状态为1表示待支付状态 // 获取订单id order_id = $(this).attr('order_id'); csrf = $('input[name=\"csrfmiddlewaretoken\"]').val(); params = &#123;\"order_id\":order_id, \"csrfmiddlewaretoken\":csrf&#125;; // 向后端接口/order/pay 发送ajax post请求 $.post('/order/pay', params, function (data) &#123; if(data.errno==\"ok\")&#123; // 引导客户到支付界面 window.open(data.pay_url) &#125; else &#123; alert(data.error_msg) &#125; &#125;) &#125; &#125;)&lt;/script&gt; step10 测试点击去付款跳转到支付宝支付页面 step11 支付测试利用沙箱买家账号进行支付测试 4.获取支付宝支付结果 step1 在项目中使用支付宝整个流程图 step2 在user_center_order.html模板中当打开支付界面后，即向/order/check后端接口发送ajax post请求，传递参数为订单号order_id，在后端接口中调用支付宝检查支付结果的接口，获取支付结果信息返回正确响应到前端模板页面中 12345678910$.post('/order/check', params, function (data) &#123; // 判断用户是否支付成功 if(data.errno==\"ok\")&#123; alert(\"支付成功\"); location.reload() &#125; else &#123; alert(data.error_msg) &#125;&#125;) step3 在df_order/views中定义类视图post方法 12345# /order/checkclass OrderCheckView(View): \"\"\"查看支付宝支付结果\"\"\" def post(self, request): pass step4 判断用户是否登录获取参数校验参数以及对支付宝工具初始化，跟前面写的支付宝支付视图逻辑一样 12345678910111213141516171819202122232425# 判断用户是否登录user = request.userif not user.is_authenticated(): return redirect(reverse('user:login'))# 接收参数order_id = request.POST.get(\"order_id\")# 校验参数if not order_id: return JsonResponse(&#123;\"errno\": 1, \"error_msg\": \"参数不完整\"&#125;)try: order = OrderInfo.objects.get(order_id=order_id, user=user, pay_method=3, order_status=1)except OrderInfo.DoesNotExist: return JsonResponse(&#123;\"errno\":2, \"error_msg\":\"无效订单\"&#125;) # todo: 使用支付宝python SDK工具，调用支付宝支付接口# 初始化alipay = AliPay( appid=\"\", # 应用id app_notify_url=None, # 默认回调url app_private_key_path=os.path.join(settings.BASE_DIR, 'apps/df_order/app_private_key.pem'), # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥, alipay_public_key_path=os.path.join(settings.BASE_DIR, 'apps/df_order/alipay_public_key.pem'), sign_type=\"RSA2\", # RSA 或者 RSA2 debug = True # 默认False) step5 调用sdk工具中支付宝交易查询接口，根据返回的response数据中的code接口状态码以及支付状态trade_status来判断支付是否成功 1234567891011121314151617181920212223while True: response = alipay.api_alipay_trade_query(order_id) # 从支付宝返回的响应数据中获取code以及trade_status code = response.get(\"code\") trade_status = response.get(\"trade_status\") if code == '10000' and trade_status == \"TRADE_SUCCESS\": # 表示成功 # 获取支付宝交易号 trade_no = response.get(\"trade_no\") # 更新订单状态 order.trade_no = trade_no order.order_status = 4 # 待评价 order.save() # 返回正确响应 return JsonResponse(&#123;\"errno\":\"ok\", \"error_msg\":\"交易成功\"&#125;) elif code == '40004' or (code == '10000' and trade_status == \"WAIT_BUYER_PAY\"): # 业务处理失败以及等待买家付款 import time time.sleep(5) # 休眠5秒再次调用支付宝交易查询接口，重新获取状态码以及支付状态信息 continue else: return JsonResponse(&#123;\"errno\":4, \"error_msg\":\"交易失败\"&#125;) step6 配置urls路由 1url(r\"^check$\", OrderCheckView.as_view(), name='check'), # 订单支付结果 step7 进行订单支付，查看返回的支付结果，以及订单状态 三丶订单评论1.显示订单评价页面 step1 当订单支付成功后，订单状态变为待评价，但该订单却还显示去支付按钮 step2 将已经支付成功的订单对应显示出去评价按钮，在js中进行遍历判断status状态，设置对应状态对应的功能 12345678910111213$('.oper_btn').each(function () &#123; // 获取订单状态 status = $(this).attr('status'); if(status == 1)&#123; $(this).text('去支付') &#125; else if(status == 4)&#123; $(this).text('去评价') &#125; else if(status == 5)&#123; $(this).text('已完成') &#125;&#125;); step3 刷新页面，显示正确订单状态对应的功能按钮 step4 当用户点击去评价时，在点击事件中，判断如果status状态为4，则跳转到评论地址，传递参数order_id，博主在测试时候发现location.href无法跳转，解决方法就是在下面添加return false即可 12345678910111213141516171819202122232425262728293031323334353637$('.oper_btn').click(function () &#123; // 获取页面上订单状态 status = $(this).attr('status'); // 获取订单id order_id = $(this).attr('order_id'); if(status == 1)&#123; // 状态为1表示待支付状态 csrf = $('input[name=\"csrfmiddlewaretoken\"]').val(); params = &#123;\"order_id\":order_id, \"csrfmiddlewaretoken\":csrf&#125;; // 向后端接口/order/pay 发送ajax post请求 $.post('/order/pay', params, function (data) &#123; if(data.errno==\"ok\")&#123; // 引导客户到支付界面 window.open(data.pay_url); // 向/order/check 发起请求查询支付宝支付结果 $.post('/order/check', params, function (data) &#123; // 判断用户是否支付成功 if(data.errno==\"ok\")&#123; alert(\"支付成功\"); location.reload() &#125; else &#123; alert(data.error_msg) &#125; &#125;) &#125; else &#123; alert(data.error_msg) &#125; &#125;) &#125; else if(status == 4)&#123; // 去评价 location.href = '/order/comment/' + order_id return false; &#125;&#125;) step5 在df_order/views中定义类视图get方法，显示评论页面 123456# /order/commentclass OrderCommentView(LoginRequiredMixin, View): \"\"\"订单评价\"\"\" def get(self, request, order_id): \"\"\"显示评论页面\"\"\" pass step6 校验参数，参数不存在或者参数不正确则跳转到订单页面 12345678user = request.user# 校验数据if not order_id: return redirect(reverse('user:order'))try: order = OrderInfo.objects.get(order_id=order_id, user=user)except OrderInfo.DoesNotExist: return redirect(reverse(\"user:order\")) step7 获取订单商品信息，遍历商品信息，获取每个商品的小计，动态给订单对象添加属性 1234567891011# 获取订单商品信息order_skus = OrderGoods.objects.filter(order_id=order_id)for order_sku in order_skus: # 计算商品的小计 amount = order_sku.count * order_sku.price # 动态给order_sku增加属性amount,保存商品小计 order_sku.amount = amount# 动态给order增加属性order_skus, 保存订单商品信息order.order_skus = order_skus# 渲染模板return render(request, \"order_comment.html\", &#123;\"order\": order&#125;) step8 在df_order/urls中配置视图url 1url(r\"^comment/(?P&lt;order_id&gt;.+)$\", OrderCommentView.as_view(), name='comment'), # 订单评价 step9 在将user_center_order.html复制到templates目录下命名为order_comment.html，进行如下编写 123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=\"right_content clearfix\"&gt; &lt;h3 class=\"common_title2\"&gt;订单评价&lt;/h3&gt; &lt;ul class=\"order_list_th w978 clearfix\"&gt; &lt;li class=\"col01\"&gt;&#123;&#123;order.create_time&#125;&#125;&lt;/li&gt; &lt;li class=\"col02\"&gt;订单号：&#123;&#123;order.order_id&#125;&#125;&lt;/li&gt; &lt;li class=\"col02 stress\"&gt;&#123;&#123;order.status_name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;form method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;# 订单id #&#125; &lt;input type=\"hidden\" name=\"order_id\" value=\"&#123;&#123;order.order_id&#125;&#125;\"&gt; &#123;# 订单中有几个商品 #&#125; &lt;input type=\"hidden\" name=\"total_count\" value=\"&#123;&#123;order.order_skus|length&#125;&#125;\"&gt; &#123;% for order_sku in order.order_skus %&#125; &lt;table class=\"order_list_table w980\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width=\"80%\"&gt; &lt;ul class=\"order_goods_list clearfix\"&gt; &lt;li class=\"col01\"&gt;&lt;img src=\"&#123;&#123; order_sku.sku.image.url &#125;&#125;\"&gt;&lt;/li&gt; &lt;li class=\"col02\"&gt;&#123;&#123;order_sku.sku.name&#125;&#125;&lt;em&gt;&#123;&#123;order_sku.price&#125;&#125;/&#123;&#123;order_sku.sku.unite&#125;&#125;&lt;/em&gt;&lt;/li&gt; &lt;li class=\"col03\"&gt;&#123;&#123;order_sku.count&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;td width=\"20%\"&gt;&#123;&#123;order_sku.amount&#125;&#125;元&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=\"site_con\"&gt; &lt;input type=\"hidden\" name=\"sku_&#123;&#123;forloop.counter&#125;&#125;\" value=\"&#123;&#123;order_sku.sku.id&#125;&#125;\"&gt; &lt;div class=\"form_group form_group2\"&gt; &lt;label&gt;评价内容：&lt;/label&gt; &lt;textarea class=\"site_area\" name=\"content_&#123;&#123;forloop.counter&#125;&#125;\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;input type=\"submit\" name=\"\" value=\"提交\" class=\"info_submit\"&gt; &lt;/form&gt;&lt;/div&gt; step10 点击去评价功能按钮，测试显示订单评价页面 2.处理评论内容 step1 在OrderCommentView类视图中定义post方法，在方法中对参数进行校验 123456789user = request.user# 校验数据if not order_id: return redirect(reverse('user:order')) try: order = OrderInfo.objects.get(order_id=order_id, user=user)except OrderInfo.DoesNotExist: return redirect(reverse(\"user:order\")) step2 获取表单提交中的评论条数 12total_count = request.POST.get(\"total_count\")total_count = int(total_count) step3 循环遍历获取订单中商品的评论内容，设置df_order_goods表中的comment字段的内容为客户填写的评论内容content 1234567891011for i in range(1, total_count + 1): # 获取评论的商品的id sku_id = request.POST.get(\"sku_%d\" % i) # sku_1 sku_2 # 获取评论的商品的内容 content = request.POST.get('content_%d' % i, '') # cotent_1 content_2 content_3 try: order_goods = OrderGoods.objects.get(order=order, sku_id=sku_id) except OrderGoods.DoesNotExist: continue order_goods.comment = content order_goods.save() step4 最后设置订单状态为5也就是已完成状态，重定向到订单页面第一页 123order.order_status = 5 # 已完成order.save()return redirect(reverse(\"user:order\", kwargs=&#123;\"page\": 1&#125;)) step5 测试订单评论功能 step6 查看上一步中评论的商品详情信息，刚商品的评论信息显示到了商品介绍一栏，正确来说应该在评论里面 3.显示评论信息 step1 在商品详情页面（detail.html）模板文件中，li标签模块商品介绍以和评论，分别添加id属性；同时在div标签中分别添加id属性，需要主要的是评论内容默认是不显示的，所以在.tab_content标签中添加style=”display: none” 123456789101112131415161718&lt;ul class=\"detail_tab clearfix\"&gt; &lt;li id=\"tag_detail\" class=\"active\"&gt;商品介绍&lt;/li&gt; &lt;li id=\"tag_comment\"&gt;评论&lt;/li&gt;&lt;/ul&gt;&lt;div class=\"tab_content\" id=\"tab_detail\"&gt; &lt;dl&gt; &lt;dt&gt;商品详情：&lt;/dt&gt; &lt;dd&gt;&#123;&#123; sku.goods.detail |safe &#125;&#125;&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;div class=\"tab_content\" id=\"tab_comment\" style=\"display: none\"&gt; &lt;dl&gt; &#123;% for comment in sku_orders_comment %&#125; &lt;dt&gt;评论时间：&#123;&#123; comment.update_time &#125;&#125;&amp;nbsp;&amp;nbsp;&#123;&#123; comment.order.user.username &#125;&#125;&lt;/dt&gt; &lt;dd&gt;评论内容：&#123;&#123; comment.comment |safe &#125;&#125;&lt;/dd&gt; &#123;% endfor %&#125; &lt;/dl&gt;&lt;/div&gt; step2 刷新页面后，商品介绍li模块中不再显示出评论内容 step3 添加如下js控制商品介绍模块与评论模块点击事件显示激活与内容 123456789101112$('#tag_detail').click(function () &#123; $('#tag_comment').removeClass('active'); $(this).addClass('active'); $('#tab_detail').show(); $('#tab_comment').hide();&#125;);$('#tag_comment').click(function () &#123; $('#tag_detail').removeClass('active'); $(this).addClass('active'); $('#tab_detail').hide(); $('#tab_comment').show();&#125;); step4 测试商品介绍与评论点击事件显示对应内容（商品详情当初在创建表数据时，没有填写，所以显示空） 四丶项目部署1.使用uwsgi作为项目运行的web服务器 说明：在开发环境中运行项目需要在终端上执行python2 manage.py runserver命令，其中runserver就是django给我们提供的web服务器；uwsgi服务器就是遵循WSGI协议的web服务器 step1 安装uwsgi服务器 step2 博主将windows中的dailyfresh项目拷贝到ubuntu桌面，需要在ubuntu中配置项目配置文件settings的mysql数据库为windows中的mysql数据库，因为ubuntu中的mysql数据库表中没有任何数据，需要注意的是windows上的防火墙必须处于关闭状态 ，在windows mysql中需要创建一个用户并且该用户只能使用dailyfresh数据库，即将该用户配置到ubuntu项目settings配置文件中 1grant all privileges on dailyfresh.* to &quot;taogang&quot;@&quot;%&quot; identified by &quot;123456&quot; step3 在ubuntu中进行远程连接windows中的mysql step4 ubuntu中配置setting数据库连接 step5 在ubuntu中启动项目，进入http://127.0.0.1:8000/index后，成功显示出主页内容 step6 修改项目settings配置文件中的调试模式以及允许的主机访问为任何一台主机都可以进行访问 step7 在项目根目录下创建一个uwsgi.ini配置文件，编写以下内容 12345678910111213141516[uwsgi]#使用nginx连接时使用#socket=127.0.0.1:8080#直接做web服务器使用http=127.0.0.1:8080#项目目录chdir=/home/taogang/Desktop/dailyfresh#项目中wsgi.py文件的目录，相对于项目目录wsgi-file=dailyfresh/wsgi.py# 工作进程数processes=4threads=2master=Truepidfile=uwsgi.piddaemonize=uwsgi.logvirtualenv=/home/taogang/.virtualenvs/django_py2 step8 启动uwsgi 1启动:uwsgi –-ini 配置文件路径 例如:uwsgi –-ini uwsgi.ini step9 启动uwsgi后，在浏览器输入http://127.0.0.1:8080/index后，显示出主页页面，但不能加载静态文件，原因是在settings中配置DEBUG=False导致的，当DEBUG=True时，django服务器会帮我们去加载静态文件，但现在使用uwsgi服务器，该服务器不会帮我们加载静态文件 step10 停止uwsgi 1停止:uwsgi --stop uwsgi.pid路径 例如:uwsgi –-stop uwsgi.pid 2.部署架构图 3.配置nginx将用户请求转交给uwsgi step1 修改项目根目录下的uwsgi.ini文件，注释掉http请求（即在浏览器输入http://127.0.0.1:8080/index不能直接访问），取消socket注释，使用nginx来连接uwsgi 12345[uwsgi]#使用nginx连接时使用socket=127.0.0.1:8080#直接做web服务器使用#http=127.0.0.1:8080 step2 因为没有多余的电脑当做nginx服务器来将请求转发到uwsgi服务器上，所以博主这里打算使用ubuntu中的nginx，进入nginx配置文件，首先博主将之前nginx的配置进行了备份处理，再进行如下编写 step3 重启nginx服务以及启动uwsgi服务 step4 在浏览器输入http://127.0.0.1/index，因为不输入端口号默认为80端口即也就是在nginx监听端口，在80监听端口中，配置了location / 中包含uwsgi的请求参数，并将请求转给uwsgi服务器127.0.0.1:8080也就是在项目根目录下的uwsgi.ini配置文件中配置的socket地址，uwsgi服务器调用django项目中的application接口，将页面返回给nginx服务器，最后nginx服务器将页面返回给浏览器 说明：因为博主在进行项目迁移到ubuntu时，使用python manage.py runserver启动项目后，访问主页并在ubuntu redis数据库中设置了主页的缓存，所以显示了带有静态资源的主页 4.配置nginx处理静态文件 step1 在ubuntu中创建static目录用户存放项目使用的静态文件 step2 修改static目录的权限 step3 django settings.py中配置收集静态文件路径 12# 配置收集静态文件路径STATIC_ROOT = &apos;/usr/www/dailyfresh/static&apos; step4 收集项目所使用的静态文件 1python manage.py collectstatic step4 编写nginx配置文件，指定静态文件的目录 step5 重启nginx服务 step6 在火狐浏览器中打开禁用缓存按钮，刷新页面成功加载静态文件资源 step7 浏览其他页面是否也能成功加载静态文件 5.通过nginx调度服务器将用户请求转发到其他地址上 step1 整个部署架构说明，当用户在浏览器中输入127.0.0.1也就是http://127.0.0.1:80/，因为在浏览器中默认端口为80，所以写不写无所谓，即访问了 / 地址，表示用户请求的是网站的静态主页面；当用户在浏览器中输入除了 / 以外的地址，比如127.0.0.1/index，即访问了 /index 地址，表示用户请求的是动态资源主页面，前面博客中写到主页面静态化时，是在虚拟机ubuntu2中使用celery异步生成主页静态页面，通过访问ubuntu2中的nginx服务器的ip+/，匹配nginx服务器中配置的location来获取指定celery异步生成的静态主页index.html文件，最终通过nginx服务器返回给浏览器，浏览器渲染到页面；而现在项目部署需要使用uwsgi服务器来运行项目，而不是用django提供的测试环境服务器，那么就需要另外一台电脑来作为动态资源服务器（ubuntu1），那么就需要使用调度服务器也就是另一台nginx服务器（ubuntu1）来根据用户请求地址的不同分为两种 / 和其他（访问其他就是除了/以外的请求，在项目中就是/index 和/static）来进行调度，用户请求的是 / 则调度器向静态页面服务器（ubuntu2）去获取静态资源数据，如果不是访问 / 则向动态资源服务器（ubuntu1）获取动态资源数据，页面中静态资源的路径为/static下的某个路径即在调度器nginx中则直接去本地/usr/www/dailyfresh/static目录中直接获取文件，需要注意的是在ubuntu1电脑中安装了nginx服务器和uwsgi服务器以及django项目，通过前面进行测试一样，通过nginx服务器来访问uwsgi服务器，然后uwsgi服务器再通过调用django项目的application接口来运行项目，无非就是多添加了一个 / 地址请求静态主页面的服务器，即需要两台ubuntu虚拟机，其中ubuntu1负责调度器以及动态资源服务器使用，而ubuntu2则只是提供静态页面，充当静态页面服务器，因为博主的电脑实在是运行不了两台虚拟机以及本机的windows，所以无法进行演示操作 step2 通过上一步的详细说明，那么就需要在ubuntu1中配置nginx服务器（动态页面服务器+调度器） 说明：location = / 唯一的当满足请求地址只能是 / 的时候，才能进行匹配转发 step3 ubuntu2中配置nginx服务器（静态页面服务器），该配置也就是之前做主页静态化时的配置 6.nginx配置upstream实现负载均衡 step1 最终部署项目流程图 step2 对于动态资源服务器（应用服务器）可以有多台，即每台都是uwsgi+django，但每台应用服务器配置连接nginx服务器（调度器）的socket端口不同，如第一台配置8080，第二天配置8081，在启动uwsgi时各自执行自己的uwsgi – ini uwsgi.ini；那么就需要在调度器（nginx）中进行如下配置，当用户请求 / 开头的任何地址即请求动态资源，则会upstream指定dailyfresh中均衡拿取地址，进行转发，比如说用户访问主页则是启动了127.0.0.1:8080此uwsgi服务器获取的资源，当用户在主页点击某个商品进行商品详情页时，则调度器（nginx）会将请求转发给127.0.0.1:8081端口的uwsgi服务器，由该服务器来获取商品详情页所需要的资源数据，这样做就能达到负载均衡 12345678910111213141516171819202122232425262728upstream dailyfresh&#123; server 127.0.0.1:8080; server 127.0.0.1:8081;&#125; #gzip on;server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location /static &#123; # 指定静态文件存放的目录 alias /usr/www/dailyfresh/static; &#125; location / &#123; # 包含uwsgi的请求参数 include uwsgi_params; # 转交请求给uwsgi #uwsgi_pass 127.0.0.1:8080; uwsgin_pass dailyfresh; location = / &#123; # 转发到静态资源服务器 proxy_pass http://171.213.28.217; &#125; 五丶项目总结12345678910111213141516171819201. 生鲜类产品 B2C PC电脑端网页2. 功能模块：用户模块 商品模块（首页、 搜索、商品） 购物车模块 订单模块（下单、 支付）3. 用户模块：注册、登录、激活、退出、个人中心、地址4. 商品模块：首页、详情、列表、搜索（haystack+whoosh）5. 购物车： 增加、删除、修改、查询6. 订单模块：确认订单页面、提交订单（下单）、请求支付、查询支付结果、评论7. django默认的认证系统 AbstractUser8. itsdangerous 生成签名的token （序列化工具 dumps loads）9. 邮件 （django提供邮件支持 配置参数 send_mail）10. celery (重点 整体认识 异步任务)11. 页面静态化 （缓解压力 celery nginx）12. 缓存（缓解压力， 保存的位置、有效期、与数据库的一致性问题）13. FastDFS (分布式的图片存储服务， 修改了django的默认文件存储系统)14. 搜索（ whoosh 索引 分词）15. 购物车redis 哈希 历史记录redis list16. ajax 前端用ajax请求后端接口17. 事务18. 高并发的库存问题 （悲观锁、乐观锁）19. 支付的使用流程20. nginx （负载均衡 提供静态文件） ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/89059800","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目之Web端电商网站的实战开发（五）","slug":"Django项目之Web端电商网站的实战开发（五）","date":"2019-11-07T06:07:04.193Z","updated":"2019-11-13T14:26:17.318Z","comments":true,"path":"2019/11/07/Django项目之Web端电商网站的实战开发（五）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/07/Django项目之Web端电商网站的实战开发（五）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶天天生鲜详情页 二丶天天生鲜列表页 三丶天天生鲜商品搜索 四丶添加商品到购物车 五丶天天生鲜我的购物车页","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶天天生鲜详情页 二丶天天生鲜列表页 三丶天天生鲜商品搜索 四丶添加商品到购物车 五丶天天生鲜我的购物车页 一丶天天生鲜详情页1.显示商品详情页 step1 在df_goods/views中定义类视图get方法渲染详情页模板 123456# /goods/商品idclass DetailView(View): \"\"\"详情页\"\"\" def get(self, request, goods_id): \"\"\"显示商品详情页\"\"\" return render(request, \"detail.html\") step2 在df_goos/urls中定义详情页路由 1url(r\"^goods/(?P&lt;goods_id&gt;\\d+)$\", DetailView.as_view(), name=\"detail\"), # 详情页 step3 在浏览器直接输入 2.获取商品详情页信息 step1 根据商品goods_id,获取商品信息，如果查询不到则返回首页 12345try: sku = GoodsSKU.objects.get(id=goods_id)except GoodsSKU.DoesNotExist: # 此goods_id的商品不存在 return redirect(reverse(\"goods:index\")) step2 获取所有的商品类型 1types = GoodsType.objects.all() step3 从订单模块中根据查询到的sku对象查询出评论不为空的评论信息 1sku_orders_comment = OrderGoods.objects.filter(sku=sku).exclude(comment='') step4 根据查询到的商品sku对象获取商品信息按照创建时间进行倒序排序并且只显示最前面两个 1new_skus = GoodsSKU.objects.filter(type=sku.type).order_by('-create_time')[:2] step5 获取用户购物车中商品的数目 12345678910# 获取用户购物车中商品的数目user = request.user # 获取user对象cart_count = 0 # 默认设置为0# 获取商品详情页中的购物车数目信息if user.is_authenticated(): # 如果返回True表示用户已登录 # 用户已登录 conn = get_redis_connection('default') # 获取配置中default默认redis连接对象 cart_key = 'cart_%d' % user.id # 设置key # 通过hlen方法获取购物车商品数目 cart_count = conn.hlen(cart_key) step6 定义模板上下文，并返回 12345# 定义模板上下问content = &#123;\"types\":types, \"sku\":sku, \"sku_orders_comment\":sku_orders_comment, \"new_skus\":new_skus, \"cart_count\":cart_count&#125;return render(request, \"detail.html\", content) step7 在商品详情页父模板base_detail_list.html中，获取全部分类信息 12345&lt;ul class=\"subnav\"&gt; &#123;% for type in types %&#125; &lt;li&gt;&lt;a href=\"&#123;% url 'goods:list' type.id 1 %&#125;\" class=\"&#123;&#123; type.logo &#125;&#125;\"&gt;&#123;&#123; type.name &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; step8 在商品详情页detail.html模板中进行数据填坑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;div class=\"breadcrumb\"&gt; &lt;a href=\"#\"&gt;全部分类&lt;/a&gt; &lt;span&gt;&gt;&lt;/span&gt; &lt;a href=\"#\"&gt;&#123;&#123; sku.type.name &#125;&#125;&lt;/a&gt; &lt;span&gt;&gt;&lt;/span&gt; &lt;a href=\"#\"&gt;商品详情&lt;/a&gt;&lt;/div&gt;&lt;div class=\"goods_detail_con clearfix\"&gt; &lt;div class=\"goods_detail_pic fl\"&gt;&lt;img src=\"&#123;&#123; sku.image.url &#125;&#125;\"&gt;&lt;/div&gt; &lt;div class=\"goods_detail_list fr\"&gt; &lt;h3&gt;&#123;&#123; sku.name &#125;&#125;&lt;/h3&gt; &lt;p&gt;&#123;&#123; sku.desc &#125;&#125;&lt;/p&gt; &lt;div class=\"prize_bar\"&gt; &lt;span class=\"show_pirze\"&gt;¥&lt;em&gt;&#123;&#123; sku.price &#125;&#125;&lt;/em&gt;&lt;/span&gt; &lt;span class=\"show_unit\"&gt;单 位：&#123;&#123; sku.unite &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"goods_num clearfix\"&gt; &lt;div class=\"num_name fl\"&gt;数 量：&lt;/div&gt; &lt;div class=\"num_add fl\"&gt; &lt;input type=\"text\" class=\"num_show fl\" value=\"1\"&gt; &lt;a href=\"javascript:;\" class=\"add fr\"&gt;+&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"minus fr\"&gt;-&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"total\"&gt;总价：&lt;em&gt;16.80元&lt;/em&gt;&lt;/div&gt; &lt;div class=\"operate_btn\"&gt; &lt;a href=\"javascript:;\" class=\"buy_btn\"&gt;立即购买&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"add_cart\" id=\"add_cart\"&gt;加入购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"main_wrap clearfix\"&gt; &lt;div class=\"l_wrap fl clearfix\"&gt; &lt;div class=\"new_goods\"&gt; &lt;h3&gt;新品推荐&lt;/h3&gt; &lt;ul&gt; &#123;% for sku in new_skus %&#125; &lt;li&gt; &lt;a href=\"&#123;% url 'goods:detail' sku.id %&#125;\"&gt;&lt;img src=\"&#123;&#123; sku.image.url &#125;&#125;\"&gt;&lt;/a&gt; &lt;h4&gt;&lt;a href=\"&#123;% url 'goods:detail' sku.id %&#125; \"&gt;&#123;&#123; sku.name &#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;div class=\"prize\"&gt;￥&#123;&#123; sku.price &#125;&#125;&lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"r_wrap fr clearfix\"&gt; &lt;ul class=\"detail_tab clearfix\"&gt; &lt;li class=\"active\"&gt;商品介绍&lt;/li&gt; &lt;li&gt;评论&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"tab_content\"&gt; &lt;dl&gt; &lt;dt&gt;商品详情：&lt;/dt&gt; &lt;dd&gt;&#123;&#123; sku.goods.detail |safe &#125;&#125;&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;div class=\"tab_content\"&gt; &lt;dl&gt; &#123;% for comment in sku_orders_comment %&#125; &lt;dt&gt;评论时间：&#123;&#123; comment.update_time &#125;&#125;&amp;nbsp;&amp;nbsp;&#123;&#123; comment.order.user.username &#125;&#125;&lt;/dt&gt; &lt;dd&gt;评论内容：&#123;&#123; comment.comment |safe &#125;&#125;&lt;/dd&gt; &#123;% endfor %&#125; &lt;/dl&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; step9 在首页index.html中对商品详情链接地址进行数据填坑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div class=\"center_con clearfix\"&gt; &lt;ul class=\"subnav fl\"&gt; &#123;% for type in types %&#125; &lt;li&gt;&lt;a href=\"#model0&#123;&#123; forloop.counter &#125;&#125;\" class=\"&#123;&#123; type.logo &#125;&#125;\"&gt;&#123;&#123; type.name &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;div class=\"slide fl\"&gt; &lt;ul class=\"slide_pics\"&gt; &#123;% for banner in goods_banners %&#125; &lt;li&gt;&lt;a href=\"&#123;% url 'goods:detail' banner.sku.id %&#125;\" &gt;&lt;img src=\"&#123;&#123; banner.image.url &#125;&#125;\" alt=\"幻灯片\"&gt;&lt;/a&gt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;div class=\"prev\"&gt;&lt;/div&gt; &lt;div class=\"next\"&gt;&lt;/div&gt; &lt;ul class=\"points\"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div class=\"adv fl\"&gt; &#123;% for banner in promotion_banners %&#125; &lt;a href=\"&#123;&#123; banner.url &#125;&#125;\"&gt;&lt;img src=\"&#123;&#123; banner.image.url &#125;&#125;\"&gt;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt;&lt;/div&gt;&#123;% for type in types %&#125;&lt;div class=\"list_model\"&gt; &lt;div class=\"list_title clearfix\"&gt; &lt;h3 class=\"fl\" id=\"model&#123;&#123; forloop.counter &#125;&#125;\"&gt;&#123;&#123; type.name &#125;&#125;&lt;/h3&gt; &lt;div class=\"subtitle fl\"&gt; &lt;span&gt;|&lt;/span&gt; &#123;% for banner in type.title_banners %&#125; &lt;a href=\"&#123;% url 'goods:detail' banner.sku.id %&#125;\"&gt;&#123;&#123; banner.sku.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;a href=\"#\" class=\"goods_more fr\" id=\"fruit_more\"&gt;查看更多 &gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"goods_con clearfix\"&gt; &lt;div class=\"goods_banner fl\"&gt;&lt;img src=\"&#123;&#123; type.image.url &#125;&#125;\"&gt;&lt;/div&gt; &lt;ul class=\"goods_list fl\"&gt; &#123;% for banner in type.image_banners %&#125; &lt;li&gt; &lt;h4&gt;&lt;a href=\"&#123;% url 'goods:detail' banner.sku.id %&#125;\"&gt;&#123;&#123; banner.sku.name &#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;a href=\"&#123;% url 'goods:detail' banner.sku.id %&#125;\"&gt;&lt;img src=\"&#123;&#123; banner.sku.image.url &#125;&#125;\"&gt;&lt;/a&gt; &lt;div class=\"prize\"&gt;¥ &#123;&#123; banner.sku.price &#125;&#125;&lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; step10 测试 3.添加历史浏览记录 step1 当用户点击某个商品，进入商品商品详情页面时，将该商品id保存到redis数据库中，在用户中心页面个人信息页面进行显示 12345678# 添加用户中心历史浏览记录history_key = \"history_%d\"% user.id# 当用户进入该goods_id的商品详情页时，则将之前redis数据中的的此goods_id的商品移除conn.lrem(history_key, 0, goods_id)# 将此goods_id的商品排到浏览记录列表的左侧conn.lpush(history_key, goods_id)# 最多只保存5条浏览记录conn.ltrim(history_key, 0 ,4) step2 测试用户历史浏览记录 step3 查看redis数据库以及mysql数据库 4.在商品详情页添加其他规格的商品 step1 在DetailView类视图get方法中进行获取，获取同一个spu的其他规格的商品,不显示当前的商品 123456same_spu_skus = GoodsSKU.objects.filter(goods=sku.goods).exclude(id=goods_id) content = &#123;\"types\":types, \"sku\":sku, \"sku_orders_comment\":sku_orders_comment, \"same_spu_skus\":same_spu_skus, \"new_skus\":new_skus, \"cart_count\":cart_count&#125; step2 在detail.html模板中添加其他规格的标签，并进行数据填坑 12345678&lt;div&gt; &lt;p&gt;其他规格:&lt;/p&gt; &lt;ul&gt; &#123;% for sku in same_spu_skus %&#125; &lt;li&gt;&lt;a href=\"&#123;% url 'goods:detail' sku.id %&#125;\"&gt;&#123;&#123; sku.name &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/div&gt; step3 测试显示不同规格的商品 5.添加详情计算商品总价js代码 step1 获取商品总价 1234567891011// 获取商品总价function get_goods_amount() &#123; price = $('.show_pirze').children('em').text(); //商品单价 count = $('.num_show').val(); //商品数量 // 计算商品总价 price = parseFloat(price); count = parseInt(count); amount = price*count; // 显示总价价格 $('.total').children('em').text(amount.toFixed(2)+'元')&#125; step2 添加商品数量 12345678910// 增加商品数量$('.add').click(function () &#123; // 获取商品原有的数量并加1 count = $('.num_show').val(); count = parseInt(count)+1; // 重新显示商品数量 $('.num_show').val(count); // 更新商品总价 get_goods_amount();&#125;); step3 减少商品数量 123456789101112$('.minus').click(function () &#123; // 获取商品原有的数量并减1 count = $('.num_show').val(); count = parseInt(count)-1; if(count&lt;=0)&#123; count=1 &#125; // 重新显示商品数量 $('.num_show').val(count); // 更新商品总价 get_goods_amount();&#125;); step4 手动输入商品数量 12345678910111213// 手动输入商品数量$('.num_show').blur(function () &#123; // 获取输入的商品数量 count = $(this).val(); // 校验用户输入的商品数量是否合法 if(isNaN(count) || count.trim().length==0 || parseInt(count) &lt;=0)&#123; count=1 &#125; // 设置用户输入的商品数目 $(this).val(parseInt(count)); // 更新商品总价 get_goods_amount()&#125;); step5 效果演示 二丶天天生鲜列表页1.显示商品列表页 step1 在df_goods/views中定义类视图get方法，显示列表页 123456# /list/商品种类id/页码?sort=排序方式class ListView(View): \"\"\"商品列表页\"\"\" def get(self, request, type_id, page): \"\"\"显示商品列表页\"\"\" return render(request, \"list.html\") step2 在df_goods/urls中定义url路由 1url(r\"^list/(?P&lt;type_id&gt;\\d+)/(?P&lt;page&gt;\\d+)$\", ListView.as_view(), name=\"list\"), # 列表页 2.获取商品列表页内容 step1 获取商品种类信息 123456# 获取商品种类信息try: type = GoodsType.objects.get(id=type_id)except GoodsType.DoesNotExist: \"\"\"商品种类不存在返回主页\"\"\" return redirect(reverse(\"goods:index\")) step2 获取全部商品分类信息 1types = GoodsType.objects.all() step3 获取排序的方式 sort=default 默认id排序 price 价格排序 hot 商品销量 123456789sort = request.GET.get(\"sort\")if sort == \"price\": skus = GoodsSKU.objects.filter(type=type).order_by(\"price\")elif sort == \"hot\": skus = GoodsSKU.objects.filter(type=type).order_by(\"-sales\")else: # 其他的通通按照默认排序 sort = \"default\" skus = GoodsSKU.objects.filter(type=type).order_by(\"-id\") step4 对数据进行分页 1234567891011paginator = Paginator(skus, 5) # Show 25 contacts per page# 获取页数try: page = int(page)except Exception as e: page = 1# 判断用户传递过来的页数，是否小于总页数，大于总页数则设置第一页if page &gt; paginator.num_pages: page = 1 skus_page = paginator.page(page) step5 获取新品推荐信息，根据查询到的商品sku对象获取商品信息按照创建时间进行倒序排序并且只显示最前面两个 1new_skus = GoodsSKU.objects.filter(type=type).order_by('-create_time')[:2] step6 获取用户购物车中商品的数目 12345678user = request.user # 获取user对象cart_count = 0 # 默认设置为0if user.is_authenticated(): # 如果返回True表示用户已登录 # 用户已登录 conn = get_redis_connection('default') # 获取配置中default默认redis连接对象 cart_key = 'cart_%d' % user.id # 设置key # 通过hlen方法获取购物车商品数目 cart_count = conn.hlen(cart_key) step7 定义模板上下文，并返回 1234567context = &#123; \"type\":type,\"types\":types, \"skus_page\":skus_page,\"new_skus\":new_skus, \"cart_count\":cart_count,\"sort\":sort&#125; return render(request, \"list.html\", context) step8 在list.html模板文件中进行数据填坑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;div class=\"breadcrumb\"&gt; &lt;a href=\"#\"&gt;全部分类&lt;/a&gt; &lt;span&gt;&gt;&lt;/span&gt; &lt;a href=\"#\"&gt;&#123;&#123; type.name &#125;&#125;&lt;/a&gt;&lt;/div&gt;&lt;div class=\"main_wrap clearfix\"&gt; &lt;div class=\"l_wrap fl clearfix\"&gt; &lt;div class=\"new_goods\"&gt; &lt;h3&gt;新品推荐&lt;/h3&gt; &lt;ul&gt; &#123;% for sku in new_skus %&#125; &lt;li&gt; &lt;a href=\"&#123;% url 'goods:detail' sku.id %&#125;\"&gt;&lt;img src=\"&#123;&#123; sku.image.url &#125;&#125;\"&gt;&lt;/a&gt; &lt;h4&gt;&lt;a href=\"&#123;% url 'goods:detail' sku.id %&#125;\"&gt;&#123;&#123; sku.name &#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;div class=\"prize\"&gt;￥&#123;&#123; sku.price &#125;&#125;&lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"r_wrap fr clearfix\"&gt; &lt;div class=\"sort_bar\"&gt; &lt;a href=\"&#123;% url 'goods:list' type.id 1 %&#125;\" &#123;% if sort == \"default\" %&#125;class=\"active\"&#123;% endif %&#125;&gt;默认&lt;/a&gt; &lt;a href=\"&#123;% url 'goods:list' type.id 1 %&#125;?sort=price\" &#123;% if sort == \"price\" %&#125;class=\"active\"&#123;% endif %&#125;&gt;价格&lt;/a&gt; &lt;a href=\"&#123;% url 'goods:list' type.id 1 %&#125;?sort=hot\" &#123;% if sort == \"hot\" %&#125;class=\"active\"&#123;% endif %&#125;&gt;人气&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"goods_type_list clearfix\"&gt; &#123;% for sku in skus_page %&#125; &lt;li&gt; &lt;a href=\"&#123;% url 'goods:detail' sku.id %&#125;\"&gt;&lt;img src=\"&#123;&#123; sku.image.url &#125;&#125;\"&gt;&lt;/a&gt; &lt;h4&gt;&lt;a href=\"&#123;% url 'goods:detail' sku.id %&#125;\"&gt;&#123;&#123; sku.name &#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;div class=\"operate\"&gt; &lt;span class=\"prize\"&gt;￥&#123;&#123; sku.price &#125;&#125;&lt;/span&gt; &lt;span class=\"unit\"&gt;&#123;&#123; sku.price &#125;&#125;/&#123;&#123; sku.unite &#125;&#125;&lt;/span&gt; &lt;a href=\"#\" class=\"add_goods\" title=\"加入购物车\"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;div class=\"pagenation\"&gt; &#123;% if skus_page.has_previous %&#125; &lt;a href=\"&#123;% url 'goods:list' type.id skus_page.previous_page_number %&#125;?sort=&#123;&#123; sort &#125;&#125;\"&gt;&lt;上一页&lt;/a&gt; &#123;% endif %&#125; &#123;% for pindex in skus_page.paginator.page_range %&#125; &#123;% if pindex == skus_page.number %&#125; &lt;a href=\"&#123;% url 'goods:list' type.id pindex %&#125;?sort=&#123;&#123; sort &#125;&#125;\" class=\"active\"&gt;&#123;&#123; pindex &#125;&#125;&lt;/a&gt; &#123;% else %&#125; &lt;a href=\"&#123;% url 'goods:list' type.id pindex %&#125;?sort=&#123;&#123; sort &#125;&#125;\"&gt;&#123;&#123; pindex &#125;&#125;&lt;/a&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if skus_page.has_next %&#125; &lt;a href=\"&#123;% url 'goods:list' type.id skus_page.next_page_number %&#125;?sort=&#123;&#123; sort &#125;&#125;\"&gt;下一页&gt;&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; step9 测试列表页 3.列表页分页页码控制（只显示5个页数） step1 当总页数小于5页时，页面上显示所有页码（1~5页都显示），当总页数大于5页时，那么判断当前页如果是前3页，显示1-5页，如果当前页是后3页，显示总页数最后5页；如果当前页不是第3页时，即显示当前页的前2页 当前页 当前页最后2页 123456789101112131415num_pages = paginator.num_pagesif num_pages &lt; 5: pages = range(1, num_pages + 1)elif page &lt;= 3: pages = range(1, 6)elif num_pages - page &lt;= 2: pages = range(num_pages - 4, num_pages + 1)else: pages = range(page - 2, page + 3)context = &#123; \"type\":type,\"types\":types, \"skus_page\":skus_page,\"new_skus\":new_skus, \"cart_count\":cart_count,\"sort\":sort, \"pages\":pages&#125; step2 替换list.html模板文件中的{% for pindex in skus_page.paginator.page_range %}为pages即可 1&#123;% for pindex in pages %&#125; step3 为了演示分页页码显示效果，博主设置每页显示商品2个，因为博主添加的商品不足够多 step4 修改主页中的查看更多链接地址 ,跳转到丢应商品种类的列表页，sort不传表示默认排序方式 1&lt;a href=\"&#123;% url 'goods:list' type.id 1 %&#125;\" class=\"goods_more fr\" id=\"fruit_more\"&gt;查看更多 &gt;&lt;/a&gt; step5 效果显示 三丶天天生鲜商品搜索1.全文检索框架以及搜索引擎安装配置 全文检索不同于特定字段的模糊查询，使用全文检索的效率更高，并且能够对于中文进行分词处理。 haystack：全文检索的框架，支持whoosh、solr、Xapian、Elasticsearc四种全文检索引擎，点击查看官方网站。 whoosh：纯Python编写的全文搜索引擎，虽然性能比不上sphinx、xapian、Elasticsearc等，但是无二进制包，程序不会莫名其妙的崩溃，对于小型的站点，whoosh已经足够使用，点击查看whoosh文档。 jieba：一款免费的中文分词包，如果觉得不好用可以使用一些收费产品。 step1 使用haystack全文检索的框架，配合whoosh搜索引擎进行数据搜索，安装django-haystack以及whoosh 12pip install django-haystackpip install whoosh step2 在settings中添加haystack应用以及配置haystack框架 123456789101112# 全文检索haystack框架配置HAYSTACK_CONNECTIONS = &#123; 'default': &#123; # 使用whoosh引擎 'ENGINE': 'haystack.backends.whoosh_backend.WhooshEngine', # 索引文件路径 'PATH': os.path.join(BASE_DIR, 'whoosh_index'), &#125;&#125; # 当数据库表 添加、修改、删除数据时，自动生成索引HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor' 2.创建引擎及索引 step1 在网站搜索框中搜索商品是对df_goods_sku表数据的搜索，即在df_goods模块下创建search_indexes.py文件，并在此文件中创建引擎和索引（固定写法和用法） 1234567891011121314151617# coding:utf-8from haystack import indexesfrom df_goods.models import GoodsSKU # 指定对于某个类的某些数据建立索引 class GoodsSKUIndex(indexes.SearchIndex, indexes.Indexable): text = indexes.CharField(document=True, use_template=True) # 索引字段 # 获取模型类 def get_model(self): # 返回模型类 return GoodsSKU # 建立索引数据 def index_queryset(self, using=None): # 返回该模型的所有数据 return self.get_model().objects.all() step2 在templates模板目录下创建search/indexes/df_goods/goodssku_text.txt文件（search/indexes/模块名/模型类_text.txt固定写法），并在goodssku_text.txt文件中，指定哪些表字段用于创建索引 1234# 指定数据库表中哪些字段来建立索引&#123;&#123;object.name&#125;&#125; # 商品名称&#123;&#123;object.desc&#125;&#125; # 商品简介&#123;&#123;object.goods.detail&#125;&#125; # 商品详情 3.生成索引文件 step1 执行命令python2 manage.py rebuild_index，生成指定模型类df_goods_sku索引文件，生成成功显示出商品的个数 step2 查看数据库中df_goods_sku表有多少个商品 step3 在settings配置中索引文件的路径为’PATH’: os.path.join(BASE_DIR, ‘whoosh_index’)，也就是项目目录下的whoosh_index目录，此时查看项目目录下已经成功创建该目录，并在该目录下生成了df_goods_sku表的索引文件 4.全文检索的使用 step1 在base.html模板文件中找到搜索框，进行如下编写，需要注意的是表单提交的方法为get以及text input输入框的name必须为q，这两个为固定的 1234&lt;form method=\"get\" action=\"/search\"&gt; &lt;input type=\"text\" class=\"input_text fl\" name=\"q\" placeholder=\"搜索商品\"&gt; &lt;input type=\"submit\" class=\"input_btn fr\" name=\"\" value=\"搜索\"&gt;&lt;/form&gt; step2 在根基urls文件中，配置全文检索框架 1url(r'^search', include('haystack.urls')), # 全文检索框架 step3 启动项目，在主页搜索框中搜索商品信息，点击搜索提交按钮后，结果提示如下错误，在templates/search目录下找不到search.html文件 step4 在templates/search目录下创建search.html文件，将list.html模板中的内容拷贝到该文件中，进行修改显示出搜索结果列表页，haystack会把搜索出的结果传递给该路径下的search.html模板 query：搜索关键字 page：当前页的page对象 –&gt;遍历page对象，获取到的是SearchResult类的实例对象，对象的属性object才是模型类的对象 paginator：分页paginator对象 12345678910111213141516171819202122232425262728293031323334353637383940&#123;% extends &apos;base_detail_list.html&apos; %&#125;&#123;% block title %&#125;天天生鲜-搜索结果列表&#123;% endblock title %&#125;&#123;% block main_content %&#125; &lt;div class=&quot;breadcrumb&quot;&gt; &lt;a href=&quot;#&quot;&gt;&#123;&#123; query &#125;&#125;&lt;/a&gt; &lt;span&gt;&gt;&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;搜索结果如下:&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;main_wrap clearfix&quot;&gt; &lt;ul class=&quot;goods_type_list clearfix&quot;&gt; &#123;% for item in page %&#125; &lt;li&gt; &lt;a href=&quot;&#123;% url &apos;goods:detail&apos; item.object.id %&#125;&quot;&gt;&lt;img src=&quot;&#123;&#123; item.object.image.url &#125;&#125;&quot;&gt;&lt;/a&gt; &lt;h4&gt;&lt;a href=&quot;&#123;% url &apos;goods:detail&apos; item.object.id %&#125;&quot;&gt;&#123;&#123; item.object.name &#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;div class=&quot;operate&quot;&gt; &lt;span class=&quot;prize&quot;&gt;￥&#123;&#123; item.object.price &#125;&#125;&lt;/span&gt; &lt;span class=&quot;unit&quot;&gt;&#123;&#123; item.object.price &#125;&#125;/&#123;&#123; item.object.unite &#125;&#125;&lt;/span&gt; &lt;a href=&quot;#&quot; class=&quot;add_goods&quot; title=&quot;加入购物车&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;div class=&quot;pagenation&quot;&gt; &#123;% if page.has_previous %&#125; &lt;a href=&quot;/search?q=&#123;&#123; query &#125;&#125;&amp;page=&#123;&#123; page.previous_page_number &#125;&#125;&quot;&gt;&lt;上一页&lt;/a&gt; &#123;% endif %&#125; &#123;% for pindex in paginator.page_range %&#125; &#123;% if pindex == page.number %&#125; &lt;a href=&quot;/search?q=&#123;&#123; query &#125;&#125;&amp;page=&#123;&#123; pindex &#125;&#125;&quot; class=&quot;active&quot;&gt;&#123;&#123; pindex &#125;&#125;&lt;/a&gt; &#123;% else %&#125; &lt;a href=&quot;/search?q=&#123;&#123; query &#125;&#125;&amp;page=&#123;&#123; pindex &#125;&#125;&quot;&gt;&#123;&#123; pindex &#125;&#125;&lt;/a&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if page.has_next %&#125; &lt;a href=&quot;/search?q=&#123;&#123; query &#125;&#125;&amp;page=&#123;&#123; page.next_page_number &#125;&#125;&quot;&gt;下一页&gt;&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock main_content %&#125; step5 回到主页在搜索框中搜索草莓，显示出搜索的结果 step6 在数据库进行模糊查询后，得值使用haystack框架加载whoosh检索出来的内容，只能呵呵了 5.使用中文分词包，更爱whoosh默认分词方式 step1 安装jieba分词包 1pip install jieba step2 在D:\\Python27\\Lib\\site-packages\\haystack\\backends你的python项目环境安装包中找到此路径，在该路径下创建ChineseAnalyzer.py文件，文件内容如下 123456789101112131415161718192021import jiebafrom whoosh.analysis import Tokenizer, Token class ChineseTokenizer(Tokenizer): def __call__(self, value, positions=False, chars=False, keeporiginal=False, removestops=True, start_pos=0, start_char=0, mode='', **kwargs): t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs) seglist = jieba.cut(value, cut_all=True) for w in seglist: t.original = t.text = w t.boost = 1.0 if positions: t.pos = start_pos + value.find(w) if chars: t.startchar = start_char + value.find(w) t.endchar = start_char + value.find(w) + len(w) yield t def ChineseAnalyzer(): return ChineseTokenizer() step3 复制whoosh_backend.py文件，改为whoosh_cn_backend.py，编辑该文件，导入from .ChineseAnalyzer import ChineseAnalyzer类，将代码中的analyzer=StemmingAnalyzer()修改为analyzer=ChineseAnalyzer() 12from .ChineseAnalyzer import ChineseAnalyzeranalyzer=ChineseAnalyzer() step4 修改settings中haystack配置，将.whoosh_backend改为.whoosh_cn_backend 1ENGINE&apos;: &apos;haystack.backends.whoosh_cn_backend.WhooshEngine&apos;, step5 重新生成新的索引文件 step6 测试搜索草莓是否显示出所有草莓相关的商品信息 step7 测试搜索商品简介以及商品详情介绍关键字 四丶添加商品到购物车1.分析如何添加购物车数目 12341.使用什么方式想后端传递参数使用ajax post方式向后端传递参数2.传递哪些参数商品id和商品的数量 2.添加购物车后台逻辑 step1 在df_cart/views中定义类视图，并在该视图下定义post方法 12345class CartAddView(View): \"\"\"购物车添加\"\"\" def post(self, request): \"\"\"添加购物车数目\"\"\" pass step2 判断用户是否登录，没有登录则无法添加购物车 123user = request.userif not user.is_authenticated(): return JsonResponse(&#123;\"errno\":0, \"error_msg\":\"请先登录\"&#125;) step3 获取参数 12sku_id = request.POST.get(\"sku_id\")count = request.POST.get(\"count\") step4 校验参数完整性 12if not all([sku_id, count]): return JsonResponse(&#123;\"errno\":1, \"error_msg\":\"参数不完整\"&#125;) step5 校验商品数量count是否合法 1234try: count = int(count)except Exception as e: return JsonResponse(&#123;\"errno\":2, \"error_msg\":\"商品数量不合法\"&#125;) step6 校验商品是否存在 1234try: sku = GoodsSKU.objects.get(id=sku_id)except GoodsSKU.DoesNotExist: return JsonResponse(&#123;\"errno\":3, \"error_msg\":\"商品不存在\"&#125;) step7 如果用户购物车存在将要添加的商品id，则添加商品的数量即可，如果没有，则添加商品id以及数量 123456conn = get_redis_connection(\"default\")cart_key = \"cart_%d\" % user.idcart_count = conn.hget(cart_key, sku_id)if cart_count: # 在redis中查询到该sku_id键存在，则添加该键的商品数量 count += int(cart_count) step8 判断该商品库存是否大于用户添加商品的数量 12if count &gt; sku.stock: return JsonResponse(&#123;\"errno\":4, \"error_msg\":\"商品库存不足\"&#125;) step9 添加商品数目，没有查到则设置新的sku_id以及商品数量，hset方法有数据则更新，无则新增 1conn.hset(cart_key, sku_id, count) step10 计算用户购物车商品的总数目，最后返回添加成功响应 12total_count = conn.hlen(cart_key)return JsonResponse(&#123;\"errno\":\"ok\",\"total_count\":total_count, \"error_msg\":\"添加成功\"&#125;) 3.添加购物车前端js step1 获取元素坐标 1234var $add_x = $('#add_cart').offset().top;var $add_y = $('#add_cart').offset().left;var $to_x = $('#show_count').offset().top;var $to_y = $('#show_count').offset().left; step2 定义点击购物车事件，获取商品sku_id以及商品数量，通过ajax post请求方式向后端cart接口发送请求并传递sku_id以及商品数量，后台进行逻辑判断向前端返回字典数据，通过后台返回的data数据进行页面购物车显示控制 123456789101112131415161718192021222324$('#add_cart').click(function()&#123; // 获取商品id和商品数量 sku_id = $(this).attr('sku_id'); count = $('.num_show').val(); csrf = $('input[name=\"csrfmiddlewaretoken\"]').val(); &#123;#alert(sku_id+':'+count);#&#125; // 发起ajax post请求 访问/cart/add ,参数 sku_id和count params = &#123;\"sku_id\":sku_id, \"count\":count, \"csrfmiddlewaretoken\":csrf&#125;; $.post('/cart/add', params, function (data) &#123; if(data.errno==\"ok\")&#123; $(\".add_jump\").css(&#123;'left':$add_y+80,'top':$add_x+10,'display':'block'&#125;); $(\".add_jump\").stop().animate(&#123; 'left': $to_y+7, 'top': $to_x+7&#125;, \"fast\", function() &#123; $(\".add_jump\").fadeOut('fast',function()&#123; $('#show_count').html(data.total_count); &#125;); &#125;); &#125;else &#123; alert(data.error_msg) &#125; &#125;); &#125;) step3 需要注意的是在上一步中通过ajax post方式向后台发送请求，是需要进行csrf验证的，不然则会报错；在detail.html模板文件中任意一位置加上{% csrf_token %}即可，并且在ajax中发送请求传递参数是获取input[name=”csrfmiddlewaretoken”]的值来向后端传递，在页面源代码中对应html文件中的{% csrf_token %}位置会出现如下标签元素 4.测试 说明：为了方便测试，博主先把redis数据库中保存的购物车删除 step1 对同一个商品进行多次添加，右上方购物车显示数目不变 step2 对不同的商品进行多次添加，右上方购物车显示数目变化 step3 查看redis库数据 五丶天天生鲜我的购物车页1.购物车页面显示 step1 在df_cart/views中定义类视图继承于封装的login_required方法的类，因为该页面是需要用户登录才能访问的，而在添加购物车数目的时候使用ajax方式发送请求，所以不用继承，在post方法中进行登录验证即可；并在类中定义get方法，显示我的购物车页面 123456# /cartclass CartInfoView(LoginRequiredMixin, View): \"\"\"我的购物车\"\"\" def get(self, request): \"\"\"显示我的购物车页面\"\"\" return render(request, \"cart.html\") step2 在df_cart/urls中定义路由 1url(r\"^$\", CartInfoView.as_view(), name=\"cart_show\") # 显示我的购物车 step3 在base.html中菜单栏上的我的购物车添加链接地址 1&lt;a href=\"&#123;% url 'cart:cart_show' %&#125;\"&gt;我的购物车&lt;/a&gt; step4 测试在登录与未登录状态进入我的购物页面 2.获取我的购物车页面数据 step1 获取登录的用户 1user = request.user step2 获取用户购物车商品信息 1234conn = get_redis_connection(\"default\")cart_key = \"cart_%d\" % user.id# &#123;商品id:商品数量&#125;cart_dict = conn.hgetall(cart_key) step3 获取我的购物车页面每个商品的数量以及小计以及我的购物车中商品总件数以及总价格 123456789101112131415161718skus = [] # 存放查出来的商品信息对象# 用于保存我的购物车中商品总件数以及总价格total_count = 0total_price = 0# 获取商品id和商品数量for sku_id, count in cart_dict.items(): # 根据sku_id获取商品信息 sku = GoodsSKU.objects.get(id=sku_id) # 计算小计 amount = sku.price*int(count) # 动态给sku对象添加属性，保存遍历获取的小计以及商品数量 sku.amount = amount sku.count = count # 将查询出来的商品信息对象保存到列表中 skus.append(sku) # 累加计算商品总件数和总价格 total_count += int(count) total_price += amount step4 定义模板上下文，并返回给购物车模板 123456# 定义模板上下文context = &#123; 'skus':skus,'total_count':total_count, 'total_price':total_price&#125;return render(request, \"cart.html\", context) step5 在cart.html模板文件中进行数据填坑 123456789101112131415161718192021222324252627282930313233&lt;div class=\"total_count\"&gt;全部商品&lt;em&gt;&#123;&#123; total_count &#125;&#125;&lt;/em&gt;件&lt;/div&gt;&lt;ul class=\"cart_list_th clearfix\"&gt; &lt;li class=\"col01\"&gt;商品名称&lt;/li&gt; &lt;li class=\"col02\"&gt;商品单位&lt;/li&gt; &lt;li class=\"col03\"&gt;商品价格&lt;/li&gt; &lt;li class=\"col04\"&gt;数量&lt;/li&gt; &lt;li class=\"col05\"&gt;小计&lt;/li&gt; &lt;li class=\"col06\"&gt;操作&lt;/li&gt;&lt;/ul&gt;&#123;% for sku in skus %&#125;&lt;ul class=\"cart_list_td clearfix\"&gt; &lt;li class=\"col01\"&gt;&lt;input type=\"checkbox\" name=\"\" checked&gt;&lt;/li&gt; &lt;li class=\"col02\"&gt;&lt;img src=\"&#123;&#123; sku.image.url &#125;&#125;\"&gt;&lt;/li&gt; &lt;li class=\"col03\"&gt;&#123;&#123; sku.name &#125;&#125;&lt;br&gt;&lt;em&gt;&#123;&#123; sku.price &#125;&#125;元/&#123;&#123; sku.unite &#125;&#125;&lt;/em&gt;&lt;/li&gt; &lt;li class=\"col04\"&gt;&#123;&#123; sku.unite &#125;&#125;&lt;/li&gt; &lt;li class=\"col05\"&gt;&#123;&#123; sku.price &#125;&#125;元&lt;/li&gt; &lt;li class=\"col06\"&gt; &lt;div class=\"num_add\"&gt; &lt;a href=\"javascript:;\" class=\"add fl\"&gt;+&lt;/a&gt; &lt;input type=\"text\" class=\"num_show fl\" value=\"&#123;&#123; sku.count &#125;&#125;\"&gt; &lt;a href=\"javascript:;\" class=\"minus fl\"&gt;-&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=\"col07\"&gt;&#123;&#123; sku.amount&#125;&#125;元&lt;/li&gt; &lt;li class=\"col08\"&gt;&lt;a href=\"javascript:;\"&gt;删除&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&#123;% endfor %&#125;&lt;ul class=\"settlements\"&gt; &lt;li class=\"col01\"&gt;&lt;input type=\"checkbox\" name=\"\" checked=\"\"&gt;&lt;/li&gt; &lt;li class=\"col02\"&gt;全选&lt;/li&gt; &lt;li class=\"col03\"&gt;合计(不含运费)：&lt;span&gt;¥&lt;/span&gt;&lt;em&gt;&#123;&#123; total_price &#125;&#125;&lt;/em&gt;&lt;br&gt;共计&lt;b&gt;&#123;&#123; total_count &#125;&#125;&lt;/b&gt;件商品&lt;/li&gt; &lt;li class=\"col04\"&gt;&lt;a href=\"place_order.html\"&gt;去结算&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; step6 进入我的购物车页面显示正确商品信息以及购物车数目小计金额以及购物车总件数总金额 3.购物车页面全选与不全选以及选中与不选中js代码 step1 计算选中的商品的总件数和总价格 12345678910111213141516function get_cart_info() &#123; total_price = 0; total_count = 0; $('.cart_list_td').find(':checked').parents('ul').each(function () &#123; //获取商品的数量和小计 count = $(this).find('.num_show').val(); amount = $(this).children('.col07').text(); count = parseInt(count); amount = parseFloat(amount); total_count += count; total_price += amount; &#125;); // 设置选中商品的总件数和总价格 $('.settlements').find('em').text(total_price.toFixed(2)); $('.settlements').find('b').text(total_count); &#125; step2 全选和全不选 12345678910$('.settlements').find(':checkbox').change(function () &#123; // 获取全选的选中状态 is_check = $(this).prop('checked'); // 遍历商品对应的checkbox状态，设置其状态与全选的checkbox状态保持一致 $('.cart_list_td').find(':checkbox').each(function () &#123; $(this).prop('checked', is_check) &#125;); // 调用get_cart_info方法，更新购物车页面商品总件数和总价格 get_cart_info() &#125;); step3 当购物车某个商品的checkbox状态发生改变时，设置全选checkbox状态 123456789101112131415$('.cart_list_td').find(':checkbox').change(function () &#123; // 获取页面上所有的商品数目(不是商品数量) all_len = $('.cart_list_td').length // 获取页面上被选中的商品数目 checked_len = $('.cart_list_td').find(\":checked\").length; if(checked_len&lt;all_len)&#123; // 说明商品未全部勾选，即取消全选的checkbox状态 $('.settlements').find(':checkbox').prop('checked', false) &#125; else&#123; $('.settlements').find(':checkbox').prop('checked', true) &#125; // 调用get_cart_info方法，更新购物车页面商品总件数和总价格 get_cart_info() &#125;) step4 效果展示 4.购物车中商品数量点击事件（增加或减少） step1 在df_cart/views中定义类视图，通过页面点击+或-来对商品数量进行修改，使用ajax post请求方式向后端发送，所以需要定义post方法，需要传递商品id（sku_id）以及商品更改后的数量（count） 123456# /cart/updateclass CartUpdateView(View): \"\"\"购物车数据更新\"\"\" def post(self, request): \"\"\"修改购物车商品数据\"\"\" pass step2 判断用户是否登录—&gt;获取参数—&gt;校验参数完整性—&gt;校验商品数量count是否合法—&gt;校验商品是否存在，跟前面添加商品到购物车（CartAddView视图逻辑一样） 12345678910111213141516171819202122user = request.userif not user.is_authenticated(): return JsonResponse(&#123;\"errno\": 0, \"error_msg\": \"请先登录\"&#125;)# 1.获取参数sku_id = request.POST.get(\"sku_id\")count = request.POST.get(\"count\") # 2.校验参数完整性if not all([sku_id, count]): return JsonResponse(&#123;\"errno\": 1, \"error_msg\": \"参数不完整\"&#125;) # 3.校验商品数量count是否合法try: count = int(count)except Exception as e: return JsonResponse(&#123;\"errno\": 2, \"error_msg\": \"商品数量不合法\"&#125;) # 4. 校验商品是否存在try: sku = GoodsSKU.objects.get(id=sku_id)except GoodsSKU.DoesNotExist: return JsonResponse(&#123;\"errno\": 3, \"error_msg\": \"商品不存在\"&#125;) step3 更新购物车的商品数量，在数据库中设置对应key的value值 12345conn = get_redis_connection(\"default\")cart_key = \"cart_%d\" % user.idif count &gt; sku.stock: return JsonResponse(&#123;\"errno\": 4, \"error_msg\": \"商品库存不足\"&#125;)conn.hset(cart_key, sku_id, count) step4 获取更新后的购物车中商品的总件数 12345total_count = 0vals = conn.hvals(cart_key)for val in vals: total_count += int(val)return JsonResponse(&#123;\"errno\": \"ok\", \"total_count\":total_count, \"error_msg\": \"更新成功\"&#125;) step5 在cart.html中编写js增加商品数量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 计算商品的小计function update_goods_amount(sku_ul) &#123; // 获取商品的价格和数量 count = sku_ul.find('.num_show').val(); price = sku_ul.children('.col05').text(); // 计算商品的小计 amount = parseInt(count)*parseFloat(price); // 设置商品的小计 sku_ul.children('.col07').text(amount.toFixed(2)+'元')&#125;// 购物车增加商品数量$('.add').click(function () &#123; // 获取商品id和当前数量 sku_id = $(this).next().attr('sku_id'); count = $(this).next().val(); count = parseInt(count) +1; csrf = $('input[name=\"csrfmiddlewaretoken\"]').val(); // 组织参数 params = &#123;'sku_id':sku_id, 'count':count, \"csrfmiddlewaretoken\":csrf&#125;; error_update = false; total = 0; // 设置ajax请求为同步 $.ajaxSettings.async = false; // 向后端发送ajax post请求 $.post('/cart/update', params, function (data) &#123; if(data.errno == \"ok\")&#123; error_update = false; total = data.total_count &#125; else &#123; // 更新失败 error_update = true; alert(data.error_msg) &#125; &#125;); // 设置ajax请求为异步 $.ajaxSettings.async = true; // 判断是否更新成功 if(error_update == false)&#123; // 重新设置页面上商品数量 $(this).next().val(count); // 计算商品小计 update_goods_amount($(this).parents('ul')); // 获取商品对应的checkbox的选中状态，如果被选中，更新页面信息 is_checked = $(this).parents('ul').find(':checkbox').prop('checked'); if (is_checked)&#123; // 更新页面信息 get_cart_info() &#125; // 更新页面上购物车商品的总件数 $('.total_count').children('em').text(total) &#125;&#125;) step6 当商品状态为checked选中状态，点击增加商品数量，则左上角全部商品件数和右下角合计金额商品总件累加，如果该增加的商品不是选中状态，则只增加左上角全部商品件数 step7 商品数量的减少，跟增加的js代码逻辑一样，只需要修改其中的count-1以及查找元素next修改为prev 123456789101112131415161718192021222324252627282930313233343536373839404142434445$('.minus').click(function () &#123; // 获取商品id和当前数量 sku_id = $(this).prev().attr('sku_id'); count = $(this).prev().val(); count = parseInt(count) -1; if(count &lt;=0)&#123; return &#125; csrf = $('input[name=\"csrfmiddlewaretoken\"]').val(); // 组织参数 params = &#123;'sku_id':sku_id, 'count':count, \"csrfmiddlewaretoken\":csrf&#125;; error_update = false; total = 0; // 设置ajax请求为同步 $.ajaxSettings.async = false; // 向后端发送ajax post请求 $.post('/cart/update', params, function (data) &#123; if(data.errno == \"ok\")&#123; error_update = false; total = data.total_count &#125; else &#123; // 更新失败 error_update = true; alert(data.error_msg) &#125; &#125;); // 设置ajax请求为异步 $.ajaxSettings.async = true; // 判断是否更新成功 if(error_update == false)&#123; // 重新设置页面上商品数量 $(this).prev().val(count); // 计算商品小计 update_goods_amount($(this).parents('ul')); // 获取商品对应的checkbox的选中状态，如果被选中，更新页面信息 is_checked = $(this).parents('ul').find(':checkbox').prop('checked'); if (is_checked)&#123; // 更新页面信息 get_cart_info() &#125; // 更新页面上购物车商品的总件数 $('.total_count').children('em').text(total) &#125;&#125;) step8 测试 step9 将增加商品数量以及减少商品数量复用的代码进行封装到函数中 1234567891011121314151617181920212223error_update = false;total = 0;function update_remote_cart_info(sku_id, count)&#123; csrf = $(&apos;input[name=&quot;csrfmiddlewaretoken&quot;]&apos;).val(); // 组织参数 params = &#123;&apos;sku_id&apos;:sku_id, &apos;count&apos;:count, &quot;csrfmiddlewaretoken&quot;:csrf&#125;; // 设置ajax请求为同步 $.ajaxSettings.async = false; // 向后端发送ajax post请求 $.post(&apos;/cart/update&apos;, params, function (data) &#123; if(data.errno == &quot;ok&quot;)&#123; error_update = false; total = data.total_count &#125; else &#123; // 更新失败 error_update = true; alert(data.error_msg) &#125; &#125;); // 设置ajax请求为异步 $.ajaxSettings.async = true;&#125; 5.购物车中的商品手动输入数量 step1 input输入框类属性失去焦点则进行逻辑处理，跟前面的增加减少大同小异 12345678910111213141516171819202122232425262728293031323334353637// 记录用户输入商品数量之前的商品数量pre_count = 0;$('.num_show ').focus(function () &#123; pre_count = $(this).val()&#125;);$('.num_show ').blur(function () &#123; // 获取商品id和当前数量 sku_id = $(this).attr('sku_id'); count = $(this).val(); if(isNaN(count) || count.trim().length==0 || parseInt(count)&lt;=0)&#123; // 当出现用户输入的数量不是数字或空格或小于等于0时，设置数量的值为输入前商品的数量 $(this).val(pre_count); return &#125; // 更新购物车数据 count = parseInt(count); update_remote_cart_info(sku_id, count); // 判断是否更新成功 if(error_update == false)&#123; // 重新设置页面上商品数量 $(this).val(count); // 计算商品小计 update_goods_amount($(this).parents('ul')); // 获取商品对应的checkbox的选中状态，如果被选中，更新页面信息 is_checked = $(this).parents('ul').find(':checkbox').prop('checked'); if (is_checked)&#123; // 更新页面信息 get_cart_info() &#125; // 更新页面上购物车商品的总件数 $('.total_count').children('em').text(total) &#125; else&#123; // 更新失败则设置为原来的手动输入前的值 $(this).val(pre_count) &#125;&#125;) step2 效果演示，输入不合法的数量，数量显示为输入之前的数量，当输入的商品数量大于实际库存则显示之前的数量 6.在购物车中删除商品记录 step1 在df_cart/views中定义类视图，使用ajax post请求方式向该视图进行数据传递 12345# /cart/deleteclass CartDelView(View): \"\"\"删除购物车记录\"\"\" def post(self, request): pass step2 获取参数校验参数数据库进行删除返回正确响应数据 1234567891011121314151617181920212223# 判断用户是否登录user = request.userif not user.is_authenticated(): return JsonResponse(&#123;\"errno\": 0, \"error_msg\": \"请先登录\"&#125;)# 1.获取参数并判断sku_id = request.POST.get(\"sku_id\")if not sku_id: return JsonResponse(&#123;\"errno\": 1, \"error_msg\": \"参数不完整\"&#125;)# 2. 校验商品是否存在try: sku = GoodsSKU.objects.get(id=sku_id)except GoodsSKU.DoesNotExist: return JsonResponse(&#123;\"errno\": 2, \"error_msg\": \"商品不存在\"&#125;)#3.删除购物车记录conn = get_redis_connection(\"default\")cart_key = \"cart_%d\" % user.idconn.hdel(cart_key, sku_id)#4.获取更新后的购物车中商品的总件数total_count = 0vals = conn.hvals(cart_key)for val in vals: total_count += int(val)return JsonResponse(&#123;\"errno\": \"ok\", \"total_count\":total_count, \"error_msg\": \"删除成功\"&#125;) step3 在模板文件中进行删除事件js编写 1234567891011121314151617181920212223242526// 删除购物车记录$('.cart_list_td').children('.col08').children('a').click(function () &#123; // 获取对应商品的id sku_id = $(this).parents('ul').find('.num_show').attr(\"sku_id\"); csrf = $('input[name=\"csrfmiddlewaretoken\"]').val(); params = &#123;\"sku_id\":sku_id, \"csrfmiddlewaretoken\":csrf&#125;; // 获取商品所在的ul元素 sku_ul = $(this).parents('ul'); $.post('/cart/delete', params, function (data) &#123; if(data.errno == \"ok\")&#123; // 删除成功 移除页面上商品所在的ul元素 sku_ul.remove() // 获取被删除商品是否为选中状态 is_checked = sku_ul.find(':checkbox').prop('checked') if(is_checked)&#123; // 更新页面信息 get_cart_info() &#125; // 重新设置页面上的总件数 $('.total_count').children('em').text(data.total_count) &#125; else &#123; alert(data.error_msg) &#125; &#125;)&#125;) step4 测试 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/89015816","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目之Web端电商网站的实战开发（四）","slug":"Django项目之Web端电商网站的实战开发（四）","date":"2019-11-07T04:00:15.173Z","updated":"2019-11-13T14:21:20.515Z","comments":true,"path":"2019/11/07/Django项目之Web端电商网站的实战开发（四）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/07/Django项目之Web端电商网站的实战开发（四）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶Windows环境下安装FastDFS_Client 二丶Django二次开发对接FastDFS 三丶天天生鲜首页","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶Windows环境下安装FastDFS_Client 二丶Django二次开发对接FastDFS 三丶天天生鲜首页 一丶Windows环境下安装FastDFS_Client1.在windows环境下直接使用pip install fdfs-client-py进行安装则会出现以下提示 2.在windows环境下需进行如下安装 step1 下载fdfs_client包https://pan.baidu.com/s/11Rd6q3vr7vH3Lr1_8JMfSw，提取码u1d7 step2 将解压之后的fdfs_client文件夹copy到python解释器下的Lib目录中 step3 进入fdfs_client目录，编辑storage_client.py文件，将第12行代码注释（避免提示ImportError: No module named sendfile错误信息） step4 安装mutagen step5 安装requests step6 在解释器目录下新建logs文件夹，用于存放fdfs客户端日志文件 step7 修改fdfs配置文件client.conf，需要注意的是base_path的路径是在以client.conf为起始路径进行查找的 step8 回到虚拟机ubuntu（192.168.1.10），开启fdfs服务以及nginx服务 step9 进行上传文件测试，打开cmd命令窗口，进行python2环境（博主将一个水果图片直接放在D盘中然后进行此图片上传操作），配置文件路径以及要上传的文件路径均为绝对路径 123from fdfs_client.client import Fdfs_clientclient = Fdfs_client(r\"D:\\Python27\\Lib\\fdfs_client\\client.conf\")client.upload_by_filename(r\"D:\\goods.jpg\") step10 上传成功后，返回文件id，在windows浏览器中直接访问ubuntu电脑的ip（也就是nginx服务器的ip端口，然后nginx再去到fdfs系统中获取对应文件id的文件，最后返回给浏览器，最后浏览器将该文件渲染出来，最终显示出图片）http://192.168.1.10:8888/group1//M00/00/00/wKgBClygfSuAO8GOAAAX1PFRdzg942.jpg，如下图可以看见响应报头中的server为在ubuntu中安装的nginx版本 step11 同样的在ubuntu系统中访问该上传成功的文件id，一样成功的在浏览器中显示出来（这里的IP就要写本地的IP） 二丶Django二次开发对接FastDFS1.项目中使用上传图片使用图片流程图 2.更改django默认上传文件的存储方式 ，django站点管理中进行文件的上传默认使用的是FileSystemStorage类，这个类在本地文件系统上实现了基本的文件存储功能，它继承自Storage类 ，并且提供父类的所有公共方法的实现，所以可以定义一个类来继承Storage类，重写这个类中方法来实现更改django的默认存储方式，可以参考django的API文档 3.编写一个自定义存储系统， step1 自定义的存储系统必须为 Django.core.files.storage.Storage的一个子类 123from django.core.files.storage import Storageclass MyStorage(Storage): ... step2 在你的存储类中，除了其他自定义的方法外，还必须实现 _open()打开文件 以及 _save()保存文件方法，如果你的类提供了本地文件存储，它必须重载 path() 方法 step3 在项目utils目录下创建一个fdfs的python包，并在这个包下创建storage.py模块，在这个模块中实现自定义存储系统 step4 在storage.py中定义一个类继承与storage的子类Stroage，实现_open()以及_save()方法 step5 导入Fdfs_client类，将client.conf配置文件拷贝到utils/fdfs目录下 step6 修改client.conf配置文件中 1base_path=D:\\Python27\\logs step7 因为项目中场景不使用_open方法，只是用_save方法，所以在_save进行编写，创建Fdfs_client对象 1client = Fdfs_client(r\"./utils/fdfs/client.conf\") step8 上传文件到FastDFS系统中,upload_by_buffer方法是上传文件内容，而不是文件名了 1res = client.upload_by_buffer(content.read()) step9 判断是否上传成功 123456789101112131415# 上传成功返回的字段数据\"\"\"dict&#123; 'Group name': group_name, 'Remote file_id': remote_file_id, 'Status': 'Upload successed.', 'Local file name': '', 'Uploaded size': upload_size, 'Storage IP': storage_ip&#125;\"\"\"if res.get(\"Status\") != \"Upload successed.\": # 表示上传失败 raise step10 上传成功获取文件id，并返回 12filename = res.get(\"Remote file_id\")return filename step11 重写exists方法调用_save方法之前会去调用exists方法，判断文件在系统中是够存在 1234def exists(self, name): \"\"\"如果提供的名称所引用的文件在文件系统中存在，则返回True，否则如果这个名称可用于新文件，返回False\"\"\" # 因为在django中不存在文件名情况，所以直接返回false return False 4.在django admin后台管理页面测试文件存储类 step1 在settings配置文件中设置django文件存储类为上面定义的类 1DEFAULT_FILE_STORAGE = \"utils.fdfs.storage.FDFSStorage\" step2 在df_goods/admin中注册商品类型模型类 12345from django.contrib import adminfrom df_goods.models import GoodsType # 注册商品类型模型类admin.site.register(GoodsType) step3 创建超级管理员 step4 在浏览器输入http://127.0.0.1:8000/admin/ 进入后台管理页面 step5 在商品种类栏点击增加（标识标识的是商品分类中对应分类标签中的class的值） step6 点击保存后，提示保存成功 step7 进入新鲜水果后，出现错误提示，必须保证有一个url方法 step8 在FDFSStorage类中定义url方法，直接返回name 12def url(self, name): return name step9 刷新报错页面，显示出filename的值（也就是上传文件到FastDFS成功后返回的文件id的值） step10 在浏览器中访问http://192.168.1.10:8888/group1/M00/00/00/wKgBClygnuOATdepAAAgnaeGwNQ6841857，则出现下载，因为在获取Remote file_id的值的时候，并没有后缀名，导致出现下载 step11 新建一个html文件，创建img标签，src就等于http://192.168.1.10:8888/group1/M00/00/00/wKgBClygnuOATdepAAAgnaeGwNQ6841857 step12 直接打开该html文件，成功将图片显示出来 step13 修改url方法返回参数 12def url(self, name): return \"http://192.168.1.10:8888/\"+name 5.优化自定义文件存储类 step1 在settings配置文件中设置client.conf的路径以及nginx服务器的ip和port 12345# 设置fdfs使用client.conf配置文件的路径FDFS_CLIENT_CONF_PATH = r\"./utils/fdfs/client.conf\" # 设置fdfs存储系统上的ngin服务器的ip和端口FDFS_URL = r\"http://192.168.1.10:8888/\" step2 在FDFSStorage类中定义魔法方法，使client.conf的路径以及nginx服务器的ip和port动态生成，增强存储类的灵活性 1234567def __init__(self, client_conf=None, base_url=None): if client_conf is None: client_conf = settings.FDFS_CLIENT_CONF_PATH if base_url is None: base_url = settings.FDFS_URL self.client_conf = client_conf self.base_url = base_url step3 将以下两处进行替换 12client = Fdfs_client(self.client_conf)return self.base_url+name 三丶天天生鲜首页1.定义类视图显示首页页面 step1 在df_goods/views中定义IndexView类视图，并在这个类中定义get方法，用于显示首页 123456# http://127.0.0.1:8000class IndexView(View): '''首页''' def get(self, request): '''显示首页''' return render(request, 'index.html') step2 在df_goods/urls中导入类视图，并调用其父类的as_view方法 1url(r\"^$\", IndexView.as_view(), name=\"index\") step3 进入http://127.0.0.1:8000/项目首页地址，成功显示首页页面 step4 将df_goods/models中的IndexPromotionBanner首页促销活动模型类的url字段的类型修改为CharField类型，因为URLField类型，在admin中注册后，在django管理后台进行添加时，会去解析URL链接地址是否有效，并且该字段是必须填写的，所以修改为CharField类型，就可填可不填，并且不用去解析 1url = models.CharField(max_length=256, verbose_name='活动链接') 2.首页内容获取与展示 step1 在IndexView类视图get方法中，获取商品的种类信息 1types = GoodsType.objects.all() step2 获取首页页面幻灯片中的商品信息，以index字段（展示顺序）进行排序 1goods_banners = IndexGoodsBanner.objects.all().order_by('index') step3 获取首页促销活动信息，以以index字段（展示顺序）进行排序 1promotion_banners = IndexPromotionBanner.objects.all().order_by('index') step4 获取首页中分类商品展示信息（types），遍历商品种类信息，获取每个商品种类（type）为GoodsType对象，然后在数据库商品分类表（IndexTypeGoodsBanner）中根据type字段（商品类型）以及display_type（展示类型）查询数据，并按照表index字段（展示顺序）进行排序显示，display_type=1表示图片展示类型，display_type=2表示文字展示类型；然后给每个商品种类对象添加image_banners属性以及title_banners属性 123456789for type in types: # GoodsType # 获取type种类首页分类商品的图片展示信息 image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1).order_by('index') # 获取type种类首页分类商品的文字展示信息 title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0).order_by('index') # 动态给type增加属性，分别保存首页分类商品的图片展示信息和文字展示信息 type.image_banners = image_banners type.title_banners = title_banners step5 获取用户购物车商品数量信息，这里先设置为0，表示默认没有 1cart_count = 0 # 默认设置为0 step6 构造上下文响应数据，并返回给模板文件 1234567context = &#123;'types':types, 'goods_banners':goods_banners, 'promotion_banners':promotion_banners, 'cart_count':cart_count&#125; # 使用模板return render(request, 'index.html', context step7 在index.html模板文件中，进行填坑数据处理，在for循环遍历是从1开始累加 商品种类 123456&lt;ul class=\"subnav fl\"&gt; &#123;% for type in types %&#125; &lt;li&gt;&lt;a href=\"#model0&#123;&#123; forloop.counter &#125;&#125;\" class=\"&#123;&#123; type.logo &#125;&#125;\"&gt;&#123;&#123; type.name &#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;# &lt;li&gt;&lt;a href=\"#model02\" class=\"seafood\"&gt;海鲜水产&lt;/a&gt;&lt;/li&gt;#&#125; &#123;% endfor %&#125;&lt;/ul&gt; 幻灯片 123&#123;% for banner in goods_banners %&#125; &lt;li&gt;&lt;a href=\"#\" &gt;&lt;img src=\"&#123;&#123; banner.image.url &#125;&#125;\" alt=\"幻灯片\"&gt;&lt;/a&gt;/li&gt;&#123;% endfor %&#125; 促销活动 1234&#123;% for banner in promotion_banners %&#125;&lt;a href=\"&#123;&#123; banner.url &#125;&#125;\"&gt;&lt;img src=\"&#123;&#123; banner.image.url &#125;&#125;\"&gt;&lt;/a&gt;&#123;#&lt;a href=\"#\"&gt;&lt;img src=\"&#123;% static 'images/adv02.jpg' %&#125;\"&gt;&lt;/a&gt;#&#125;&#123;% endfor %&#125; 分类商品 1234567891011121314151617181920212223&lt;ul class=\"subnav fl\"&gt; &#123;% for type in types %&#125; &lt;li&gt;&lt;a href=\"#model0&#123;&#123; forloop.counter &#125;&#125;\" class=\"&#123;&#123; type.logo &#125;&#125;\"&gt;&#123;&#123; type.name &#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;# &lt;li&gt;&lt;a href=\"#model02\" class=\"seafood\"&gt;海鲜水产&lt;/a&gt;&lt;/li&gt;#&#125; &#123;% endfor %&#125;&lt;/ul&gt;&lt;div class=\"slide fl\"&gt; &lt;ul class=\"slide_pics\"&gt; &#123;% for banner in goods_banners %&#125; &lt;li&gt;&lt;a href=\"#\" &gt;&lt;img src=\"&#123;&#123; banner.image.url &#125;&#125;\" alt=\"幻灯片\"&gt;&lt;/a&gt;/li&gt; &#123;% endfor %&#125;&#123;# &lt;li&gt;&lt;a href=\"#\" &gt;&lt;img src=\"../static/images/slide02.jpg\" alt=\"幻灯片\"&gt;&lt;/li&gt;#&#125; &lt;/ul&gt; &lt;div class=\"prev\"&gt;&lt;/div&gt; &lt;div class=\"next\"&gt;&lt;/div&gt; &lt;ul class=\"points\"&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=\"adv fl\"&gt; &#123;% for banner in promotion_banners %&#125; &lt;a href=\"&#123;&#123; banner.url &#125;&#125;\"&gt;&lt;img src=\"&#123;&#123; banner.image.url &#125;&#125;\"&gt;&lt;/a&gt;&#123;# &lt;a href=\"#\"&gt;&lt;img src=\"&#123;% static 'images/adv02.jpg' %&#125;\"&gt;&lt;/a&gt;#&#125; &#123;% endfor %&#125;&lt;/div&gt; step8 刷新首页http://127.0.0.1:8000/页面后，只显示了商品分类信息，幻灯片和商品促销以及分类商品均为空白，这是因为数据库中并没有数据，而显示了商品分类信息，是因为博主前面注册了商品类型模型类（GoodsType）并在django管理后台进行了商品类型的添加，所以数据库中df_goods_type表有数据 3.数据准备 step1 在df_goods/admin中注册模型类 step2 进入http://127.0.0.1:8000/admin/django后台管理页面 step3 点击商品SPU栏的增加，进行数据库df_goods表数据的添加，添加后进行保存即可 step4 保存成功后进入商品SPU栏后，则显示添加后的数据 step5 当添加商品SPU数据后，再对商品栏（df_goods_sku表）进行数据添加操作 step6 点击保存，结果报错了，根据报错提示没有找到文件的位置，异常目录为tracker_client.py，说明tracker服务器没有找到，于是博主立马知道了，因为博主在写博客分为两个时间，一个是在家，另一个是在公司，即IP端不同，此时在django后台添加数据是在公司的IP网段下，而client.conf中的配置为家里的IP段配置，所以添加数据报错了 step7 修改ubuntu中fdfs目录下的storage.conf，mod_fastdfs.conf以及windows项目中fdfs目录下的client.conf配置文件里面的tracker_server的ip为公司环境IP后，刷新提交页面，添加记录成功 step8 添加操作都是体力活啊，这里就不一一进行演示了，博主花了大半会儿功夫将主页需要的数据添加完毕，添加6个表的数据 step9 此时添加完主页必有的表字段数据后，刷新主页面 step10 在数据库中表示数相关的表数据 说明：由于数据太多只截取前面两条数据 商品SPU 商品 商品种类 首页幻灯片商品 主页促销活动商品 主页分类展示商品 4.首页获取购物车商品数目 step1 分析存储购物车记录 12345678910111.什么时候添加购物车数目 当用户点击商品加入购物车时，需要添加购物车数目2.什么时候需要获取购物车记录 当用户使用购物车记录时和用户访问购物车页面数据时3.使用什么来数据库来存储购物车的记录 使用redis数据库进行存储，因为加入购物车是高频的4.以哪种数据格式进行存储 使用hash（属性：值的关系进行购物车数目的存储） cart_用户id:&#123;&apos;sku_id1&apos;:商品数目，&apos;sku_id2&apos;:商品数目&#125; 例如：&apos;cart_1&apos;:&#123;&apos;1&apos;:4,&apos;2&apos;,8&#125; 在首页左上方显示的购物车显示的是hash数据中的元素总数，即2（商品id为1的和商品id为2的共两个），大多网站都是显示商品类总数，而不是商品量总数 step2 在IndexView视图函数中获取用户购物车商品数目 12345678user = request.user # 获取user对象cart_count = 0 # 默认设置为0if user.is_authenticated(): # 如果返回True表示用户已登录 # 用户已登录 conn = get_redis_connection('default') # 获取配置中default默认redis连接对象 cart_key = 'cart_%d'%user.id # 设置key # 通过hlen方法获取购物车商品数目 cart_count = conn.hlen(cart_key) step3 在父模板base.html文件中填写购物车数目的坑 1&lt;div class=\"goods_count fl\" id=\"show_count\"&gt;&#123;&#123; cart_count &#125;&#125;&lt;/div&gt; step4 刷新主页，因为还没有编写添加商品到购物车逻辑代码，所以cart_count为0，即在主页显示为0 step5 登录cdtaogang_2账号（用户id=2），进入redis数据库，选择settings配置文件中配置的第五个数据库，然后使用hmset设置模拟数据 （’cart_2’:{‘1’:4,’2’:8}），使用hlen获取元素长度（个数）2，即购物车数目为2 step6 此时刷新页面，成功显示购物车数目为2 5.将首页页面静态化，把原本动态的页面处理结果保存成html文件，让用户直接访问这个生成出来的静态的html页面 说明：因为网站首页几乎是不变的，当首页需要更改修改数据时，才会发生变化，换句话说就是当后台管理员首页页面对应的数据时，才会生成新的首页静态页面，大多用户浏览网站都是看主页，当很多用户浏览主页时，不管登录与否页面显示的内容都是一样的，每次用户请求主页页面时，都会到数据库去查询数据，并且查询的数据都是一样的，所以将页面进行静态化后，就不用每次用户请求首页数据时都要到数据库进行查询数据，再返回给用户，这样做大大的对减少网站服务器的压力，还利于SEO的优化 step1 分析静态页面的实现 12341.什么时候需要重新生成静态页面（用户未登录的主页页面） 当管理员在后台修改添加以及删除页面对应数据库表中的数据时需要重新生成新的静态页面2.如何生成使用celery，在tasks.py文件中异步生成首页静态页面 step2 在tasks.py文件中定义一个任务函数 1234@app.taskdef generate_static_index_page(): \"\"\"生成首页静态页面\"\"\" pass step3 获取首页页面上的数据，直接把IndexView类视图get方法中的代码拿过来，因为生成的首页静态页面是用户不登录状态，所以，不需要获取购物车的数目，也不需要返回HttpResponse对象 1234567891011types = GoodsType.objects.all()goods_banners = IndexGoodsBanner.objects.all().order_by('index')promotion_banners = IndexPromotionBanner.objects.all().order_by('index')for type in types: image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1).order_by('index') title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0).order_by('index') type.image_banners = image_banners type.title_banners = title_bannerscontext = &#123;'types': types, 'goods_banners': goods_banners, 'promotion_banners': promotion_banners&#125; step4 因为是显示用户未登录的首页静态页面，所以必须创建一个新的主页模板文件，创建首页静态页面继承的父模板文件static_base.html以及静态主页模板文件static_index.html，将base.html内容直接拷贝到static_base.html中，再将index.html中的内容全部拷贝到static_index.html中，修改static_index.html模板文件的继承模板文件为static_base.html，然后去除父模板文件static_base.html中的欢迎以及显示用户所在的标签，只留下登录和登出即可 step5 使用loader方法加载模板文件，再通过模板对象中的render方法渲染出模板文件的内容，最后通过文件读写操作，将模板内容（static_index_html）写入到static目录下的index.html中 12345678# 1.加载模板文件template = loader.get_template(\"static_index.html\") # 返回模板对象# 2.渲染模板内容（数据填坑）static_index_html = template.render(context)# 3.生成首页静态文件save_index_static_file = os.path.join(settings.BASE_DIR, 'static/index.html') # 生成首页静态文件的路径with open(save_index_static_file, \"w\") as f: f.write(static_index_html) step6 在Terminal终端上新开一个终端，执行celery -A celery_tasks.tasks worker -l info 启动worker，结果报错了提示没有模块名，from df_goods.models import GoodsType, IndexGoodsBanner, IndexTypeGoodsBanner, IndexPromotionBanner导入模块报错，原因是在django配置环境没有初始化的时候，导入会报错，根本找不到，所以需要将这几个模型类放到django.setup()吃实话下面，这样就能找到，不会出现以下错误 step7 重新执行celery -A celery_tasks.tasks worker -l info，启动2个worker成功 step8 向worker发出任务，打开IDE下方的Python Console，导入任务函数generate_static_index_page，去调用delay方法，向worker发送任务成功 step9 回到Terminal中查看celery 日志，显示任务执行成功，时长0.259秒 step10 查看static目录是否生成了index.html文件 step11 查看index.html文件内容，该内容已经是对templates/index.html模板进行填坑后的数据了 step12 在浏览器中直接打开static/index.html静态页面，只显示出商品图片，也是所有填坑数据，所有的静态文件资源路径not found，无法找到 6.配置nginx服务器，让nginx服务器来提交静态页面 step1 首先想要nginx服务器提交静态页面，那么就需要在nginx所在的服务器中有项目文件，所以拷贝项目到nginx服务器（Ubuntu）桌面上 step2 其次是添加nginx服务器server配置，添加如下配置说明：listen 监听80端口，也就是nginx的默认端口号 /static表示 访问请求地址为 nginx服务器IP:listen/static（192.168.4.63:80/static）alias指定文件路径为ubuntu中项目下的static目录，顺便说一下alisa配置端只有location本地，从本地获取路径，而root配置端为http、server、location、if /表示 访问请求地址为 nginx服务器IP:listen/static（192.168.4.63:80）root指定文件路径为ubuntu中项目下的static目录 index 表示配置网页初始页，后面可以跟多个，会在root目录下去查找，找到匹配的就返回 1sudo vi /usr/local/nginx/conf/nginx.conf 之所以配置/static和/这两种路径是因为生成的static目录下的index.html文件内容中，静态资源文件路径都是/static开头的，当在浏览器中输入http://192.168.4.63/（nginx服务器IP） ，就会匹配location / 地址，然后就会将static目录下查找是否存在index.html或者是index.htm文件并且将查找到的文件返回给浏览器，浏览器在对index.html进行解析时，然后发现内容中的所有静态资源需要从192.168.4.63:80/static/xxxxx地址进行获取，匹配location /static地址然后就会从ubuntu桌面项目static目录下获取文件 1234567891011121314151617server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location /static &#123; alias /home/taogang/Desktop/dailyfresh/static/; &#125; location / &#123; root /home/taogang/Desktop/dailyfresh/static/; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; step3 重启nginx服务 step4 在浏览器中输入http://192.168.4.63/成功显示出首页静态页面，**不输入端口号浏览器默认端口就是80** step5 查看首页静态页面中静态资源访问地址，验证step2博主说的静态资源访问地址 7.django后台管理更新首页数据时重新生成新的首页静态页面 step1 在df_goods/admin中定义IndexPromotionBannerAdmin类，该类继承于admin.ModelAdmin，在这个类中重写父类的save_model方法以及delete_model方法用于django后台对表数据进行修改删除时，会调用我们重写父类的方法，在这两个方法中再调用父类的的save_model以及delete_model方法完成数据的更新操作，然后再向worker发出任务，重新从数据库中获取修改后的数据，读写templates目录下已经更新数据后的index.html文件的内容写入到static下的index.html中，显示最新的主页静态页面 12345678910111213141516171819class IndexPromotionBannerAdmin(admin.ModelAdmin): \"\"\"重写父类中的save_model方法，该方法在后台管理页面对数据修改时时会调用此方法\"\"\" def save_model(self, request, obj, form, change): # 调用父类中国的save_model方法让数据完成更新 super(IndexPromotionBannerAdmin, self).save_model(request,obj,form,change) # 向worker发出任务，重新生成更新数据后的页面 from celery_tasks.tasks import generate_static_index_page generate_static_index_page.delay() def delete_model(self, request, obj): \"\"\"对数据进行删除时会调用\"\"\" super(IndexPromotionBannerAdmin, self).delete_model(request, obj) # 向worker发出任务，重新生成更新数据后的页面 from celery_tasks.tasks import generate_static_index_page generate_static_index_page.delay( # 注册首页促销活动模型类admin.site.register(IndexPromotionBanner, IndexPromotionBannerAdmin) # 将管理类添加进去 step2 因为首页静态页面是从nginx服务器中（ubuntu）本地项目static目录下的index.html，所以在windows项目这边需要将tasks.py文件中broker设置为nginx服务器的中的redis数据库作为中间人 1app = Celery(\"celery_tasks.tasks\", broker=\"redis://192.168.1.8:6379/4\") step3 在ubuntu中配置redis可任意ip连接，注释掉bind即可 step4 测试在windows电脑上远程ubuntu电脑上的redis数据库 step5 在nginx服务器中（ubuntu）中启动worker step6 然后在django后台修改数据，点击保存时即worker显示接收到任务，最后访问192.168.1.8（nginx服务器IP），查看静态页面是否更新，博主这里就修改主页中促销商品的显示顺序，index展示顺序 step7 刷新主页静态页面http://192.168.1.8/，结果页面没人任何数据，原因是在ubuntu中的项目配置的mysql数据库为本地，所以没说任何数据，之前在django管理页面添加数据为windows本地项目，所以需要在windows msyql中新建个用户用于ubuntu项目中进行访问数据，需要注意的是windows关闭防火墙 1grant all privileges on dailyfresh.* to &quot;taogang&quot;@&quot;%&quot; identified by &quot;123456&quot; step8 修改ubuntu项目中的settings配置文件mysql项 step9 重新刷新http://192.168.1.8/主页静态页面后，成功显示出数据 step10 修改IndexPromotionBannerAdmin类为BaseModelAdmin，并定义其他模型管理类，继承于BaseModelAdmin，当管理员在后台对其他表数据进行修改时也同样调用我们重写的方法对数据进行更新，然后向worker发出任务，完成首页静态页面数据的更新 12345678910111213141516171819202122232425262728293031323334353637383940class BaseModelAdmin(admin.ModelAdmin): \"\"\"重写父类中的save_model方法，该方法在后台管理页面对数据修改时时会调用此方法\"\"\" def save_model(self, request, obj, form, change): print \"11111111111\" # 调用父类中国的save_model方法让数据完成更新 super(BaseModelAdmin, self).save_model(request,obj,form,change) # 向worker发出任务，重新生成更新数据后的页面 from celery_tasks.tasks import generate_static_index_page generate_static_index_page.delay() def delete_model(self, request, obj): \"\"\"对数据进行删除时会调用\"\"\" super(BaseModelAdmin, self).delete_model(request, obj) # 向worker发出任务，重新生成更新数据后的页面 from celery_tasks.tasks import generate_static_index_page generate_static_index_page.delay()class GoodsTypeAdmin(BaseModelAdmin): passclass GoodsSKUAdmin(BaseModelAdmin): passclass GoodsAdmin(BaseModelAdmin): passclass IndexGoodsBannerAdmin(BaseModelAdmin): passclass IndexPromotionBannerAdmin(BaseModelAdmin): passclass IndexTypeGoodsBannerAdmin(BaseModelAdmin): pass# 注册商品类型模型类admin.site.register(GoodsType, GoodsTypeAdmin)# 注册商品SKU模型类admin.site.register(GoodsSKU, GoodsSKUAdmin)# 注册商品SPU模型类admin.site.register(Goods, GoodsAdmin)# 注册首页幻灯片展示模型类admin.site.register(IndexGoodsBanner, IndexGoodsBannerAdmin)# 注册首页促销活动模型类admin.site.register(IndexPromotionBanner, IndexPromotionBannerAdmin)# 注册分类商品展示模型类admin.site.register(IndexTypeGoodsBanner, IndexTypeGoodsBannerAdmin) 8.关于静态页面与django类视图IndexView调度说明 step1 前面所有的访问操作都是192.168.1.8（主页静态页面，通过Ubuntu nginx服务器返回）以及127.0.0.1:8000（主页动态页面，通过windows django服务器返回），即问题是当用户访问时网站主页时，怎么区分给用户访问静态主页还是动态主页且用户只能输入一个IP地址，不可能一个网站有两个域名IP吧，所以我们设定用户请求的网站地址为192.168.1.8，当用户直接在浏览器中输入http://192.168.1.8/时，就相当于访问 / 就向ngin服务器获取静态主页，当用户输入http://192.168.1.8/index时，就想当于访问 /index 就向django服务器获取类视图中返回的动态主面，因此就可以来判断用户请求的是静态主页还是动态主页，那么为了完成用户请求地址的判断，则需要使用调度服务器（另一个nginx服务器作为请求地址的调度），示意图如下 step2 修改IndexView的url路由 1url(r\"^/index$\", IndexView.as_view(), name=\"index\"), # 首页 9.设置以及获取首页的缓存数据 step1 分析 1231.把首页用到的数据存放到缓存中2.当用户请求首页页面数据时，就到redis数据中获取缓存数据3.如果数据获取不到时，再去数据进行查询，这样做就减少了数据库的查询操作 step2 在IndexView视图函数中先去获取获取缓存数据，当返回的数据为空时， 则对数据库进行查询操作，并设置缓存数据 123456789101112131415161718192021222324252627282930313233def get(self, request): '''显示首页''' # 先从缓存中获取主页数据 context = cache.get(\"index_page_data\") if context is None: \"\"\"缓存中没有数据就去数据库查询获取并设置\"\"\" print(\"设置主页缓存数据\") # 获取商品的种类信息 types = GoodsType.objects.all() # 获取首页轮播商品信息 goods_banners = IndexGoodsBanner.objects.all().order_by('index') # 获取首页促销活动信息 promotion_banners = IndexPromotionBanner.objects.all().order_by('index') # 获取首页分类商品展示信息 for type in types: # GoodsType # 获取type种类首页分类商品的图片展示信息 image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1).order_by('index') # 获取type种类首页分类商品的文字展示信息 title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0).order_by('index') # 动态给type增加属性，分别保存首页分类商品的图片展示信息和文字展示信息 type.image_banners = image_banners type.title_banners = title_banners context = &#123;'types': types, 'goods_banners': goods_banners, 'promotion_banners': promotion_banners&#125; # 设置首页数据的缓存 cache.set(\"index_page_data\", context, 3600) step3 使用字段对象中的update方法，向content字段中设置购物车，这个方法是当字典中有这个cart_count键时，则不进行修改，没有这个键则进行添加操作 1context.update(cart_count=cart_count) step4 当第一次访问http://127.0.0.1:8000/index主页页面时，查看django服务运行日志，成功打印出设置主页缓存数据，第二次访问则没有打印 step5 查看redis数据 10.更新首页缓存数据 step1 分析 12什么时候需要更新首页中的缓存数据当后台管理员对主页表数据进行修改时，需要更新主页缓存数据 step2 在df_goods/admin中BaseModelAdmin中，进行缓存数据的清除 12# 清除缓存数据cache.delete(\"index_page_data\") ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/88921322","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目之Web端电商网站的实战开发（三）","slug":"Django项目之Web端电商网站的实战开发（三）","date":"2019-11-07T02:33:01.899Z","updated":"2019-11-13T14:08:46.311Z","comments":true,"path":"2019/11/07/Django项目之Web端电商网站的实战开发（三）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/07/Django项目之Web端电商网站的实战开发（三）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶模板文件继承 二丶用户中心页面显示 三丶登录验证以及登录后跳转的地址 四丶封装login_required方法 五丶登录后显示用户名以及退出登录 六丶用户中心-地址 七丶用户中心-信息 八丶分布式文件系统FastDFS 九丶Nginx配置FastDFS使用的安装和配置 十丶Python与FastDFS进行交互","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶模板文件继承 二丶用户中心页面显示 三丶登录验证以及登录后跳转的地址 四丶封装login_required方法 五丶登录后显示用户名以及退出登录 六丶用户中心-地址 七丶用户中心-信息 八丶分布式文件系统FastDFS 九丶Nginx配置FastDFS使用的安装和配置 十丶Python与FastDFS进行交互 一丶模板文件继承1.分析网页中共有的模块，定义父模板 step1 在templates目录下常见base.html文件，用于主页（index.html），登录页（login.html）以及注册页（register.html）模板的继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&#123;# 首页 注册 登录 #&#125;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"&gt;&#123;% load staticfiles %&#125;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &#123;# 网页标题内容块 #&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock title %&#125;&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"&#123;% static 'css/reset.css' %&#125;\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"&#123;% static 'css/main.css' %&#125;\"&gt; &#123;# 网页顶部引入文件块 #&#125; &#123;% block topfiles %&#125;&#123;% endblock topfiles %&#125;&lt;/head&gt;&lt;body&gt;&#123;# 网页顶部欢迎信息块 #&#125;&#123;% block header_con %&#125; &lt;div class=\"header_con\"&gt; &lt;div class=\"header\"&gt; &lt;div class=\"welcome fl\"&gt;欢迎来到天天生鲜!&lt;/div&gt; &lt;div class=\"fr\"&gt; &lt;div class=\"login_info fl\"&gt; 欢迎您：&lt;em&gt;张 山&lt;/em&gt; &lt;/div&gt; &lt;div class=\"login_btn fl\"&gt; &lt;a href=\"login.html\"&gt;登录&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"register.html\"&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;div class=\"user_link fl\"&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"../static/user_center_info.html\"&gt;用户中心&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"../static/cart.html\"&gt;我的购物车&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"../static/user_center_order.html\"&gt;我的订单&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endblock header_con %&#125; &#123;# 网页顶部搜索框块 #&#125;&#123;% block search_bar %&#125; &lt;div class=\"search_bar clearfix\"&gt; &lt;a href=\"index.html\" class=\"logo fl\"&gt;&lt;img src=\"&#123;% static 'images/logo.png' %&#125;\"&gt;&lt;/a&gt; &lt;div class=\"search_con fl\"&gt; &lt;input type=\"text\" class=\"input_text fl\" name=\"\" placeholder=\"搜索商品\"&gt; &lt;input type=\"button\" class=\"input_btn fr\" name=\"\" value=\"搜索\"&gt; &lt;/div&gt; &lt;div class=\"guest_cart fr\"&gt; &lt;a href=\"#\" class=\"cart_name fl\"&gt;我的购物车&lt;/a&gt; &lt;div class=\"goods_count fl\" id=\"show_count\"&gt;1&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endblock search_bar %&#125; &#123;# 网站主体内容块 #&#125;&#123;% block body %&#125;&#123;% endblock body %&#125; &lt;div class=\"footer\"&gt; &lt;div class=\"foot_link\"&gt; &lt;a href=\"#\"&gt;关于我们&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"#\"&gt;联系我们&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"#\"&gt;招聘人才&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"#\"&gt;友情链接&lt;/a&gt; &lt;/div&gt; &lt;p&gt;CopyRight © 2016 北京天天生鲜信息技术有限公司 All Rights Reserved&lt;/p&gt; &lt;p&gt;电话：010-****888 京ICP备*******8号&lt;/p&gt; &lt;/div&gt; &#123;# 网页底部html元素块 #&#125; &#123;% block bottom %&#125;&#123;% endblock bottom %&#125; &#123;# 网页底部引入文件块 #&#125; &#123;% block bottomfiles %&#125;&#123;% endblock bottomfiles %&#125;&lt;/body&gt;&lt;/html&gt; step2 在templates目录下常见base_detail_list.html文件，这个模板文件继承需base.html，用于详情页（detail.html），列表页（list.html）模板的继承 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123;# 详情页 列表页 #&#125;&#123;% extends 'base.html' %&#125;&#123;# 网站主体内容块 #&#125;&#123;% block body %&#125; &lt;div class=\"navbar_con\"&gt; &lt;div class=\"navbar clearfix\"&gt; &lt;div class=\"subnav_con fl\"&gt; &lt;h1&gt;全部商品分类&lt;/h1&gt; &lt;span&gt;&lt;/span&gt; &lt;ul class=\"subnav\"&gt; &lt;li&gt;&lt;a href=\"#\" class=\"fruit\"&gt;新鲜水果&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" class=\"seafood\"&gt;海鲜水产&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" class=\"meet\"&gt;猪牛羊肉&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" class=\"egg\"&gt;禽类蛋品&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" class=\"vegetables\"&gt;新鲜蔬菜&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" class=\"ice\"&gt;速冻食品&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;ul class=\"navlist fl\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"interval\"&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;手机生鲜&lt;/a&gt;&lt;/li&gt; &lt;li class=\"interval\"&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;抽奖&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &#123;# 详情页，列表页主体内容块 #&#125; &#123;% block main_content %&#125;&#123;% endblock main_content %&#125;&#123;% endblock body %&#125;step3 在templates目录下常见base_no_cart.html文件，这个模板文件继承需base.html，用于购物车页（cart.html），提交订单页（place_order.html）模板的继承&#123;# 购物车 提交订单 #&#125;&#123;% extends 'base.html' %&#125;&#123;% load staticfiles %&#125;&#123;# 网页顶部搜索框块 #&#125;&#123;% block search_bar %&#125; &lt;div class=\"search_bar clearfix\"&gt; &lt;a href=\"index.html\" class=\"logo fl\"&gt;&lt;img src=\"&#123;% static 'images/logo.png' %&#125;\"&gt;&lt;/a&gt; &lt;div class=\"sub_page_name fl\"&gt;|&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#123;% block page_title %&#125;&#123;% endblock page_title %&#125;&lt;/div&gt; &lt;div class=\"search_con fr\"&gt; &lt;input type=\"text\" class=\"input_text fl\" name=\"\" placeholder=\"搜索商品\"&gt; &lt;input type=\"button\" class=\"input_btn fr\" name=\"\" value=\"搜索\"&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endblock search_bar %&#125;step4 在templates目录下常见base_user_center.html文件，这个模板文件继承需base_no_cart.html，用于用户中心三个页面（user_center_info.html）（user_center_order.html）（user_center_site.html）模板的继承&#123;# 用户中心3页面 #&#125;&#123;% extends 'base_no_cart.html' %&#125;&#123;% block title %&#125;天天生鲜-用户中心&#123;% endblock title %&#125;&#123;% block page_title %&#125;用户中心&#123;% endblock page_title %&#125;&#123;% block body %&#125; &lt;div class=\"main_con clearfix\"&gt; &lt;div class=\"left_menu_con clearfix\"&gt; &lt;h3&gt;用户中心&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"user_center_info.html\" class=\"active\"&gt;· 个人信息&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"user_center_order.html\"&gt;· 全部订单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"user_center_site.html\"&gt;· 收货地址&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &#123;# 用户中心右侧内容块 #&#125; &#123;% block right_content %&#125;&#123;% endblock right_content %&#125; &lt;/div&gt;&#123;% endblock body %&#125; 2.注册页登录页主页继承于父模板 step1 编写注册页面（register.html）继承于base.html step2 编写登录页面（login.html）继承于base.html step3 编写主页（index.html）继承于bases.html step4 测试页面显示是否正确 3.用户中心三个页面继承于父模板 step1 编写（user_center_info.html）继承于base_user_center.html step2 编写（user_center_order.html）继承于base_user_center.html step3 编写（user_center_site.html）继承于base_user_center.html 4.购物车页提交订单页继承于父模板 step1 编写购物车页（cart.html）继承于base_no_cart.html step2 编写提交订单页（place_order.html） 继承于base_no_cart.html 5.商品详情页商品列表页继承于父模板 step1 编写详情页（detail.html）继承于base_detail_list.html step2 编写列表页（list.html）继承于base_detail_list.html 二丶用户中心页面显示1.定义类视图 step1 定义UserInfoView类并定义get方法，用于显示用户信息页面 123456# /userclass UserInfoView(View): \"\"\"用户中心-信息\"\"\" def get(self, request): \"\"\"显示页面\"\"\" return render(request, \"user_center_info.html\") step2 定义UserOrderView类并定义get方法，用于显示用户订单页面 12345class UserOrderView(View): \"\"\"用户中心-订单\"\"\" def get(self, request): \"\"\"显示页面\"\"\" return render(request, \"user_center_order.html\") step3 定义UserAddressView类并定义get方法，用于显示用户地址页面 123456# /user/addressclass UserAddressView(View): \"\"\"用户中心-地址\"\"\" def get(self, request): \"\"\"显示页面\"\"\" return render(request, \"user_center_site.html\") 2.在df_user/urls中配置路由 123url(r\"^$\", UserInfoView.as_view(), name=\"user\"), # 用户中心-信息url(r\"^order$\", UserOrderView.as_view(), name=\"order\"), # 用户中心-订单url(r\"^address$\", UserAddressView.as_view(), name=\"address\"), # 用户中心-地址 3.输入路由地址进行页面显示 step1 用户信息页面 step2 用户订单页面 step3 用户地址页面 4.修改用户中心链接地址以及激活active选择器 step1 在用户中心页面点击个人信息，全部订单以及收货地址时，跳转到正确链接地址 step2 在base_user_center.html父模板中使用反向解析定义链接地址 123&lt;li&gt;&lt;a href=\"&#123;% url 'user:user' %&#125;\" class=\"active\"&gt;· 个人信息&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"&#123;% url 'user:order' %&#125;\"&gt;· 全部订单&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"&#123;% url 'user:address' %&#125;\"&gt;· 收货地址&lt;/a&gt;&lt;/li&gt; step3 在用户中心三个类视图中在返回模板文件时，传递三个页面不同的参数，根据参数来判断active激活哪个页面 123return render(request, \"user_center_info.html\", &#123;\"page\":\"user\"&#125;)return render(request, \"user_center_info.html\", &#123;\"page\":\"order\"&#125;)return render(request, \"user_center_info.html\", &#123;\"page\":\"address\"&#125;) step4 紧接着在base_user_center.html父模板对后端返回的数据进行判断处理 12345&lt;ul&gt; &lt;li&gt;&lt;a href=\"&#123;% url 'user:user' %&#125;\" &#123;% if page == 'user' %&#125;class=\"active\"&#123;% endif %&#125;&gt;· 个人信息&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"&#123;% url 'user:order' %&#125;\"&#123;% if page == 'order' %&#125;class=\"active\"&#123;% endif %&#125;&gt;· 全部订单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"&#123;% url 'user:address' %&#125;\"&#123;% if page == 'address' %&#125;class=\"active\"&#123;% endif %&#125;&gt;· 收货地址&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; step5 测试效果 三丶登录验证以及登录后跳转的地址1.登录验证 step1 导入django模块中的login_required方法，验证用户是否是登录状态，也就是获取session的值，如果用户是登录状态，那么则可以访问需要登录成功后所访问的页面，如果用户未登录，直接访问需要登录后才能看到的页面，则login_required方法默认跳转到http://127.0.0.1:8000/accounts/login/?next=/user/页面 1from django.contrib.auth.decorators import login_required step2 在df_user/urls中对用户中心信息页添加login_required登录验证方法 1url(r\"^$\", login_required(UserInfoView.as_view()), name=\"user\"), # 用户中心-信息 step3 未登录状态直接访问http://127.0.0.1:8000/user/（用户中心信息页面）说明：这里之所以换了个浏览器是因为之前的谷歌浏览器有登录成功保存的session，博主不想清除浏览缓存 step4 在官网文档中调用login_required方法，设置验证不成功跳转的地址，则需要在项目settings配置文件中配置LOGIN_URL，设置为登录地址 2.登录成功后跳转的地址 step1 根据login_required方法验证未登录状态跳转的登录地址http://127.0.0.1:8000/user/login?next=/user/，在LoginView类视图post方法中，获取请求地址next参数的值，如果当用户访问的是http://127.0.0.1:8000/user/login登录页面，则next请求地址参数中的next参数无法获取，所以设置默认值为反向解析主页地址 12next_url = request.GET.get(\"next\", reverse(\"goods:index\"))response = redirect(next_url) step2 验证当用户在未登录状态访问需要登录后才能访问的页面，跳转到http://127.0.0.1:8000/user/login?next=/user/，进入登录页面，登录成功后是否跳转到未登录时访问的页面http://127.0.0.1:8000/user/ step3 验证当用户直接访问登录页面是否进入主页http://127.0.0.1:8000 step4 同理将用户中心-订单（http://127.0.0.1:8000/user/order）和用户中心地址（http://127.0.0.1:8000/user/address）加上login_required方法，同样情况在未登录状态跳转的登录地址http://127.0.0.1:8000/user/login?next=/user/order和http://127.0.0.1:8000/user/login?next=/user/address 12url(r\"^order$\", login_required(UserOrderView.as_view()), name=\"order\"), # 用户中心-订单url(r\"^address$\", login_required(UserAddressView.as_view()), name=\"address\"), # 用户中心-地址 四丶封装login_required方法1.定义工具类 step1 在项目目录下创建utils包，在utils包下创建mixin.py文件 step2 在mixin.py文件中创建LoginRequiredMixin类，封装login_required方法 1234567from django.contrib.auth.decorators import login_required # 验证是否登录 class LoginRequiredMixin(object): @classmethod def as_view(cls, **initkwargs): view = super(LoginRequiredMixin, cls).as_view(**initkwargs) return login_required(view) 2.在用户中心类视图中继承LoginRequiredMixin类并在urls中去掉login_required方法 step1 继承LoginRequiredMixin类 step2 去掉login_required方法 123url(r\"^$\", UserInfoView.as_view(), name=\"user\"), # 用户中心-信息url(r\"^order$\", UserOrderView.as_view(), name=\"order\"), # 用户中心-订单url(r\"^address$\", UserAddressView.as_view(), name=\"address\"), # 用户中心-地址 step3 验证成功 五丶登录后显示用户名以及退出登录1.登录后显示用户名不显示登录注册功能选项 step1 Django框架默认会给前端模板文件传递request.user对象，如果用户是登录状态访问页面会返回User类的对象user，如果未登录则返回AnonymousUser实力对象，当给前端模板文件返回的是user对象（已登录）则这个实力对象去调is_authenticated方法则会返回True，（未登录）AnonymousUser实力对象去调用is_authenticated方法则会返回False，在base.html模板文件中根据user对象进行判断，如果没有使用重复模板的继承复用，则需要在有class=‘header_con’模块的模板文件中一一进行判断，在此体现出重复内容模板继承的重要性 1234567891011&#123;% if user.is_authenticated %&#125;&lt;div class=\"login_btn fl\"&gt; 欢迎您：&lt;em style=\"color: #f89752\"&gt;&#123;&#123; user.username &#125;&#125;&lt;/em&gt;&lt;/div&gt;&#123;% else %&#125;&lt;div class=\"login_btn fl\"&gt; &lt;a href=\"/user/login\"&gt;登录&lt;/a&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"/user/register\"&gt;注册&lt;/a&gt;&lt;/div&gt; &#123;% endif %&#125; step2 直接刷新已登录后的主页进行验证 2.退出登录 step1 在base.html模板文件中添加退出按钮 1234&lt;div class=\"login_btn fl\"&gt; &lt;span&gt;|&lt;/span&gt; &lt;a href=\"&#123;% url 'user:logout' %&#125;\"&gt;退出&lt;/a&gt;&lt;/div&gt; step2 在views中定义Logout类视图完成退出功能 1234567# /user/logoutclass LogoutView(View): \"\"\"退出\"\"\" def get(self, request): logout(request) # 退出后跳转到主页 return redirect(reverse(\"goods:index\")) step3 在urls中定义退出路由 1url(r\"^logout$\", LogoutView.as_view(), name=\"logout\"), # 注销 3.验证登录登出功能 六丶用户中心-地址1.在UserAddressView类中定义post方法添加地址 step1 接收用户填写的数据 1234receiver = request.POST.get(\"receiver\") # 收件人addr = request.POST.get(\"addr\") # 地址zip_code = request.POST.get(\"zip_code\") # 邮编phone = request.POST.get(\"phone\") # 手机号 step2 验证数据完整性，邮编可以不填 12if not all([receiver, addr, phone]): return render(request, \"user_center_site.html\", &#123;\"error_msg\":\"数据不完整\"&#125;) step3 验证手机号格式 12if not re.match(r'^1[3|4|5|7|8|9][0-9]&#123;9&#125;$', phone): return render(request, \"user_center_site.html\", &#123;\"error_msg\": \"手机号格式不正确\"&#125;) step4 加收货地址，当用户已存在默认收货地址，添加的地址不作为默认收货地址，否则作为默认收货地址， 因为此界面输入登录后的界面，所以django保存了user对象 1234567891011user = request.usertry: address = Address.objects.get(user=user, is_default=True)except Address.DoesNotExist: # 出现异常表示该用户还没有设置默认地址 address = None if address: is_default = Falseelse: is_default = True step5 保存收货地址，跳转到地址页 12Address.objects.create(user=user, receiver=receiver, addr=addr, zip_code=zip_code, phone=phone, is_default=is_default)return redirect(reverse(\"user:address\")) 2.在UserAddressView类get方法中获取地址类Address对象 step1 通过登录后的user对象在Address类中获取该用户的地址对象，根据该对象中的is_default字段，设置值为True（也就是该用户存在默认地址）进行数据库df_address表查询，如果出现异常表示该用户并没有收货地，则设置address对象为None，最后将address对象返回给前端模板 12345678910def get(self, request): \"\"\"显示页面\"\"\" # 获取用户的的收货地址 user = request.user try: address = Address.objects.get(user=user, is_default=True) except Address.DoesNotExist: # 出现异常表示该用户还没有设置默认地址 address = None return render(request, \"user_center_site.html\", &#123;\"page\":\"address\",\"address\":address&#125;) step2 在用户地址前端模板文件中进行判断，当后端返回的address对象不为空时则从该对象中获取用户填写的收件地址，收件人以及收件人电话，否则返回None 12345678910&lt;div class=\"site_con\"&gt; &lt;dl&gt; &lt;dt&gt;当前地址：&lt;/dt&gt; &#123;% if address %&#125; &lt;dd&gt;&#123;&#123; address.addr &#125;&#125; （&#123;&#123; address.receiver &#125;&#125; 收） &#123;&#123; address.phone &#125;&#125;&lt;/dd&gt; &#123;% else %&#125; &lt;dd style=\"color: red\"&gt;无默认地址&lt;/dd&gt; &#123;% endif %&#125; &lt;/dl&gt;&lt;/div&gt; 3.测试 step1 添加收货地址 step2 查看数据库 4.定义地址模型类管理器 step1 在df_use模块models.py文件中创建AddressManager模型类，在类中定义一个方法用于操作模型类对应的数据表，将视图中的UserAddressView类里获取登录后用户的地址对象代码拷贝到此方法中，进行封装 1234567891011class AddressManager(models.Manager): \"\"\"地址模型类管理器\"\"\" # 用于操作模型类对应的数据表 def get_default_address(self, user): try: address = self.get(user=user, is_default=True) except self.model.DoesNotExist: # 出现异常表示该用户还没有设置默认地址 address = None return address step2 在df_use模块models.py文件中地址类（Address）中创建AddressManager的实例对象objects 1objects = AddressManager() step3 回到UserAddressView类视图中，注释掉try包含的代码，直接通过调用Address.objects.get_default_address方法来获取address对象 1address = Address.objects.get_default_address(user) step4 测试添加地址 说明：收货地址栏可以添加一个复选框，在这个复选框中显示出该用户所有的收货地址，当选择某一个收货地址时，则设置改收货地址的is_default值为1 七丶用户中心-信息1.显示基本信息 step1 在UserInfoView类视图get方法中获取用户基本信息 123456def get(self, request): \"\"\"显示页面\"\"\" # 获取用户地址信息 user = request.user address = Address.objects.get_default_address(user) return render(request, \"user_center_info.html\", &#123;\"page\":\"user\", \"address\":address&#125;) step2 在模板文件user_center_info.html中获取后端返回的用户地址信息对象，根据该对象来对页面信息进行处理 12345678910&lt;ul class=\"user_info_list\"&gt; &lt;li&gt;&lt;span&gt;用户名：&lt;/span&gt;&#123;&#123; user.username &#125;&#125;&lt;/li&gt; &#123;% if address %&#125; &lt;li&gt;&lt;span&gt;联系方式：&lt;/span&gt;&#123;&#123; address.phone &#125;&#125;&lt;/li&gt; &lt;li&gt;&lt;span&gt;联系地址：&lt;/span&gt;&#123;&#123; address.addr &#125;&#125;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;span&gt;联系方式：&lt;/span&gt;无&lt;/li&gt; &lt;li&gt;&lt;span&gt;联系地址：&lt;/span&gt;无&lt;/li&gt; &#123;% endif %&#125;&lt;/ul&gt; step3 刷新http://127.0.0.1:8000/user/页面 2.获取用户历史浏览记录 step1 分析历史浏览记录存储设计 123456781.什么时候添加历史浏览记录 当用户点击进入某个商品详情页时，需要添加历史浏览记录2.什么时候获取历史浏览记录 在用户信息页面显示3.历史浏览记录往哪里存储 存储在内存级的redis数据库中提高读写效率4.以哪种数据格式进行存储 以list数据格式进行存储 step2 通过django_redis包封装好的get_redis_connection方法获取redis中的StrictRedis类的实例对象 ，这个方法接收参数为default与settings配置文件中django缓存数据库设置名default一致 1conn = get_redis_connection(\"default\") step3 设置redis数据库的key 1history_key = \"history_%d\" % user.id step4 获取用户最新浏览的5个商品的id 1sku_ids = conn.lrange(history_key, 0 ,4) step5 遍历查询到的用户sku_ids,根据遍历出的的id查询出对应的商品信息，之所以定义一个空列表是为了让存入列表中的商品信息，是以先进后出的方式进行排列，因为浏览记录第一个即是用户最后一个浏览的商品详情 1234goods_list = []for sku_id in sku_ids: goods = GoodsSKU.objects.get(id=sku_id) goods_list.append(goods) step6 构造返回前端模板响应数据 123456content = &#123;\"page\":\"user\", \"address\":address, \"goods_list\":goods_list &#125; return render(request, \"user_center_info.html\", content ) step7 在user_center_info模板文件中，获取后端返回的数据，并进行判断处理 12345678910111213&#123;% for goods in goods_list %&#125; &lt;li&gt; &lt;a href=\"detail.html\"&gt;&lt;img src=\"&#123;&#123; goods.image.url &#125;&#125;\"&gt;&lt;/a&gt; &lt;h4&gt;&lt;a href=\"detail.html\"&gt;&#123;&#123; goods.name &#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;div class=\"operate\"&gt; &lt;span class=\"prize\"&gt;￥&#123;&#123; goods.price &#125;&#125;&lt;/span&gt; &lt;span class=\"unit\"&gt;&#123;&#123; goods.price &#125;&#125;/&#123;&#123; goods.unite &#125;&#125;&lt;/span&gt; &lt;a href=\"#\" class=\"add_goods\" title=\"加入购物车\"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &#123;% empty %&#125; 无历史浏览记录&#123;% endfor %&#125; step8 直接刷新http://127.0.0.1:8000/user/用户中心信息页，因为商品详情还没有做，所以数据库中并没有存储历史浏览的商品信息，所以显示无历史浏览记 八丶分布式文件系统FastDFS1.FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题 2.该项目之所以使用FastDFS进行图片存储，而不使用django管理员网页进行上传，是因为使用FastDFS对海量存储以及存储扩容方便，同时也解决了同文件重复的问题 3.FastDFS架构图 服务端两个角色： Tracker:管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。 Storage:实际保存文件 Storage 分为多个组，每个组之间保存的文件是不同的。每 个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有 主从的概念。 4.文件上传流程 说明：客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文 件的索引信息。文件索引信息包括:组名，虚拟磁盘路径，数据两级目录，文件名 组名:文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回， 需要客户端自行保存。 虚拟磁盘路径:storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了 store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。 数据两级目录:storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据 文件。 文件名:与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含:源存储 服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息 5.文件下载流程 6.开发环境搭建简易FastDFS架构 7.FastDFS安装 说明：FastDFS需要在Linux系统进行安装，网上查了资料并没有推出可以在Windows环境下安装的FastDFS版本，安装FastDFS之前需安装fastdfs依赖包libfastcommon-master.zip step1 解压缩libfastcommon-master.zip包，进入到libfastcommon-master的目录中，执行 ./make.sh进行编译 step2 执行 sudo ./make.sh install进行安装 step3 解压缩fastdfs-master.zip，进入到 fastdfs-master目录中，执行 ./make.sh进行编译 step4 执行 sudo ./make.sh install进行安装 8.配置跟踪服务器tracker step1 安装完fdfs后在fdfd目录下会产生一个fdfs的配置文件样例 tracker.conf.sample，将该配置文件拷贝并重命名到当前路径下名为tracker.conf 1sudo cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.conf step2 在/home/taogang/目录中创建目录 fastdfs/tracker两个层级目录，记得修改（/home/用户名） step3 编辑/etc/fdfs/tracker.conf配置文件,修改 base_path=/home/taogang/fastdfs/tracker 1sudo vim /etc/fdfs/tracker.conf 9.配置存储服务器storage step1 将fdfs目录下的storage.conf.sample配置文件拷贝并重命名到当前路径下名为tracker.confsudo cp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.conf step2 在/home/taogang/fastdfs/ 目录中创建目录 storage step3 编辑/etc/fdfs/storage.conf配置文件，修改如下配置 123456sudo vim /etc/fdfs/storage.confbase_path=/home/taogang/fastdfs/storage store_path0=/home/taogang/fastdfs/storage tracker_server=你的ubuntu虚拟机的ip地址:22122 10.启动tracker 和 storage 12sudo service fdfs_trackerd startsudo service fdfs_storaged start 11.测试是否安装成功 step1 将fdfs目录下的client.conf.sample配置文件拷贝并重命名到当前路径下名为client.conf 1sudo cp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf step2 编辑/etc/fdfs/client.conf配置文件，修改如下配置 1sudo vim /etc/fdfs/client.conf 12base_path=/home/taogang/fastdfs/trackertracker_server=你的ubuntu虚拟机的ip地址:22122 step3 上传文件测试，使用fdfs_upload_file /etc/fdfs/client.conf 要上传的文件 ，如果返回类似group1/M00/00/00/xxxxxxxxxxxxxxxxxxxx.sql（上传文件的后缀名）的文件id则说明文件上传成功 九丶Nginx配置FastDFS使用的安装和配置1.说明：使用FastDFS分布式系统架构在用户量比较大的时候，用户对内容的获取效率是非常低的，为了提高效率需要借助Nginx服务器来配置FastDFS进行使用，Nginx服务器在处理静态文件的效率是很高的，因为Nginx服务器内核是epoll，上传资源使用fdfs系统，获取资源则借助nginx服务器来获取；需安装nginx-1.8.1.tar.gz和fastdfs-nginx-module-master.zip这两个包，fastdfs-nginx-module-master.zip这个包的作用就是让nginx服务器和fdfs系统进行关联配置的作用 2.安装nginx和fastdfs-nginx-module step1 解压缩 nginx-1.8.1.tar.gz和fastdfs-nginx-module-master.zip这两个包，进入nginx-1.8.1目录中，执行sudo ./configure –prefix=/usr/local/nginx/ –add-module=（fastdfs-nginx-module-master）解压后的目录的绝对路径/src 结果报错了，看提示是缺少PCRE库 step2 安装pcre，依次执行下面三条命令 123sudo apt-get updatesudo apt-get install libpcre3 libpcre3-devsudo apt-get install openssl libssl-dev step3 安装pcre成功后再次执行configure命令，生成Makefile成功 step4 编译 step5 安装 step6 安装成功后测试nginx是否安装成功，执行./nginx -t ，结果报错了，根据报错提示，当前用户对该nginx文件下的文件没有读写操作，执行su root切换到root权限，再次执行提示成功 step7 拷贝fastdfs-nginx-module-master解压后的目录中src下的mod_fastdfs.conf 到 /etc/fdfs/mod_fastdfs.conf命名为mod_fastdfs.conf step8 编辑/etc/fdfs/mod_fastdfs.conf配置文件，进行以下修改 1sudo vim /etc/fdfs/mod_fastdfs.conf 1234connect_timeout=10 # 连接fdfs超时时间tracker_server=自己ubuntu虚拟机的ip地址:22122url_have_group_name=true # 访问fdfs时带不带组的信息（group1）store_path0=/home/python/fastdfs/storage step9 拷贝解压缩的fastdfs-master目录下conf目录中http.conf和mime.types配置文件到 /etc/fdfs目录下 step10 编辑/usr/local/nginx/conf/目录下的nginx.conf配置文件，进行如下编写 1sudo vim /usr/local/nginx/conf/nginx.conf step11 开启nginx服务 3.测试Nginx服务器配合FastDFS系统进行文件上传与获取 step1 开启fdfs服务，上传桌面上的goods_detail.jpg图片，返回文件id，这个id需记住，为了下一步的测试 step2 打开浏览器输入127.0.0.1:8888(nginx配置的端口)/(上传成功返回的文件id)，成功显示出上传的图片 十丶Python与FastDFS进行交互 step1 进入博主自己项目的虚拟环境（django_py2），使用pip安装fdfs_client-py包 step2 查看虚拟环境中是否存在fdfs_client-py模块 step3 上传测试（上传成功） step4 最后话不多说，在浏览器中通过nginx服务器8888端口来访问上传的的test.py文件，输入上传文件成功返回的文件id，127.0.0.1:8888/group1/M00/00/00/wKgBClyfYxSAGPA_AAAAFZ3HQjA1801.py，因为上传的文件为py脚本文件，所以提示下载窗口，即 step5 归纳：python作为客户端与fdfs系统进行交互并上传文件成功，安装nginx服务器配合fdfs系统使用成功，最后通过访问配置nginx服务group[0-9]以及8888端口在浏览器中访问python客户端上产到fdfs系统上的文件，非常成功 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/88842059","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目之Web端电商网站的实战开发（二）","slug":"Django项目之Web端电商网站的实战开发（二）","date":"2019-11-06T07:03:32.818Z","updated":"2019-11-13T14:07:43.730Z","comments":true,"path":"2019/11/06/Django项目之Web端电商网站的实战开发（二）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/06/Django项目之Web端电商网站的实战开发（二）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶用户注册 二丶用户登录","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶用户注册 二丶用户登录 一丶用户注册1.显示用户注册页面 step1 在static目录下将register.html文件拷贝到templates模板目录下 step2 在df_user模块下的views视图中定义一个register函数，定义这个函数的路由正则匹配为/user/register，显示用户注册页面 1234# /user/registerdef register(request): \"\"\"显示注册页面\"\"\" return render(request, \"register.html\") step3 在df_user模块下的urls地址中配置注册页面正则规则，以及调用视图函数中的register函数 123urlpatterns = [ url(r\"^register$\", views.register, name=\"register\") # 注册页] step4 运行项目，在浏览器中输入http://127.0.0.1:8000/user/register后，将注册页面渲染到浏览器上 step5 出现上面这种情况是，页面所需要的图片和css以及js文件路径错误404，因为此时的register.html文件放在了templates模板目录下，所以需要在register.html中动态获取路径，需导入静态资源，然后修改每个链接，因为之前在settings配置文件中配置了静态文件URL为/static/所以这里只需要写之后的路径即可 123456&#123;% load staticfiles %&#125;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt;天天生鲜-注册&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"&#123;% static 'css/reset.css' %&#125;\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"&#123;% static 'css/main.css' %&#125;\"&gt; step6 刷新页面，成功显示出页面内容 2.定义注册页面表单数据视图函数 step1 首先注册页面数据是以POST请求方式向服务器发送，那么在register.html文件中找到form表单标签，编写用户点击注册按钮后向服务器请求的url地址 1&lt;form method=\"post\" action=\"/user/register_handle\"&gt; step2 在django中发送POST请求表单数据，防止跨站攻击需在form标签下加上{% csrf_token %} 12&lt;form method=\"post\" action=\"/user/register_handle\"&gt; &#123;% csrf_token %&#125; step3 在df_user/views视图函数中定义register_handle方法，用于处理注册页面数据 1234# /user/register/handledef register_handle(request): \"\"\"处理用户注册数据\"\"\" pass step4 在在df_user/urls路由地址中定义register_handle视图函数正则匹配规则 1url(r\"^register_handle$\", views.register_handle, name=\"register_handle\") # 注册数据处理 3.视图函数register_handle代码逻辑实现 step1 接收注册表单数据 1234username = request.POST.get(\"user_name\")password = request.POST.get(\"pwd\")email = request.POST.get(\"email\")allow = request.POST.get(\"allow\") step2 判断用户传递过来的数据是否存在，不存在返回错误信息提示 12if not all([username, password, email]): return render(request, \"register.html\", &#123;\"error_msg\":\"数据不完整\"&#125;) step3 判断用户填写的邮箱是否为正确邮箱 12if not re.match(r\"^[a-z0-9][\\w.\\-]*@[a-z0-9\\-]+(\\.[a-z]&#123;2,5&#125;)&#123;1,2&#125;$\", email): return render(request, \"register.html\", &#123;\"error_msg\":\"邮箱格式不正确\"&#125;) step4 判断用户注册时是否勾选同意，同意后该字段POST请求参数为on 12if allow != \"on\": return render(request, \"register.html\", &#123;\"error_msg\":\"请勾选同意\"&#125;) step5 进行用户注册，将数据保存在数据库用户名中, 因为在执行迁移文件时，在settings中配置了django认证系统指定的模型类为df_user.User 所以可以不使用传统方式向类中添加属性再保存到数据库，而是直接使用django认证系统封装好的create_user函数将数据直接保存到数据库 1user = User.objects.create_user(username, email, password) step6 注册成功后，使用反向解析跳转到首页 reverse(根基urls中的主页的namespace:goods模块中的urls主页的name) 1return redirect(reverse(\"goods:index\")) step7 为了显示主页，将static目录下的index.html文件拷贝到templates目录下，并加载静态资源文件{% load staticfiles %}修改index.html中的静态文件路径，这个页面的地址比较多，体力活 step8 在df_goods/views中定义index视图函数 1234# http://127.0.0.1:8000def index(request): \"\"\"显示首页\"\"\" return render(request, \"index.html\") step9 紧接着在df_goods/urls进行正则路由配置 123urlpatterns = [ url(r\"^$\", views.index, name=\"index\"), # 首页] step10 查看数据库中的用户信息表 step11 运行项目，在浏览器中输入http://127.0.0.1:8000/user/register，进行注册页，填写注册信息，点击注册按钮 说明：前端注册页面使用js对密码长度和两次密码是否一致以及邮箱地址是否同意都进行了校验 step12 当点击注册按钮时，此时在会跳转到form表单中的action地址（/user/register_handle），匹配df_user/urls中的正则然后调用df_user/views中的register_handle视图函数，处理完数据后最终重定向到主页（index.html） step13 查看数据库df_user表数据，因为使用了django认证系统也就通俗点说在df_user/models中的User类继承了AbstractUser类，所以django的认证系统已经将用户注册时填写的密码进行加密处理后存到数据库，这样我们就不用在视图函数中获取密码并加密然后再保存到数据库表中 step14 django认证系统默认用户表字段is_active为1（激活），所以这里需要进行设置为0（未激活） 12user.is_active = 0user.save() step15 再此回到注册页面，进行另一个用户注册，验证上一步is_active默认是否为未激活状态 step16 使用已经注册过的账号进行注册，查看django认证系统错误提示 step17 提示信息为用户名已存在，但这样的显示页面不是我们想要的 step18 在进行用户注册之前，需要判断用户注册的用户名是否存在 123456789try: user = User.objects.get(username=username)except User.DoesNotExist: \"\"\"如果出现该异常说明用户名不存在，则让user对象为空\"\"\" user = None # 如果user对象存在，则表示用户名已存在，返回错误提示信息if user: return render(request, \"register.html\", &#123;\"error_msg\":\"用户名已存在\"&#125;) 4.测试数据不合法的情况下，提示错误信息 step1 在register.html中form标签下添加error_msg变量 1&lt;span style=\"color: red\"&gt;&#123;&#123; error_msg &#125;&#125;&lt;/span&gt; step2 注册已存在的用户名cdtaogang，查看错误提示 step3 填写错误邮箱地址，然后点击注册 step4 不填写任何数据直接进行注册 5.注册优化处理，让显示注册页面和注册数据处理为同一个url地址（/user/register） ，因为显示注册页面为get请求，而注册数据处理为post请求，可以根据请求方式不同来使用同一个url地址 step1 在register.html中将form表单action地址修改为/user/register与显示页面地址一致 1&lt;form method=\"post\" action=\"/user/register\"&gt; step2 在df_user/views中的register视图函数中进行请求方式判断 12345678910# Create your views here.# /user/registerdef register(request): \"\"\"注册\"\"\" # 当请求方式为get时表示请求注册页面，反之为处理用户注册数据 if request.method == \"GET\": \"\"\"显示注册页面\"\"\" return render(request, \"register.html\") else: \"\"\"处理用户注册数据\"\"\" step3 注册一个新用户 step4 查看数据库用户表 6.使用类视图来区分用户请求 step1 在df_user/views视图中定义RegisterView视图类，在这个类中定义注册所需的get方法以及post方法，这个方法名必须等同于请求方式名 123456789101112from django.views.generic import View # /user/registerclass RegisterView(View): \"\"\"注册\"\"\" def get(self, request): \"\"\"显示注册页面\"\"\" return render(request, \"register.html\") def post(self, request): \"\"\"处理用户注册数据\"\"\" step2 在df_user/urls中需导入RegisterView类，并调用这个类所属父类View中的as_view方法来根据请求方式调用对应的方法完成代码逻辑 1234urlpatterns = [ url(r\"^register$\", RegisterView.as_view(), name=\"register\"), # 注册] step3 刷新注册页，进行新用户注册 7.生成用户激活邮件中的token，当在不错的网站进行用户注册成功后，会想用户注册填写的邮箱地址发送账户激活的邮件，在这个邮件内容中会有一个激活的链接地址，并且会提示用户请在2小时内进行激活，2小时后失效；定义激活链接为http://127.0.0.1:8000/user/active/用户id，如果在链接地址明文显示用户的id值的话，就会出现某些懂技术的用户，修改链接地址中的用户id，就很有可能去激活其他用户，所以需要将链接地址中的用户id值进行加密并设置密钥的有效期 step1 安装itsdangerous模块，使用改模块生成我们所需的token 1pip install itsdangerous step2 导致该模块中的TimedJSONWebSignatureSerializer类 1from itsdangerous import TimedJSONWebSignatureSerializer as Serializer step3 加密用户id，生成激活的token 123serializer = Serializer(settings.SECRET_KEY, 3600) # 有效期1小时info = &#123;\"confirm\":user.id&#125;token = serializer.dumps(info) 8.使用django内置函数发送邮件（这个QQ邮箱为博主小小小小号） step1 这里有QQ邮箱为例，进入QQ邮箱设置，开启POP3/SMTP服务 step2 使用提示的密保手机向指定的号码发送指定内容来完成验证 step3 发送成功后，显示出授权码，记住此授权码后，点击保存设置 step4 在settings配置文件中进行发送邮件配置 12345678910# 发送邮件配置EMAIL_BACKEND = &apos;django.core.mail.backends.smtp.EmailBackend&apos;EMAIL_HOST = &apos;smtp.qq.com&apos;EMAIL_PORT = 25#发送邮件的邮箱EMAIL_HOST_USER = &apos;2384005622@qq.com&apos;#在邮箱中设置的客户端授权密码EMAIL_HOST_PASSWORD = &apos;授权码&apos;#收件人看到的发件人EMAIL_FROM = &apos;天天生鲜&lt;2384005622@qq.com&gt;&apos; step5 在df_user/view视图中导入django内置函数中的send_mail方法 1from django.core.mail import send_mail step6 在RegisterView类中调用send_mail方法发送邮件 12345subject = \"天天生鲜欢迎你\" # 邮件标题message = \"how are you\" # 邮件正文sender = settings.EMAIL_FROM # 发件人receiver = [email] # 收件人send_mail(subject, message, sender, receiver) step7 注册一个新用户 step8 登录注册时的邮箱，查看收件箱 step9 向邮箱发送账户激活链接地址，htmp_message参数为渲染html标签后再进行内容发送 12345678subject = \"天天生鲜欢迎你\" # 邮件标题message = '' # 邮件正文sender = settings.EMAIL_FROM # 发件人receiver = [email] # 收件人html_message = \"\"\" &lt;h1&gt;%s 恭喜您成为天天生鲜注册会员&lt;/h1&gt;&lt;br/&gt;&lt;h3&gt;请您在1小时内点击以下链接进行账户激活&lt;/h3&gt;&lt;a href=\"http://127.0.0.1:8000/user/active/%s\"&gt;http://127.0.0.1:8000/user/active/%s&lt;/a&gt;\"\"\" % (username, token, token)send_mail(subject, message, sender, receiver, html_message=html_message) step10 注册一个新用户 step11 查看邮件 step12 点击邮件中的链接地址 9.用户注册激活 step1 在df_user/views视图中定义ActiveView类，在这个类中定义get方法，用于处理用户激活 123456# /user/active/......class ActiveView(View): \"\"\"账户激活\"\"\" def get(self, request, token): \"\"\"进行用户激活\"\"\" pass step2 获取加密的serializer对象 1serializer = Serializer(settings.SECRET_KEY, 3600) step3 解密token，获取要激活的用户信息，首先需要导入itsdangerous包中的SignatureExpired类来处理超时异常，所以接下里的代码需要写到try里面 1234567891011121314try: info = serializer.loads(token) # 获取用户id user_id = info['confirm'] # 根据用户id 获取该用户对象 user = User.objects.get(id=user_id) # 设置该用户对象中的is_active字段的值为1 user.is_active = 1 user.save() # 使用反向解析跳转到登录页 return redirect(reverse(\"user:login\"))except SignatureExpired as e: # 出现异常表示链接失效 return HttpResponse(\"激活链接已过期\") step4 创建LoginView类并在这个类中定义get方法用于显示登录页 123456# /user/loginclass LoginView(View): \"\"\"登录\"\"\" def get(self, request): \"\"\"显示登录页\"\"\" return render(request, \"login.html\") step5 在df_user/urls中定义以上两个类视图对应的正则以及对应的方法调用，将static目录下的login.html文件拷贝到templates目录下 12url(r\"^active/(?P&lt;token&gt;.*)$\", ActiveView.as_view(), name=\"active\"), # 账户激活url(r\"^login$\", LoginView.as_view(), name=\"login\"), # 登录 step6 注册一个新用户，查看数据库中is_active的值 step7 查看邮箱邮件信息 step8 在邮箱中点击链接地址进行激活操作，成功跳转到登录页 step9 查看数据库，该用户is_active字段的是为1表示已激活 10.使用celery异步发送邮件 step1 在项目目录下创建celery_tasks包，在该包下创建tasks.py文件 step2 在tasks.py文件中创建Celery实例对象 1app = Celery(\"celery_tasks.tasks\", broker=\"redis://127.0.0.1:6379/4\") step3 定义任务函数send_active_email，说明之所以睡眠5秒是为了体现celery异步的强大 12345678910111213@app.taskdef send_active_email(to_email, username, token): \"\"\"发送用户激活邮件\"\"\" subject = \"天天生鲜欢迎你\" # 邮件标题 message = '' # 邮件正文 sender = settings.EMAIL_FROM # 发件人 receiver = [to_email] # 收件人 html_message = \"\"\" &lt;h1&gt;%s 恭喜您成为天天生鲜注册会员&lt;/h1&gt;&lt;br/&gt;&lt;h3&gt;请您在1小时内点击以下链接进行账户激活&lt;/h3&gt;&lt;a href=\"http://127.0.0.1:8000/user/active/%s\"&gt;http://127.0.0.1:8000/user/active/%s&lt;/a&gt; \"\"\" % (username, token, token) send_mail(subject, message, sender, receiver, html_message=html_message) # 为了体现出celery异步完成发送邮件，这里睡眠5秒 time.sleep(5) step4 另打开一个Terminal终端，执行celery -A celery_tasks.tasks worker -l info 运行任务处理者，需要在broker所在的服务器中执行，需要注意的是windows不支持celery4.0以上的版本 step5 注册一个新用户，注册成功跳转到首页后，查看celery处理者运行日志，发现报错了，导致用户注册成功，但邮件并未发送成功原因是在tasks.py文件中导入了项目配置文件settings，而未在执行任务进行初始化，并且在windows环境中要成功使用celery，celery版本必须在4.0以下，任务队列（中间人）redis数据库版本必须在3.0以下，博主经验 step6 在tasks.py文件中添加如下代码，作用于worker工作室初始化django配置，因为博主这里使用celery是将任务发布者和中间人（broker）以及任务处理者（worker）在一台主机上运行，所以将下面的初始化配置写在这里，该初始化配置是跟随worker走的 1234import osimport djangoos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"dailyfresh.settings\")django.setup() step7 在新终端中执行celery -A celery_tasks.tasks worker -l info，然后进行新用户注册 step8 查看celery运行日志，显示成功，时间为6秒，之所以这么长时间是因为在send_active_email函数中睡眠5秒，由此可见尽管睡眠五秒，但用户在注册的时候根本感觉不到，注册成功瞬间跳转到主页，说明使用celery进行异步发送邮件的重要性 step9 查看用户表 step10 查看redis数据库 二丶用户登录1.显示登录页面 step1 在用户注册时已经定义了LoginView类视图中的get方法，显示登录页，所以直接在login.html文件中定义form表单请求方式以及请求地址，注：action不写默认表示与登录地址一致，跟用户注册一样，使用同一地址显示并处理登录 12&lt;form method=\"post\"&gt;&#123;% csrf_token %&#125; step2 在浏览器中输入http://127.0.0.1:8000/user/login，显示出登录页 2.处理登录数据校验 step1 在类视图LoginView中定义post函数 123def post(self, request): \"\"\"登录校验\"\"\" pass step2 接收用户填写的数据 12username = request.POST.get(\"username\")password = request.POST.get(\"pwd\") step3 校验参数完整性 12if not all([username, password]): return render(request, \"login.html\", &#123;\"error_msg\":\"数据不完整\"&#125;) step4 校验用户名密码，当用户名密码正确情况下保存登录状态到session中，使用django认证系统中的 12345678910111213141516authenticate和login方法user = authenticate(username=username, password=password) # 正确返回user对象，不正确返回Noneif user is not None: # 用户名密码正确 if user.is_active: # 用户已激活 # 将用户登录成功后状态保存在session，使用django认证系统中的login方法 login(request, user) # 重定向到主页 return redirect(reverse(\"goods:index\")) else: # 用户未激活 return render(request, \"login.html\", &#123;\"error_msg\":\"账户未激活\"&#125;)else: # 用户名或密码错误 return render(request, \"login.html\", &#123;\"error_msg\":\"用户名或密码错误\"&#125;) 3.进行登录测试 ，查看网页走下方红色字样提示 step1 登录已激活的账户 step2 登录不存在的账号 step3 登录未激活的账号，这里有一个bug那就是在进行未激活账号登录时一直提示用户名和密码错误，在post方法中通过打印username和password的值查看输入的用户名和密码没错与当初注册时填写的用户名密码对的上，查看django认证系统文档，方法时候啥的都没问题，但是在校验用户名密码时调用的authenticate方法一直返回的是None，这就很奇怪了，通过网上查资料发现需要在settings配置文件中添加如下配置，让django认证系统中的create_user方法再保存用户注册数据时，不关联用户表中的is_active字段，这样再进行登录验证时调用authenticate方法返回错误的None对象 1AUTHENTICATION_BACKENDS = [&apos;django.contrib.auth.backends.AllowAllUsersModelBackend&apos;] step4 不填写数据直接登录 4.配置django缓存以及session数据存储后端到redis数据库，django默认将session数据存储到mysql数据库（settings配置的数据库）中的django_session表中 step1 安装django-redis包 1pip2 install django-redis step2 在settings中添加django缓存配置以及设置django-redis作为session存储后端 1234567891011121314# django缓存配置CACHES = &#123; &quot;default&quot;: &#123; &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/5&quot;, &quot;OPTIONS&quot;: &#123; &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, &#125; &#125;&#125; # 使用django-redis 作为 session 储存后端SESSION_ENGINE = &quot;django.contrib.sessions.backends.cache&quot;SESSION_CACHE_ALIAS = &quot;default&quot; step3 查看reids中5库中的键 step4 进行用户登录，服务器返回响应的sessionid step5 查看redis数据库 5.用户勾选记住用户名 step1 在保存用户登录状态代码中进行如下代码逻辑判断，当用户勾选记住用户名时，remember的值为on，并将用户名保存到cookie中 123456789101112# 因为redirect方法返回的是HttpResponseRedirect对象，而这个对象是HttpResponse的子类，所以可以设置cookieresponse = redirect(reverse(\"goods:index\"))# 判断用户是否记勾选记住用户名remember = request.POST.get(\"remember\")if remember == \"on\": # 表示勾选了,将用户名保存在cookie中 response.set_cookie(\"username\", username, max_age=7*24*3600)else: # 删除cookie response.delete_cookie(\"username\")# 重定向到主页return response step2 在显示登录页面get函数中判断用户是否记住用户名，记住用户名则获取cookie中的username并且设置勾选框为checked勾选状态，并返回给前端模板中 123456789# 判断是否勾选记住用户名if 'username' in request.COOKIES: username = request.COOKIES.get(\"username\") checked = \"checked\"else: username='' checked = '' return render(request, \"login.html\", &#123;\"username\":username, \"checked\":checked&#125;) step3 在login.html中设置用户名username标签的value值，以及remember的值 12&lt;input type=\"text\" name=\"username\" class=\"name_input\" value=\"&#123;&#123; username &#125;&#125;\" placeholder=\"请输入用户名\" autocomplete=\"off\"&gt;&lt;input type=\"checkbox\" name=\"remember\" &#123;&#123; checked &#125;&#125;&gt; step4 测试登录时记住用户名 step5 勾选记住用户名后，查看网站cookie看到刚设置的名为username的cookie了 step6 测试登录时不记住用户名 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/88810060","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Django项目之Web端电商网站的实战开发（一）","slug":"Django项目之Web端电商网站的实战开发（一）","date":"2019-11-06T06:03:21.407Z","updated":"2019-11-16T03:32:59.858Z","comments":true,"path":"2019/11/06/Django项目之Web端电商网站的实战开发（一）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/06/Django项目之Web端电商网站的实战开发（一）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶项目介绍 二丶电商项目开发流程 三丶项目需求 四丶项目架构概览 五丶项目数据库设计 六丶项目框架搭建","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶项目介绍 二丶电商项目开发流程 三丶项目需求 四丶项目架构概览 五丶项目数据库设计 六丶项目框架搭建 一丶项目介绍 产品：关于Web端的电商网站 商业模式：B2C模式 企业对个人 设计模式：使用前后端不分离进行项目开发(后端控制前端的效果展示) 前端效果展示 二丶电商项目开发流程1.流程图 2.1 前奏 项目立项：公司BOSS决定做项目 需求分析：分析客户的需求 原型设计：产品经理画出产品原型图 2.2 前端 UI设计：使用PS等工具对产品进行界面设计 前端设计：根据UI人员设计的图片，写成对应的前端页面 2.3 后端 架构设计：①模块划分，功能架构 ② 开发环境选择 ③其他技术 ④部署架构 数据库设计：①分析数据表和表字段 ②表关系 模块代码实现和单元测试：①后端开发人员进行分工开发 ②开发完成后给测试人员进行单元测试 2.4 尾声 代码整合：将后端代码与前端代码进行耦合合并 集成测试：将整合后的代码再次进行测试 网站发布：在生产环境进行上线 三丶项目需求用户模块 注册页 1.1 注册时校验用户名是否已被注册 1.2 完成用户信息的注册 1.3 给用户的注册邮箱发送邮件，用户点击邮件中的激活链接完成用户账户的激活 1.4 城区的区域信息需动态加载 登录页 2.1 实现用户的登录功能 用户中心 3.1 用户中心信息页：显示登录用户的信息，包括用户名、电话和地址，同时页面下方显示出用户最近浏览的商品信息 3.2 用户中心地址页：显示登录用户的默认收件地址，页面下方的表单可以新增用户的收货地址 3.3 用户中心订单页：显示登录用户的订单信息 3.4 用户可以选择城区、入住时间、离开时间等条件进行搜索 其他 4.1 如果用户已经登录，页面顶部显示登录用户的信息 商品相关 首页 1.1 动态指定首页轮播商品信息 1.2 动态指定首页活动信息 1.3 动态获取商品的种类信息并显示 1.4 动态指定首页显示的每个种类的商品(包括图片商品和文字商品) 1.5 点击某一个商品时跳转到商品的详情页面 商品详情页 2.1 显示出某个商品的详情信息 2.2 页面的左下方显示出该种类商品的2个新品信息 商品列表页 3.1 显示出某一个种类商品的列表数据，分页显示并支持按照默认、价格、和人气进行排序 3.2 页面的左下方显示出该种类商品的2个新品信息 其他 4.1 通过页面搜索框搜索商品信息 购物车相关 1 列表页和详情页将商品添加到购物车 2 用户登录后，首页，详情页，列表页显示登录用户购物车中商品的数目 3 购物车页面：对用户购物车中商品的操作。如选择某件商品，增加或减少购物车中商品的数目 订单相关 1 提交订单页面：显示用户准备购买的商品信息 2 点击提交订单完成订单的创建 3 用户中心订单页显示用户的订单信息 4 点击支付完成订单的支付 四丶项目架构概览1.页面图 2.功能图 3.部署图 五丶项目数据库设计1.分析网站页面所需的参数 注册页（register.html） ①用户名 ②密码 ③邮箱 登录页（login.html） ①用户名 ②密码 用户中心页（user_center_site.html） ①收件人 ②详细地址 ③邮编 ④联系方式 商品详情页（detail.html） ①商品名称 ②简介 ③价格 ④单位 ⑤商品库存 ⑥商品详情 ⑦商品图片 ⑧商品种类编号 主页（index.html） ①商品种类名称 ②logo ③图片 商品列表页（list.html） ①商品名称 ②商品价格 ③商品图片 ④商品分类 购物车页（cart.html） ①商品图片 ②商品名称 ③商品SKU（库存量单位） 提交订单页（place_order.html） ①地址 ②支付方式 ③商品信息 ④总金额 ⑤运费 ⑥商品信息 用户订单页（user_center_order.html） ①订单编号 ②支付状态 ③订单创建时间 2.将参数拆分到其所对应的表中 用户表（df_user） ①主键ID ②用户名 ③密码 ④邮箱 ⑤激活标识（是否激活邮箱） ⑥权限标识（普通用户和管理员） 地址表（df_address） ①主键ID ②收件人 ③收件地址 ④邮编 ⑤联系方式 ⑥是否默认（默认收货地址） ⑦用户ID （外键） 商品SKU表（df_goods_sku） ①主键ID ②商品名称 ③简介 ④价格 ⑤单位 ⑥库存 ⑦销量 ⑧图片（这个图片字段只存一张商品封面图） ⑨状态 ⑩商品种类ID（外键） ⑪spu ID（外键） 商品种类表（df_goods_type） ①主键ID ②种类名称 ③logo ④图片 主页幻灯片商品表（df_index_banner） ①主键ID ②sku ID （外键） ③图片 ④index （图片索引值） 主页促销活动表（df_index_promotion） ①主键ID ②图片 ③活动url地址 ④index（图片索引值） 商品SPU表（df_goods） ①主键ID ②名称 ③商品详情 主页分类商品展示表（df_index_type_goods） ①主键ID ②sku ID （外键） ③种类ID ④展示标识 ⑤index（图片索引值） 商品图片表（df_goods_image） ①主键ID ②图片 ③sku ID 订单商品表（df_order_goods） ①主键ID ②订单ID （外键） ③sku ID （外键） ④商品数量 ⑤商品价格 ⑥评论 订单信息表（df_order_info） ①主键ID ②订单ID （外键） ③用户ID （外键） ④支付方式 ⑤总数量 ⑥总金额 ⑦运费 ⑧支付状态 ⑨创建时间 六丶项目框架搭建说明：博主这里使用开发环境为Windows7+PyCharm 1.在PyCharm中创建dailyfresh项目，然后再到终端中创建项目应用模块，如下图所示 2.在实际项目开发中应用比较多时，会在项目下创建一个名为apps的包，并将应用目录放在该apps下 3.在配置文件settings中注册应用 step1 项目配置文件settings中导入sys模块，添加apps包到系统路径中，这样做的目的是在添加应用时不用写apps.应用名 1sys.path.insert(0, os.path.join(BASE_DIR, \"apps\")) step2 注册刚创建出来的应用 123456789101112INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;df_cart&apos;, &apos;df_goods&apos;, &apos;df_order&apos;, &apos;df_user&apos;] 4.在配置文件settings中配置mysql数据库 step1 在mysql中创建dailyfresh数据库 1create database dailyfresh charset=utf8; step2 配置数据库 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dailyfresh', 'USER': 'root', 'PASSWORD': 'mysql', 'HOST': 'localhost', 'PORT': '3306', &#125;&#125; step3 顺便设置语言和时区 123LANGUAGE_CODE = &apos;zh-hans&apos; TIME_ZONE = &apos;Asia/Shanghai&apos; 5.在配置文件settings中配置静态文件目录 step1 在项目目录下创建static目录，用于存放前端静态文件 step2 在settings配置文件末端将static目录路径添加到系统路径中 1STATICFILES_DIRS = [os.path.join(BASE_DIR, &quot;static&quot;)] step3 将前端资源放到static目录下 6.在根基urls.py文件设置正则匹配将应用模块中的urls包含进来 step1 在根基urls.py文件中进行如下编写，namespace表示反向解析 1234567urlpatterns = [ url(r'^admin/', include(admin.site.urls)), url(r'^user/', include('df_user.urls', namespace='user')), # 用户模块 url(r'^cart/', include('df_cart.urls', namespace='cart')), # 购物车模块 url(r'^order/', include('df_order.urls', namespace='order')), # 订单模块 url(r'^', include('df_goods.urls', namespace='goods')), # 商品模块] step2 在每个应用模块中创建urls.py文件，内容如下 12345678# coding:utf-8 from django.conf.urls import url urlpatterns = [ ] 7.在项目目录下创建一个名为db的python包，在这个包下创建一个base_model.py文件，用作于基类完成数据库表共有字段 step1 创建base_model.py文件 step2 在base_model.py中进行如下编写 12345678910111213# coding:utf-8from django.db import models class BaseModel(models.Model): \"\"\"抽象模型基类\"\"\" create_time = models.DateTimeField(auto_now_add=True, verbose_name=\"创建时间\") update_time = models.DateTimeField(auto_now=True, verbose_name=\"更新时间\") isDelete = models.BooleanField(default=False, verbose_name=\"删除标记\") class Meta: # 表示为抽象模型类 abstract = True 8.在df_user模块中的models.py中定义两个模型类分别是用户模型类和地址模型类 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-from django.db import modelsfrom django.contrib.auth.models import AbstractUserfrom db.base_model import BaseModel# Create your models here. class User(AbstractUser, BaseModel): '''用户模型类''' class Meta: db_table = 'df_user' verbose_name = '用户' verbose_name_plural = verbose_name class Address(BaseModel): '''地址模型类''' user = models.ForeignKey('User', verbose_name='所属账户') receiver = models.CharField(max_length=20, verbose_name='收件人') addr = models.CharField(max_length=256, verbose_name='收件地址') zip_code = models.CharField(max_length=6, null=True, verbose_name='邮政编码') phone = models.CharField(max_length=11, verbose_name='联系电话') is_default = models.BooleanField(default=False, verbose_name='是否默认') class Meta: db_table = 'df_address' verbose_name = '地址' verbose_name_plural = verbose_name 9.在df_goods模块中的models.py中定义模型类 step1 在models.py中进行如下编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# -*- coding: utf-8 -*-from django.db import modelsfrom db.base_model import BaseModelfrom tinymce.models import HTMLField# Create your models here. class GoodsType(BaseModel): '''商品类型模型类''' name = models.CharField(max_length=20, verbose_name='种类名称') logo = models.CharField(max_length=20, verbose_name='标识') image = models.ImageField(upload_to='type', verbose_name='商品类型图片') class Meta: db_table = 'df_goods_type' verbose_name = '商品种类' verbose_name_plural = verbose_name def __str__(self): return self.name class GoodsSKU(BaseModel): '''商品SKU模型类''' status_choices = ( (0, '下线'), (1, '上线'), ) type = models.ForeignKey('GoodsType', verbose_name='商品种类') goods = models.ForeignKey('Goods', verbose_name='商品SPU') name = models.CharField(max_length=20, verbose_name='商品名称') desc = models.CharField(max_length=256, verbose_name='商品简介') price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name='商品价格') unite = models.CharField(max_length=20, verbose_name='商品单位') image = models.ImageField(upload_to='goods', verbose_name='商品图片') stock = models.IntegerField(default=1, verbose_name='商品库存') sales = models.IntegerField(default=0, verbose_name='商品销量') status = models.SmallIntegerField(default=1, choices=status_choices, verbose_name='商品状态') class Meta: db_table = 'df_goods_sku' verbose_name = '商品' verbose_name_plural = verbose_name class Goods(BaseModel): '''商品SPU模型类''' name = models.CharField(max_length=20, verbose_name='商品SPU名称') # 富文本类型:带有格式的文本 detail = HTMLField(blank=True, verbose_name='商品详情') class Meta: db_table = 'df_goods' verbose_name = '商品SPU' verbose_name_plural = verbose_name class GoodsImage(BaseModel): '''商品图片模型类''' sku = models.ForeignKey('GoodsSKU', verbose_name='商品') image = models.ImageField(upload_to='goods', verbose_name='图片路径') class Meta: db_table = 'df_goods_image' verbose_name = '商品图片' verbose_name_plural = verbose_name class IndexGoodsBanner(BaseModel): '''首页轮播商品展示模型类''' sku = models.ForeignKey('GoodsSKU', verbose_name='商品') image = models.ImageField(upload_to='banner', verbose_name='图片') index = models.SmallIntegerField(default=0, verbose_name='展示顺序') class Meta: db_table = 'df_index_banner' verbose_name = '首页轮播商品' verbose_name_plural = verbose_name class IndexTypeGoodsBanner(BaseModel): '''首页分类商品展示模型类''' DISPLAY_TYPE_CHOICES = ( (0, \"标题\"), (1, \"图片\") ) type = models.ForeignKey('GoodsType', verbose_name='商品类型') sku = models.ForeignKey('GoodsSKU', verbose_name='商品SKU') display_type = models.SmallIntegerField(default=1, choices=DISPLAY_TYPE_CHOICES, verbose_name='展示类型') index = models.SmallIntegerField(default=0, verbose_name='展示顺序') class Meta: db_table = 'df_index_type_goods' verbose_name = \"主页分类展示商品\" verbose_name_plural = verbose_name class IndexPromotionBanner(BaseModel): '''首页促销活动模型类''' name = models.CharField(max_length=20, verbose_name='活动名称') url = models.URLField(verbose_name='活动链接') image = models.ImageField(upload_to='banner', verbose_name='活动图片') index = models.SmallIntegerField(default=0, verbose_name='展示顺序') class Meta: db_table = 'df_index_promotion' verbose_name = \"主页促销活动\" verbose_name_plural = verbose_name step2 因为在df_goods模块中使用了第三方模块tinymce富文本编辑器所以需要在settings中进行添加应用 12345678910111213INSTALLED_APPS = [ &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;tinymce&apos;, &apos;df_cart&apos;, &apos;df_goods&apos;, &apos;df_order&apos;, &apos;df_user&apos;] step3 在配置文件末尾添加编辑器的配置 123456# 富文本编辑器配置TINYMCE_DEFAULT_CONFIG = &#123; &apos;theme&apos;: &apos;advanced&apos;, &apos;width&apos;: 600, &apos;height&apos;: 400,&#125; step4 在根基urls文件中配置编辑器url 1url(r'^tinymce/', include('tinymce.urls')), # 富文本编辑器 10.在df_order模块中的models.py中定义如下模型类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-from django.db import modelsfrom db.base_model import BaseModel# Create your models here. class OrderInfo(BaseModel): '''订单模型类''' PAY_METHOD_CHOICES = ( (1, '货到付款'), (2, '微信支付'), (3, '支付宝'), (4, '银联支付') ) ORDER_STATUS_CHOICES = ( (1, '待支付'), (2, '待发货'), (3, '待收货'), (4, '待评价'), (5, '已完成') ) order_id = models.CharField(max_length=128, primary_key=True, verbose_name='订单id') user = models.ForeignKey('df_user.User', verbose_name='用户') addr = models.ForeignKey('df_user.Address', verbose_name='地址') pay_method = models.SmallIntegerField(choices=PAY_METHOD_CHOICES, default=3, verbose_name='支付方式') total_count = models.IntegerField(default=1, verbose_name='商品数量') total_price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name='商品总价') transit_price = models.DecimalField(max_digits=10, decimal_places=2,verbose_name='订单运费') order_status = models.SmallIntegerField(choices=ORDER_STATUS_CHOICES, default=1, verbose_name='订单状态') trade_no = models.CharField(max_length=128, verbose_name='支付编号') class Meta: db_table = 'df_order_info' verbose_name = '订单' verbose_name_plural = verbose_name class OrderGoods(BaseModel): '''订单商品模型类''' order = models.ForeignKey('OrderInfo', verbose_name='订单') sku = models.ForeignKey('df_goods.GoodsSKU', verbose_name='商品SKU') count = models.IntegerField(default=1, verbose_name='商品数目') price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name='商品价格') comment = models.CharField(max_length=256, verbose_name='评论') class Meta: db_table = 'df_order_goods' verbose_name = '订单商品' verbose_name_plural = verbose_name 11.在settings配置文件中使用django内置的认证系统指定的模型类为df_user下的User类 12# django认证系统指定的模型类AUTH_USER_MODEL = &apos;df_user.User&apos; 12.生成迁移文件 13.执行迁移文件 14.查看数据库 15.运行项目 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/88790662","categories":[{"name":"Django开发","slug":"Django开发","permalink":"https://hellotaogang.github.io/categories/Django开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://hellotaogang.github.io/tags/Django/"},{"name":"Django网站实战","slug":"Django网站实战","permalink":"https://hellotaogang.github.io/tags/Django网站实战/"},{"name":"Python Web开发","slug":"Python-Web开发","permalink":"https://hellotaogang.github.io/tags/Python-Web开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之手机端租房网站的实战开发（完结）","slug":"Flask项目之手机端租房网站的实战开发（完结）","date":"2019-11-06T05:32:35.752Z","updated":"2019-11-13T13:06:43.324Z","comments":true,"path":"2019/11/06/Flask项目之手机端租房网站的实战开发（完结）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/06/Flask项目之手机端租房网站的实战开发（完结）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶注册和登录以及用户退出功能 二丶上传头像功能和修改用户名功能测试 三丶发布房源以及实名认证功能测试 四丶网站房屋搜索功能测试 五丶我的订单功能以及客户订单功能测试 六丶网站主页房屋幻灯片功能测试","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶注册和登录以及用户退出功能 二丶上传头像功能和修改用户名功能测试 三丶发布房源以及实名认证功能测试 四丶网站房屋搜索功能测试 五丶我的订单功能以及客户订单功能测试 六丶网站主页房屋幻灯片功能测试 一丶注册和登录以及用户退出功能1.注册功能 step1 使用博主自己的手机号码进行注册功能测试，注册界面（左图），手机收到短信验证（右图） step2 点击注册则成功进入网站主页，并在右上角显示注册的手机号码，功能测试成功 step3 查看数据库用户表ih_user_profile与刚注册的用户信息一致 step4 查看redis数据库保存用户登录信息的session数据 2.退出功能 step1 点击网站主页右上角的手机号码（左图，刚注册还未设置用户名，所以用户名默认为手机号），进入我的爱家界面（右图） step2 在我的爱家页面，点击最下面的退出功能按钮，成功退出并清除用户信息相关的session数据，在主页右上方显示注册登录按钮 step3 此时查看redis数据库中session数据，按上一篇博客写的逻辑，正确则只显示csrf_token的数据 3.登录功能 点击登录按钮，进入登录页（左图），输入刚注册时的手机号码以及密码，成功登录进入主页（右图） 二丶上传头像功能和修改用户名功能测试1.上传头像功能 step1 进入我的爱家（左图），点击修改进入个人信息页面（右图） step2 点击选择文件按钮，选择头像图片（左图），点击上传则设置头像成功（右图） step3 查看数据库用户信息表ih_user_profile，avatar_url头像图片url字段不再为null 2.修改用户名功能 step1 在用户名一栏输入要修改后用户名（左图），点击保存按钮，则提示保存成功（右图） step2 查看数据库用户信息表ih_user_profile，name字段的值为刚设置的用户名 step3 进入我的爱家页面，在个人信息栏，成功显示出设置的用户头像和用户名 step4 回到主页，在右上角成功显示出设置的用户名 三丶发布房源以及实名认证功能测试1.实名认证功能 step1 首先先进入我的房源页面，当用户想发布房源那么就需要进行实名认证，实名认证成功后，在我的房源页面才有发布房源的功能按钮 step2 进入实名认证页面（左图），输入姓名以及身份证号（这个身份证号乱输的），如（右图）所示 step3 点击保存后，成功则提示保存成功（左图），然后此页面便变成灰色输入框不可编写状态（右图） step4 数据库用户信息表ih_user_profile，real_name和id_card字段的值为用户实名认证填写的数据 2.发布房源功能 step1 当用户进行实名注册成功之后，再次进入我的房源页，则出现发布房源功能按钮（左图），点击发布房源功能出现（右图）界面 step2 填写房源信息 step3 店家发布房源信息进入发布新房源页面（左图），选择房屋图片，点击上传（右图），可以传多张 step4 查看数据库房屋信息表ih_house_info，表字段值与填写的新房源数据一致 step5 回到我的房源页面，则成功显示该用户发布的房源信息 四丶网站房屋搜索功能测试1.网站主页搜索 step1 用户在主页中选择入住条件 step2 点击搜索后则跳转到房屋列表页，显示出满足用户选择的入住条件的房屋（左图），客户点击此列表页中任意一房屋后，则显示该房屋的相关信息（右图） step3 此账号用户刚好在锦江区发布过一个房源，因为代码逻辑设定用户自己不能预订自己发布的房屋，所以点击进行该房屋，则不显示即可预定功能按钮 2.房源列表页进行搜索 在房源列表页上，可进行入住日期区域以及按照条件进行筛选，选择2-3~2-5日入住，房屋位置为武侯区，筛选条件为价格由低到高，进行搜索，筛选条件就不进行一一测试了 五丶我的订单功能以及客户订单功能测试1.我的订单功能 step1 进入我的订单页面，显示为空，因为该用户并未进行房屋预定（左图），对云漫单间进行预定（右图） step2 因为预订房屋为张三发布的，所以切换到张三账户，在我的订单中对该订单进行接单处理 step3 回到之前账户，查看我的订单显示为待支付状态，功能测试成功，支付功能测试在客户订单功能中进行测试 2.客户订单功能 step1 该用户在锦江区成功发布了一个新房源，登录18033333333（张三）账号，对此房源进行预定，在主页选择锦江区（左图），点击搜索按钮，默认筛选条件为最新，所以第一个为该用户发布的房屋（右图） step2 点击房屋图片显示房屋信息，点击即可预定对该房屋进行预定（左图），输入入住以及离开日期后，显示出订单总金额（右图） step3 提交订单后，显示该订单状态信息为待接单 step4 此时登录180XXXXX796（2019 努力 奋斗）账号，进入我的爱家—–客户订单页面，显示18033333333（张三）预定了我的房屋的订单信息（左图），选择接单，此单状态变为已接单状态（右图），选择拒单则需要填写拒单原因，拒单就不进行演示了，之前的博客已经演示过了 step5 切换到18033333333（张三）账号，查看我的订单则显示此单的状态为待支付状态（左图），正常来说是待使用，等到客户到店入住后，则显示为入住中，退房时显示为待支付，支付后显示为待评价，评价完成后，此订单状态才为已完成，前面的三个步骤给省略掉了，因为没那个时间去等待测试，点击去支付则跳转到登录支付宝页面（右图） step6 登录支付宝后，则显示订单的信息，以及付款金额（左图），确认付款输入支付密码后，则显示支付成功界面（右图） step7 点击完成后，则跳转到我的订单页面，此时订单的状态为待评价状态 step8 点击发表评价后，弹出评价框（左图），输入评价信息，然后确定则此单的评价信息成功显示出来（右图） step9 切换到180XXXXX796（2019 努力 奋斗）账号，进入到客户订单中，在此订单我的评价一栏也显示了用户作出的评价信息 六丶网站主页房屋幻灯片功能测试说明：网站主页五张幻灯片是按照订单量倒序进行筛选的，意思就是订单量越大则显示到幻灯片主页第一张，以此类推，因为主页幻灯片属于用户经常访问的资源，所以是保存在redis数据库中当中缓存数据的，所以就会有有效期（7200S），当过了有效期后则会按照此时的订单量进行筛选房屋数据的，按照房屋的订单量进行倒序排序，取出5条数据对象，每个对象中的房屋图片，则显示拿到前端主页页面进行显示给所有用户 step1 在数据库中按照订单量的倒序进行查询，并显示5条 step2 根据数据库查询结果，得值云漫单间排名第一，所以在主页房屋幻灯片第一张应该是云漫单间 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/86756248","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（十四）","slug":"Flask项目之手机端租房网站的实战开发（十四）","date":"2019-11-06T02:59:13.262Z","updated":"2019-11-13T13:04:01.095Z","comments":true,"path":"2019/11/06/Flask项目之手机端租房网站的实战开发（十四）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/06/Flask项目之手机端租房网站的实战开发（十四）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶支付接口 二丶支付宝支付后端接口编写 三丶支付宝支付测试 四丶获取支付宝支付结果对订单状态进行修改 五丶测试订单支付成功后对订单状态的修改 六丶测试客户评论对订单状态以及订单量的增加 七丶项目优化","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶支付接口 二丶支付宝支付后端接口编写 三丶支付宝支付测试 四丶获取支付宝支付结果对订单状态进行修改 五丶测试订单支付成功后对订单状态的修改 六丶测试客户评论对订单状态以及订单量的增加 七丶项目优化 一丶支付接口1.分析：当客户下单后，房东需要进入客户订单中，将该订单进行接单处理后，那么在客户的我的订单功能中，才能对此订单进行支付操作，当客户点击支付后，接入支付宝支付（这里以支付宝为支付方式，微信的话逻辑也是一样） 2.支付宝开发文档 step1 进入支付宝开放平台https://open.alipay.com/platform/home.htm，进入开发接入-----查看详情 step2 然后选择支付应用下的接入文档 step3 点击全部文档 step4 进入手机网站支付，查看开发说明文档 3.支付宝产品流程 step1 用户已安装支付宝支付流程： 步骤1：用户在浏览器中访问商家网页应用，选择商品下单、确认购买，进入支付环节，选择支付宝付款，用户点击去支付，如下图1；步骤2：进入到支付宝支付路由页面，支付宝处理支付请求，并尝试唤起支付宝客户端，如下图2；步骤3：进入到支付宝页面，调起支付宝支付，出现确认支付界面，如下图3； 图1： 图2： 图3： 步骤4：用户确认收款方和金额，点击立即支付后出现输入密码界面，如下图4；步骤5：输入正确密码后，支付宝端显示支付结果，如下图5；步骤6：自动回跳到浏览器中，商家根据付款结果个性化展示订单处理结果，如下图6。注意：在iOS系统中，唤起支付宝App支付完成后，不会自动回到浏览器或商户App。用户可手工切回到浏览器或商户App。 图4： 图5： 图6： step2 用户未安装支付宝支付流程：用户未安装支付宝支付流程步骤1：若用户未安装支付宝客户端，用户进入到支付宝网页收银台，用户登录支付宝账户，如图7和图8；步骤2：登录成功后，进入付款确认页面，如图9；步骤3：用户点击确认付款，进入支付密码页面，如图10；步骤4：用户输入密码，完成支付，展示支付结果，如图11。 图7： 图8： 图9： 图10： 图11： 4.创建应用 step1 登录支付宝，进入管理中心 step2 填写入住申请 step3 提交后进入如下界面 step4 进入网页&amp;移动应用列表，进入支付接入 step5 创建应用并提交审核，通过后，方可在线上使用 ，需要审核，还有填写营业执照啥的，这样太麻烦，微信有测试环境，那么支付宝同样也有，沙箱就是支付宝测试环境 5.沙箱：这是支付宝提供开发人员测试的那么一个环境，这个沙箱环境与线上的环境是一样的，在沙箱环境与线上使用唯一不同的就是APPID，如果需要转换为线上的话，只需要将APPID修改为你的应用的APPID即可，程序代码不需要作任何改变，进入支付宝沙箱，在沙箱账号中分为卖家信息和买家信息，账户余额可以任意充值 6.支付流程图 7.在支付宝开发平台中，只有JAVA PHP 以及.NET三种语言的SDK，在github上也有他人封装好的支付宝支付的SDK https://github.com/fzlee/alipay/blob/master/README.zh-hans.md 二丶支付宝支付后端接口编写1.生成秘钥文件 step1 在linux系统中有openssl命令，用来生成秘钥的，进入openssl，执行genrsa -out app_private_key.pem 2048命令，生成2048字节的私钥并保存到app_private_key.pem文件中 step2 生成完私钥后，执行rsa -in app_private_key.pem -pubout -out app_public_key.pem，对应根据私钥生成公钥 step3 在终端中使用cat 查看公钥，复制公钥 step4 在沙箱中查看应用公钥点击修改，将刚复制的公钥进行粘贴保存即可 step5 在项目文件api_1_0目录下新建keys目录用于保存项目所需的秘钥，再将在linux系统中生成的app_private_key.pem拷贝到keys项目目录下，在keys目录下创建一个alipay_public_key.pem文件，然后在上图中，查看支付宝公钥，复制支付宝公钥，将复制的支付宝公钥粘贴到alipay_public_key.pem文件中 2.逻辑编写 step1 在api_1_0目录下创建一个pay.py模块，用作于支付，然后子啊init中导入此模块 step2 定义接口路由 12345@api.route(\"/orders/&lt;int:order_id&gt;/payment\", methods=[\"POST\"])@login_requireddef order_pay(order_id): \"\"\"支付宝支付\"\"\" pass step3 获取用户id 1user_id = g.user_id step4 判断订单的状态，需要满足参数中订单id与客户的订单id一致，当前订单的用户与登录的用户id一致，以及订单的状态为待支付 12345try: order = Order.query.filter(Order.id==order_id, Order.user_id==user_id, Order.status==\"WAIT_PAYMENT\").first()except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"数据库异常\") step5 判断订单对象是否存在 12if not order: return jsonify(errno=RET.NODATA, errmsg=\"订单数据有误\") step6 获取应用私钥 12app_private_key_path = os.path.join(os.path.dirname(__file__), \"keys/app_private_key.pem\")app_private_key_string = open(app_private_key_path).read() step7 获取支付宝公钥 12alipay_public_key_path = os.path.join(os.path.dirname(__file__), \"keys/alipay_public_key.pem\")alipay_public_key_string = open(alipay_public_key_path).read() step8 创建支付宝sdk工具对象 123456789app_client = AliPay( appid=\"2016092400589177\", # 沙箱的appid app_notify_url=None, # 默认回调url app_private_key_string=app_private_key_string, # 私钥 # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥, alipay_public_key_string=alipay_public_key_string, sign_type=\"RSA2\", # RSA 或者 RSA2 debug = True # 默认False) step9 手机网站支付，需要跳转到https://openapi.alipaydev.com/gateway.do? + order_string 1234567order_string = app_client.api_alipay_trade_wap_pay( out_trade_no=order.id, # 订单编号 total_amount=str(order.amount/100.0), # 总金额 subject=u\"爱家租房&lt;%s&gt;\" % order.id, # 订单标题 return_url=\"http://127.0.0.1:5000/orders.html\", notify_url=None # 可选, 不填则使用默认notify url) step10 构造用户跳转的支付链接地址，并返回正确响应数据 123pay_url = constants.ALIPAY_URL_PREFIX + order_string return jsonify(errno=RET.OK, errmsg=\"OK\", data=&#123;\"pay_url\":pay_url&#125;) 三丶支付宝支付测试1.运行项目，清除浏览器缓存，进入http://127.0.0.1:5000/orders.html我的订单页面 2.在订单编号为5的订单上进行点击去支付， 然后会出现一个检查客户到的页面，如果客户端存在则会在手机上打开支付宝客户端（注：因为这里博主使用的是沙箱进行开发测试，所以在手机端需要安装沙箱版的支付宝，详细说明在开发平台文档中有相关说明，此支付宝只暂不支持IOS） 3.因为博主是在电脑Web上进行测试，所以当环境中没有支付宝客户端，那么就会跳转到支付宝手机网页登录界面，选择支付宝账号登录（左图），输入开发平台沙箱买家账号（右图）进行登录 图10： 图11： 4.点击下一步后，会出现房屋的编号，以及金额，与我的订单中编号5的的订单信息一致（左图），点击确认付款后，输入支付密码，然后出现（右图）成功界面 5.点击完成后，根据return_url编写的代码逻辑会跳转到http://127.0.0.1:5000/orders.html订单页面，此时订单5的状态依然显示待支付（左图），那是因为这一块的逻辑还未进行编写，当支付宝支付成功返回正确响应数据给我们时，我们还未在页面中对订单的状态进行修改，如果此时再点击该订单的去支付，则会出现（右图）页面，而不会跳转到订单支付界面，此时如果点击继续支付，则会报错，因为此订单在支付宝后台已经有对应的流水了 四丶获取支付宝支付结果对订单状态进行修改1.分析：根据代码逻辑当客户进行订单支付后，支付显示成功后，支付宝会携带以下参数跳转到订单页面，正常来说那么在这个页面就应该根据支付宝返回的参数，进行处理，但是放在订单页面进行处理的话就比较麻烦，因为我客户访问我的订单页面时，是不需要携带参数的，而从我的订单页面去访问支付宝支付接口时，成功支付后，返回的我的订单页面是携带了参数的，所以如果要在我的订单页面进行处理的话，需要进行判断到底是客户访问的还是支付宝返回回来的这是其一，其二就是在我的订单页面什么时候让后端去对订单状态进行更改，所以在我的订单页面进行处理的话，逻辑比较复杂，那么最好的方式就是定义一个过渡页面，当支付宝支付成功后，不是直接跳转到我的订单页面，而是跳转到我们定义的过渡页面，在这个过渡页面肯定是有支付宝发送过来的参数，那么就在后端对订单状态进行修改，再跳转到我的订单页面，显示成功支付后的订单状态 前台回跳参数 公共参数： 参数 类型 是否必填 最大长度 描述 示例值 app_id String 是 32 支付宝分配给开发者的应用ID 2016040501024706 method String 是 128 接口名称 alipay.trade.wap.pay.return sign_type String 是 10 签名算法类型，目前支持RSA2和RSA，推荐使用RSA2 RSA2 sign String 是 256 支付宝对本次支付结果的签名，开发者必须使用支付宝公钥验证签名 详见示例 charset String 是 10 编码格式，如utf-8,gbk,gb2312等 utf-8 timestamp String 是 19 前台回跳的时间，格式”yyyy-MM-dd HH:mm:ss” 2016-08-11 19:36:01 version String 是 3 调用的接口版本，固定为：1.0 1.0 业务参数： 参数 类型 是否必填 最大长度 描述 示例值 out_trade_no String 是 64 商户网站唯一订单号 70501111111S001111119 trade_no String 是 64 该交易在支付宝系统中的交易流水号。最长64位。 2016081121001004630200142207 total_amount Price 是 9 该笔订单的资金总额，单位为RMB-Yuan。取值范围为[0.01，100000000.00]，精确到小数点后两位。 9.00 seller_id String 是 16 收款支付宝账号对应的支付宝唯一用户号。 以2088开头的纯16位数字 2088111111116894 2.逻辑编写 step1 在static静态文件目录下创建一个payComplete.html订单支付完成页面，将orders.html的代码复制到此文件中，并进行修改 123456789101112131415&lt;div class=\"container\"&gt; &lt;div class=\"top-bar\"&gt; &lt;div class=\"nav-bar\"&gt; &lt;h3 class=\"page-title\"&gt;支付完成&lt;/h3&gt; &lt;a class=\"nav-btn fl\" href=\"/my.html\"&gt;&lt;span&gt;&lt;i class=\"fa fa-angle-left fa-2x\"&gt;&lt;/i&gt;&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"orders-con\"&gt; &lt;p style=\"font-size: 20px;margin: auto\"&gt;支付已完成&lt;/p&gt; &lt;a href=\"orders.html\" style=\"font-size: 18px\"&gt;返回到我的订单页&lt;/a&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;p&gt;&lt;span&gt;&lt;i class=\"fa fa-copyright\"&gt;&lt;/i&gt;&lt;/span&gt;爱家租房&amp;nbsp;&amp;nbsp;享受家的温馨&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; step2 在pay.py中将return_url修改为http://127.0.0.1:5000/payComplete.html过渡页面 1return_url=\"http://127.0.0.1:5000/payComplete.html\" step3 访问如下地址，查看此过渡页面 http://127.0.0.1:5000/payComplete.html?charset=utf-8&amp;out_trade_no=5&amp;method=alipay.trade.wap.pay.return&amp;total_amount=2544.00&amp;sign=U%2Fl06mjzgZwNEdXo0ePmldLIE6wuMZ4qo2PgyDf4Q%2BRZh1b0KdBqaRkckEBZ136Zyr283FzBlNOMprucQcjH6E9i1Df0ZVRx9HJAm54yN6n%2F1ENFpSOG9znILGbGj%2BV9v%2F0efrcUIvBnYgMIHvp2rBJ8ygRjnhQlTC0q5TVafJQ9OHt%2BX9Ae5F7yiJsb%2B8MVoaG6CDSxqy6MpT2JG7h14alKF6At%2BiJVCN6lbs9RCHZgABabTLDgHbkjJWusElCbi6NEzR%2FHvu9ANSz9onb0RmiyfZ35hwVNw1EATKTsdM47TwYxHxHv%2BFS0gFXdDsQnCYpsH%2F0SCL6aqjK%2Fj1r9eg%3D%3D&amp;trade_no=2019013122001459890500811871&amp;auth_app_id=xxx&amp;version=1.0&amp;app_id=xxx&amp;sign_type=RSA2&amp;seller_id=xxx&amp;timestamp=2019-01-31+10%3A47%3A16 step4 在pay.py模块中定义接口路由，用于保存订单支付结果 12345# /api_v1.0/order/payment@api.route(\"/order/payment\", methods=[\"PUT\"])def save_order_payment_result(): \"\"\"保存订单支付结果\"\"\" pass step5 获取支付宝支付成功返回的响应参数并转换为字典格式数据 1alipay_dict = request.form.to_dict() step6 对支付宝的数据进行分离 将签名参数sign提取出去并获取值 1alipay_sign = alipay_dict.pop(\"sign\") step7 获取应用私钥和支付宝公钥 123456# 获取应用私钥app_private_key_path = os.path.join(os.path.dirname(__file__), \"keys/app_private_key.pem\")app_private_key_string = open(app_private_key_path).read()# 获取支付宝公钥alipay_public_key_path = os.path.join(os.path.dirname(__file__), \"keys/alipay_public_key.pem\")alipay_public_key_string = open(alipay_public_key_path).read() step8 创建支付宝sdk工具对象 123456789app_client = AliPay( appid=\"2016092400589177\", # 沙箱的appid app_notify_url=None, # 默认回调url app_private_key_string=app_private_key_string, # 应用私钥 # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥, alipay_public_key_string=alipay_public_key_string, # 支付宝公钥 sign_type=\"RSA2\", # RSA 或者 RSA2 debug=True # 默认False) step9 通过支付宝sdk工具对象中的verify方法验证支付宝返回的响应参数中剔除sign参数后，剩余参数与响应参数中的sign值是否一致，如果确定参数是支付宝的，返回True，否则返回false 1result = app_client.verify(alipay_dict, alipay_sign) step10 验证正确则修改数据库的订单状态信息，最后返回正确响应 12345678910111213if result: # 获取请求中的参数 order_id = alipay_dict.get(\"out_trade_no\") # 订单号 trade_no = alipay_dict.get(\"trade_no\") # 支付宝的流水号 try: # 查询并修改该订单的状态以及在支付宝中的交易流水号 Order.query.filter_by(id=order_id).update(&#123;\"status\": \"WAIT_COMMENT\", \"trade_no\": trade_no&#125;) db.session.commit() except Exception as e: current_app.logger.error(e) db.session.rollback() return jsonify(errno=RET.OK, errmsg=\"OK\") 3.更新数据库ih_order_info表字段，增加trade_no字段 说明：因为当初在创建数据库时，未设置订单对应的支付宝交易流水号的字段，所以这里进行一个更新 step1 在models.py中找到Order类，添加此字段 1trade_no = db.Column(db.String(128)) # 支付宝交易流水号 step2 生成迁移文件并对数据库进行更新操作 step3 查看数据库ih_order_info表结构，添加trade_no字段成功 4.在payComplete.html中编写js代码，向后端/api/v1.0/order/payment接口发送请求，并携带支付宝支付成功返回的参数 12345678910111213141516&lt;script type=\"text/javascript\"&gt; function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined; &#125; // 获取支付宝返回的url中的参数，并通过substr方法从去掉第一个元素?,因为返回的url参数是以键值对方式进行构造的，所以这里是以请求体数据进行发送给后端接口 var alipayData = document.location.search.substr(1); $.ajax(&#123; url: \"/api/v1.0/order/payment\", type: \"put\", data: alipayData, headers: &#123; \"X-CSRFToken\": getCookie(\"csrf_token\") &#125; &#125;)&lt;/script&gt; 五丶测试订单支付成功后对订单状态的修改1.运行项目，清除页面缓存，刷新网页，进入我的订单（左图），因为前面测试支付时，对订单编号为5的订单已经支付成功，所以对应的在支付宝后台中已经形成了此订单编号为5的交易号，所以这里需从数据库中将该订单的编号进行修改，这里修改为100（右图） 1update ih_order_info set id= 100 where id = 5; 2.然后将订单编号为100的订单进行支付（左图），点击确认付款后，支付宝显示成功后，则跳转到payComplete.html页面，在此页面中点击返回我的订单页，此订单状态为发表评价（右图），按理说当订单支付成功后，该订单状态显示为已支付，等待用户退房或者完成住宿后，才会出现待评价，这个逻辑被直接省掉了，在此项目中用户一旦支付成功则该订单显示发表评价 3.第一次使用支付宝支付接口的朋友们，一般不知道支付宝会收取手续费的，那么博主就带大家看看支付宝的手续费是多少 step1 修改我的订单中订单标号为1的订单，将编号改为101，来进行测试，这个房屋之前博主测试过电脑网页支付接口，所以是需要进行编号修改的 step2 查看蚂蚁金服开放平台—沙箱账号中商家的账户余额为2009144.81，测试订单的金额为4112，没有手续费的情况下，客户支付此单后，商家的账户余额就应该为2013256.81 step3 支付编号为101的订单，下面展示支付流程图 step4 点击返回到我的订单页后，订单标号为101的订单显示为可以发表评价 step5 在step2时，如果没有支付宝不收取手续费的情况下，客户在支付4112元订单后，商家的账户余额应该为2013256.81元，那么此时在商家信息看看商家的账户余额到底是不是这么多钱，结果发现商家的余额是2013232.14元 step6 计算下支付宝的收费需收取比例是多少，原来是千分之6，还是比较多的 六丶测试客户评论对订单状态以及订单量的增加1.对订单编号为100的订单（左图），点击发表评论按钮，弹出评论框（右图） 2.点击确定按钮后，该订单的状态变成已完成，显示客户评论 3.查看数据库房屋信息表ih_user_info，订单量order_count值从0变成1，代码逻辑当订单状态变成已完成则order_count加1 七丶项目优化1.解决csrf_token缺失的bug，INFO csrf.py:251 The CSRF token is missing.，在用户进行退出时，不将session数据全部清除，需要将csrf_token的数据保存到session中 123456# 在清除session数据时，先从session中获取csrf_token的值csrf_token = session.get(\"csrf_token\")session.clear()# 当session数据清除完后 再设置session中的csrf_token的值，这样可以解决csrf_token缺失的bugsession[\"csrf_token\"] = csrf_token 2.数据库优化： a. 表结构设计 扩展 查询的快慢 三范式 https://www.zhihu.com/question/24696366 设计的时候就考虑可能会用到的查询，为方便查询而设计，比如用空间换时间，适当增加冗余字段节省查询开销 b. 建索引 主键 唯一(unique) 索引(key index) （外键） http://www.jianshu.com/p/2b541c028157 提升 查询速度 复合索引 where k1 k2 k3 k4 降低 增删改 c. sql语句优化 123456789101112131415使用索引 注意关键字顺序 最左原则 where 不要select * 能使用联合查询，不使用嵌套（子查询） select from tbl_a a inner join tbl_b b on a.field=b.filed where b.= select from tbl_a where filed=(select field from tbl_b where b.=) 能不使用联合查询，尽量不用联合查询 外键 cascade 级联 （维护外键有额外开销，影响性能） 数据量大的时候，不再使用外键 使用分析工具分析效率低的sql语句 慢查询工具 https://flyerboy.github.io/2016/12/23/mysql_slow/https://yemengying.com/2016/05/24/mysql-tuning/ d. 缓存 redis memcached e. 读写分离 主从热备份 主（写 增删改） 从（查） f. 分库分表 水平分库分表 http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/86699086","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（十三）","slug":"Flask项目之手机端租房网站的实战开发（十三）","date":"2019-11-05T13:55:52.138Z","updated":"2019-11-13T13:02:39.632Z","comments":true,"path":"2019/11/05/Flask项目之手机端租房网站的实战开发（十三）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/05/Flask项目之手机端租房网站的实战开发（十三）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶保存订单后端接口编写 二丶预订页面前端编写以及接口测试 三丶订单模块（我的订单）后端接口编写 四丶订单模块（我的订单）前端编写 五丶我的订单功能测试 六丶订单模块（客户订单）后端接口编写 七丶订单模块（客户订单）前端编写以及接口测试","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶保存订单后端接口编写 二丶预订页面前端编写以及接口测试 三丶订单模块（我的订单）后端接口编写 四丶订单模块（我的订单）前端编写 五丶我的订单功能测试 六丶订单模块（客户订单）后端接口编写 七丶订单模块（客户订单）前端编写以及接口测试 一丶保存订单后端接口编写1.分析：当用户点击房屋图片进入房间信息页面时，在页面最下面会出现即可预定功能按钮（左图），当用户点击预定时，即跳转到预定页面（右图），在该页面中，首选是获取用户点击的房屋信息显示到此页面上，然后需要用户选择入住的时间和离开的时间，当用户选择完时间后那么在界面左下角即显示出订单的价格，点击提交订单后，此时需要从后端来判断此房间在用户选择入住离开期间有没有冲突订单，如果有则提示用户房屋被抢订，重新选择日期的一个提示，如果提交订单成功，则在我的订单中显示出该订单，这是整个业务逻辑 2.逻辑编写如下 step1 在api_v1.0目录下创建orders.py模块，用于编写订单相关的接口，并在init.py模块中导入此模块 step2 定义路由接口 12345@api.route(\"/orders\", methods=[\"POST\"])@login_requireddef save_order(): \"\"\"保存用户的订单\"\"\" pass step3 获取用户id 1user_id = g.user_id step4 获取前端发送的请求参数 1order_data = request.get_json() step5 校验参数 12if not order_data: return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") step6 获取用户预订的房屋编号，入住时间以及离开时间 123house_id = order_data.get(\"house_id\")start_date_str = order_data.get(\"start_date\")end_date_str = order_data.get(\"end_date\") step7 校验参数完整性 12if not all([house_id, start_date_str, end_date_str]): return jsonify(errno=RET.PARAMERR, errmsg=\"参数不完整\") step8 检查日期格式 12345678910try: # 将str格式的日期数据转换成datetime格式的日期数据 start_date = datetime.strptime(start_date_str, \"%Y-%m-%d\") end_date = datetime.strptime(end_date_str, \"%Y-%m-%d\") assert start_date &lt;= end_date #使用断言就行判断 # 计算预订的天数 days = (end_date-start_date).days + 1except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.PARAMERR, errmsg=\"日期格式不正确\") step9 查询用户预订的房屋是否存在 12345try: house = House.query.get(house_id)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"获取房屋信息失败\") step10 判断房屋是否存在 12if not house: return jsonify(errno=RET.NODATA, errmsg=\"房屋不存在\") step11 判断房东预订的房屋是不是自己的发布的房屋 12if user_id == house.user_id: return jsonify(errno=RET.ROLEERR, errmsg=\"不能预订自己发布的房屋\") step12 检查用户预订的时间内，房屋没有被别人下单 123456try: # 查询时间冲突的订单数 select count(*) from ih_order_info where () count = Order.query.filter(Order.house_id == house_id, Order.begin_date &lt;= end_date, Order.end_date &gt;= start_date).count()except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"系统繁忙，请稍候重试\") step13 如果查询的订单冲突数大于0，则说明房屋在用户预订时间内，已被他人预订 12if count &gt; 0: return jsonify(errno=RET.DATAERR, errmsg=\"房屋已被预订\") step14 计算订单总额 1amount = house.price * days step15 保存订单数据 123456789order = Order( house_id=house_id, user_id=user_id, begin_date=start_date, end_date=end_date, days=days, house_price=house.price, amount=amount ) step16 将订单数据提交到数据库中，并返回正确响应数据 12345678910try: db.session.add(order) db.session.commit()except Exception as (e): current_app.logger.error(e) db.session.rollback() return jsonify(errno=RET.DBERR, errmsg=\"保存订单失败\")返回正确响应数据return jsonify(errno=RET.OK, errmsg=\"OK\", data=&#123;\"order_id\": order.id&#125;) 二丶预订页面前端编写以及接口测试1.在booking.js中进行如下编写 step1 首先当页面加载完时，则判断用户是否登录 12345$.get(\"/api/v1.0/session\", function(resp) &#123; if (\"0\" != resp.errno) &#123; location.href = \"/login.html\"; &#125;&#125;, \"json\"); step2 获取详情页面要展示的房屋编号 12var queryData = decodeQuery();var houseId = queryData[\"id\"]; step3 获取房屋的基本信息 1234567$.get(\"/api/v1.0/houses/\" + houseId, function(resp)&#123; if (0 == resp.errno) &#123; $(\".house-info&gt;img\").attr(\"src\", resp.data.house.img_urls[0]); $(\".house-text&gt;h3\").html(resp.data.house.title); $(\".house-text&gt;p&gt;span\").html((resp.data.house.price/100.0).toFixed(0)); &#125; &#125;); step4 提交订单 12345678910111213141516171819202122232425262728293031$(\".submit-btn\").on(\"click\", function(e) &#123; if ($(\".order-amount&gt;span\").html()) &#123; $(this).prop(\"disabled\", true); var startDate = $(\"#start-date\").val(); var endDate = $(\"#end-date\").val(); var data = &#123; \"house_id\":houseId, \"start_date\":startDate, \"end_date\":endDate &#125;; $.ajax(&#123; url:\"/api/v1.0/orders\", type:\"POST\", data: JSON.stringify(data), contentType: \"application/json\", dataType: \"json\", headers:&#123; \"X-CSRFTOKEN\":getCookie(\"csrf_token\"), &#125;, success: function (resp) &#123; if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; else if (\"4004\" == resp.errno) &#123; showErrorMsg(\"房间已被抢定，请重新选择日期！\"); &#125; else if (\"0\" == resp.errno) &#123; location.href = \"/orders.html\"; &#125; &#125; &#125;); &#125;&#125;); 2.测试 step1 在房屋信息页（左图），点击即可预定后成功跳转到预定界面（右图），并成功显示预定房屋的信息 step2 在预定房屋界面，选择入住时间以及离开时间后，左下角则成功显示正确的订单总额（左图），当点击提交订单成功后，则跳转到我的订单页面（右图），因为此页面接口未编写，所以啥都没有属于正常情况 step3 此时查看数据库ih_order_info表，则显示我们成功提交的订单信息，此功能测试成功 三丶订单模块（我的订单）后端接口编写1.分析：第一当用户成功提交订单后，则会跳转到我的订单页面，此时在这个页面就应该显示出用户刚才预定房屋的订单情况，第二就是需要对角色进行一个判断，如果是下单人那么在我的订单中查看订单，如果是房东那么就在客户订单中，查看别人预定我发布的房屋的订单，无论是哪种情况，对于后端来说都是查询数据库订单信息情况而已，所以这两个功能可以用一个查询订单接口在后端进行实现 2.说明：之所以不管哪种角色在我的爱家页面都出现这两个有关订单的功能（我的订单和客户订单），那是因为对于任何注册网站的用户来说，我既可以订房，也可以发布房源，即一个账号可以切换成两种角色 3.逻辑编写 step1 定义接口路由 123456# /api/v1.0/user/orders?role=(custom/landlord)@api.route(\"/user/orders\", methods=[\"GET\"])@login_requireddef get_user_orders(): \"\"\"查询用户的订单信息\"\"\" pass step2 获取用户id 1user_id = g.user_id step3 获取前端请求数据中角色role,如果没有则默认为空字符串 1role = request.args.get(\"role\", \"\") step4 获取订单数据 123456789101112131415try: # 以房东的身份在数据库中查询自己发布过的房屋 if \"landlord\" == role: houses = House.query.filter(House.user_id == user_id).all() # 通过列表生成式方式保存房东名下的所有房屋的id houses_ids = [house.id for house in houses] # 在Order表中查询预定了自己房子的订单,并按照创建订单的时间的倒序排序，也就是在此页面显示最新的订单信息 orders = Order.query.filter(Order.house_id.in_(houses_ids)).order_by(Order.create_time.desc()).all() else: # 以房客的身份查询订单，则查询的是我的订单 orders = Order.query.filter(Order.user_id == user_id).order_by(Order.create_time.desc()).all()except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"获取订单信息失败\") step5 在models.py模块Order类中构建to_dict方法，用于将详细信息转换为字典数据 1234567891011121314def to_dict(self): \"\"\"将订单信息转换为字典数据\"\"\" order_dict = &#123; \"order_id\": self.id, \"title\": self.house.title, \"img_url\": constants.QINIU_URL_DOMAIN + self.house.index_image_url if self.house.index_image_url else \"\", \"start_date\": self.begin_date.strftime(\"%Y-%m-%d\"), \"end_date\": self.end_date.strftime(\"%Y-%m-%d\"), \"ctime\": self.create_time.strftime(\"%Y-%m-%d %H:%M:%S\"), \"days\": self.days, \"amount\": self.amount, \"status\": self.status, \"comment\": self.comment if self.comment else \"\" &#125; step6 订单存在则将订单对象orders转换成字典数据 1234orders_dict_list = [] if orders: for order in orders: orders_dict_list.append(order.to_dict()) step7 最后向前端返回正确响应数据 1return jsonify(errno=RET.OK, errmsg=\"OK\", data=&#123;\"orders\": orders_dict_list&#125;) 四丶订单模块（我的订单）前端编写1.我的订单orders.js中进行如下编写，需注意的是当客户预定的房间后，会引导到支付链接去 1234567891011121314151617181920212223// 查询房客订单 $.get(\"/api/v1.0/user/orders?role=custom\", function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\".orders-list\").html(template(\"orders-list-tmpl\", &#123;orders:resp.data.orders&#125;)); $(\".order-pay\").on(\"click\", function () &#123; var orderId = $(this).parents(\"li\").attr(\"order-id\"); $.ajax(&#123; url: \"/api/v1.0/orders/\" + orderId + \"/payment\", type: \"post\", dataType: \"json\", headers: &#123; \"X-CSRFToken\": getCookie(\"csrf_token\"), &#125;, success: function (resp) &#123; if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; // 引导用户跳转到支付宝连接 location.href = resp.data.pay_url; &#125; &#125; &#125;); &#125;); 2.在orders.html中进行如下编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;script id=\"orders-list-tmpl\" type=\"text/html\"&gt; &#123;&#123;if orders&#125;&#125; &#123;&#123;each orders as order&#125;&#125; &lt;li order-id=&#123;&#123;order.order_id&#125;&#125;&gt; &lt;div class=\"order-title\"&gt; &lt;h3&gt;订单编号：&#123;&#123;order.order_id&#125;&#125;&lt;/h3&gt; &#123;&#123; if \"WAIT_COMMENT\" == order.status &#125;&#125; &lt;div class=\"fr order-operate\"&gt; &lt;button type=\"button\" class=\"btn btn-success order-comment\" data-toggle=\"modal\" data-target=\"#comment-modal\"&gt;发表评价&lt;/button&gt; &lt;/div&gt; &#123;&#123; else if \"WAIT_PAYMENT\" == order.status &#125;&#125; &lt;div class=\"fr order-operate\"&gt; &lt;button type=\"button\" class=\"btn btn-success order-pay\"&gt;去支付&lt;/button&gt; &lt;/div&gt; &#123;&#123;/if&#125;&#125; &lt;/div&gt; &lt;div class=\"order-content\"&gt; &lt;img src=\"&#123;&#123;order.img_url&#125;&#125;\"&gt; &lt;div class=\"order-text\"&gt; &lt;h3&gt;&#123;&#123;order.title&#125;&#125;&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;创建时间：&#123;&#123;order.ctime&#125;&#125;&lt;/li&gt; &lt;li&gt;入住日期：&#123;&#123;order.start_date&#125;&#125;&lt;/li&gt; &lt;li&gt;离开日期：&#123;&#123;order.end_date&#125;&#125;&lt;/li&gt; &lt;li&gt;合计金额：￥&#123;&#123;(order.amount/100.0).toFixed(0)&#125;&#125;(共&#123;&#123;order.days&#125;&#125;晚)&lt;/li&gt; &lt;li&gt;订单状态： &lt;span&gt; &#123;&#123;if \"WAIT_ACCEPT\" == order.status&#125;&#125; 待接单 &#123;&#123;else if \"WAIT_PAYMENT\" == order.status&#125;&#125; 待支付 &#123;&#123;else if \"WAIT_COMMENT\" == order.status&#125;&#125; 待评价 &#123;&#123;else if \"COMPLETE\" == order.status&#125;&#125; 已完成 &#123;&#123;else if \"REJECTED\" == order.status&#125;&#125; 已拒单 &#123;&#123;/if&#125;&#125; &lt;/span&gt; &lt;/li&gt; &#123;&#123;if \"COMPLETE\" == order.status&#125;&#125; &lt;li&gt;我的评价： &#123;&#123;order.comment&#125;&#125;&lt;/li&gt; &#123;&#123;else if \"REJECTED\" == order.status&#125;&#125; &lt;li&gt;拒单原因： &#123;&#123;order.comment&#125;&#125;&lt;/li&gt; &#123;&#123;/if&#125;&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125; &#123;&#123;else&#125;&#125; 暂时没有订单。 &#123;&#123;/if&#125;&#125;&lt;/script&gt; 五丶我的订单功能测试1.登录18022222222（Hellotaogang）账户后，直接进入我的订单页面，成功显示我的订单信息，如下 2.以客户的角色进行预定房间，选择锦江区，价格由高到低，选择最贵的房间 3.进入房间信息后，点击即可预定（左图），然后提交成功后跳转到我的订单页（右图），成功按照最新预定时间进行排序显示 4.查看数据库ih_user_profile用户信息表以及ih_order_info订单信息表，当前的所有订单都是由18022222222（Hellotaogang）账号进行的预定 5.现在博主登录18033333333（张三）账号进行测试，测试房东能不能预定自己发布的房屋（刷单） step1 首先在数据中查看张三发布了哪些房屋 step2 这里对house_id为10的房屋进行预定，也就是至朴大床房进行预定，结果发现根本没有即可预定按钮（左图），反之对house_id为8的商务套房进行预定，如果成功显示即可预定功能按钮（右图），那么说明编写的代码逻辑没有任何问题 6.上一篇博客中有一个搜索条件未进行测试，因为当时并没有编写订单模块接口，所以无法查询到冲突订单，现在我使用18111111111（taogang123）账号进行相同房间时间冲突为条件进行搜索测试 step1 根据数据库订单表以及房屋信息表，获取Hellotaogang账号的订单信息以及对应的房屋信息 step2 根据获取的信息来进行冲突订单搜索条件测试，金牛区房屋id为13的云篆单间入住时间为2019-01-27到2019-01-30的订单已经被Hellotaogang账号预定，无法预定则表示代码逻辑正确 step3 在主页进行条件搜索时，则不显示冲突订单中房屋信息 六丶订单模块（客户订单）后端接口编写1.分析：当房东进入客户订单后，即显示出该房东的房屋被客户预定的订单信息，在每个订单上都会有接单以及拒单的功能按钮，不管是接单还是拒单都是改变订单的一个状态，只是房东在选择拒单时必需填写拒绝原因，所以这关于接单和拒单这两个功能接口可以进行复用 2.接口逻辑编写 step1 定义路由接口，需从前端请求中获取订单编号，使用PUT方式 12345@api.route(\"/orders/&lt;int:order_id&gt;/status\", methods=[\"PUT\"])@login_requireddef accept_reject_order(order_id): \"\"\"接单拒单\"\"\" pass step2 获取用户id 1user_id = g.user_id step3 获取请求参数 1req_data = request.get_json() step4 校验参数 12if not req_data: return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") step5 获取前端用户请求为接单还是拒单，关键字action 1action = req_data.get(\"action\") step6 判断action参数的值在不在accept接单和reject拒单之间 12if action not in (\"accept\", \"reject\"): return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") step7 在数据库中根据订单号查询订单状态为等待接单状态的订单 1234567891011try: order = Order.query.filter(Order.id == order_id, Order.status == \"WAIT_ACCEPT\").first() # 获取order订单对象中的house对象 house = order.houseexcept Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"无法获取订单数据\") # 如果order对象不存在或者订单中的房屋id不等于用户id 则说明房东在修改不属于自己房屋订单if not order or house.user_id != user_id: return jsonify(errno=RET.REQERR, errmsg=\"操作无效\") step8 房东选择接单，则对应订单状态为等待评论，拒单则需房东填写拒单的原因 12345678if action == \"accept\": # 接单 order.status = \"WAIT_PAYMENT\"elif action == \"reject\": # 拒单 reason = req_data.get(\"reason\") if not reason: return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") order.status = \"REJECTED\" order.comment = reason step9 将订单修改后的对象提交到数据库 1234567try: db.session.add(order) db.session.commit()except Exception as e: current_app.logger.error(e) db.session.rollback() return jsonify(errno=RET.DBERR, errmsg=\"操作失败\") step10 返回正确响应，因为接口逻辑是在数据库的修改以及查询，所以不需要向前端返回数据 1return jsonify(errno=RET.OK, errmsg=\"OK\") 七丶订单模块（客户订单）前端编写以及接口测试1.在客户订单页lorders.js中进行如下编写 step1 查询房东的订单 1234567$.get(\"/api/v1.0/user/orders?role=landlord\", function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\".orders-list\").html(template(\"orders-list-tmpl\", &#123;orders:resp.data.orders&#125;)); $(\".order-accept\").on(\"click\", function()&#123; var orderId = $(this).parents(\"li\").attr(\"order-id\"); $(\".modal-accept\").attr(\"order-id\", orderId); &#125;); step2 接单处理 1234567891011121314151617181920212223242526$(\".modal-accept\").on(\"click\", function()&#123; var orderId = $(this).attr(\"order-id\"); $.ajax(&#123; url:\"/api/v1.0/orders/\"+orderId+\"/status\", type:\"PUT\", data:'&#123;\"action\":\"accept\"&#125;', contentType:\"application/json\", dataType:\"json\", headers:&#123; \"X-CSRFTOKEN\":getCookie(\"csrf_token\"), &#125;, success:function (resp) &#123; if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; $(\".orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-content&gt;div.order-text&gt;ul li:eq(4)&gt;span\").html(\"已接单\"); $(\"ul.orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-title&gt;div.order-operate\").hide(); $(\"#accept-modal\").modal(\"hide\"); &#125; &#125; &#125;) &#125;); $(\".order-reject\").on(\"click\", function()&#123; var orderId = $(this).parents(\"li\").attr(\"order-id\"); $(\".modal-reject\").attr(\"order-id\", orderId); &#125;); step3 拒单处理 12345678910111213141516171819202122232425262728$(\".modal-reject\").on(\"click\", function()&#123; var orderId = $(this).attr(\"order-id\"); var reject_reason = $(\"#reject-reason\").val(); if (!reject_reason) return; var data = &#123; action: \"reject\", reason:reject_reason &#125;; $.ajax(&#123; url:\"/api/v1.0/orders/\"+orderId+\"/status\", type:\"PUT\", data:JSON.stringify(data), contentType:\"application/json\", headers: &#123; \"X-CSRFTOKEN\":getCookie(\"csrf_token\") &#125;, dataType:\"json\", success:function (resp) &#123; if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; $(\".orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-content&gt;div.order-text&gt;ul li:eq(4)&gt;span\").html(\"已拒单\"); $(\"ul.orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-title&gt;div.order-operate\").hide(); $(\"#reject-modal\").modal(\"hide\"); &#125; &#125; &#125;);&#125;) 2.在lorders.html中进行如下编写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script id=\"orders-list-tmpl\" type=\"text/html\"&gt; &#123;&#123;if orders&#125;&#125; &#123;&#123;each orders as order&#125;&#125; &lt;li order-id=&#123;&#123;order.order_id&#125;&#125;&gt; &lt;div class=\"order-title\"&gt; &lt;h3&gt;订单编号：&#123;&#123;order.order_id&#125;&#125;&lt;/h3&gt; &#123;&#123; if \"WAIT_ACCEPT\" == order.status &#125;&#125; &lt;div class=\"fr order-operate\"&gt; &lt;button type=\"button\" class=\"btn btn-success order-accept\" data-toggle=\"modal\" data-target=\"#accept-modal\"&gt;接单&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-danger order-reject\" data-toggle=\"modal\" data-target=\"#reject-modal\"&gt;拒单&lt;/button&gt; &lt;/div&gt; &#123;&#123;/if&#125;&#125; &lt;/div&gt; &lt;div class=\"order-content\"&gt; &lt;img src=\"&#123;&#123;order.img_url&#125;&#125;\"&gt; &lt;div class=\"order-text\"&gt; &lt;h3&gt;&#123;&#123;order.title&#125;&#125;&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;创建时间：&#123;&#123;order.ctime&#125;&#125;&lt;/li&gt; &lt;li&gt;入住日期：&#123;&#123;order.start_date&#125;&#125;&lt;/li&gt; &lt;li&gt;离开日期：&#123;&#123;order.end_date&#125;&#125;&lt;/li&gt; &lt;li&gt;合计金额：￥&#123;&#123;(order.amount/100.0).toFixed(0)&#125;&#125;(共&#123;&#123;order.days&#125;&#125;晚)&lt;/li&gt; &lt;li&gt;订单状态： &lt;span&gt; &#123;&#123;if \"WAIT_ACCEPT\" == order.status&#125;&#125; 待接单 &#123;&#123;else if \"WAIT_COMMENT\" == order.status&#125;&#125; 待评价 &#123;&#123;else if \"COMPLETE\" == order.status&#125;&#125; 已完成 &#123;&#123;else if \"REJECTED\" == order.status&#125;&#125; 已拒单 &#123;&#123;/if&#125;&#125; &lt;/span&gt; &lt;/li&gt; &#123;&#123;if \"COMPLETE\" == order.status&#125;&#125; &lt;li&gt;我的评价： &#123;&#123;order.comment&#125;&#125;&lt;/li&gt; &#123;&#123;else if \"REJECTED\" == order.status&#125;&#125; &lt;li&gt;拒单原因： &#123;&#123;order.comment&#125;&#125;&lt;/li&gt; &#123;&#123;/if&#125;&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125; &#123;&#123;else&#125;&#125; 暂时没有订单。 &#123;&#123;/if&#125;&#125;&lt;/script&gt; 3.测试 step1 使用18033333333（张三）账号进行此接口测试，账号登录后进入客户订单，成功显示客户预定了我发布的房屋列表信息 step2 查询数据库ih_order_info订单表，验证是否有4张客户订单，结果显示正确，需要注意的是这里的user_id指的是哪个账号预定的，通过user_id发现用户id为3的用户预定了三间，而用户id为8的预定了一间 step3 查看数据库ih_user_profile表，查看是user_id =3 和 8 的是哪个账号 step4 分别登录这两个账号，进入我的订单，如果订单详情和张三客户订单一样，说明代码逻辑完全没问题，左图为Hellotaogang账户，右图为taogang123账户 step5 接单功能接口测试，切换18033333333（张三）账号，进入客户订单，选择订单编号为1的订单，点击接单出现提示信息（左图），点击确定接单后，则在客户订单页中此编号的订单的状态即变成了已接单状态，而在前端中此订单不在显示出接单和拒单功能按钮，说明代码逻辑正确 step6 拒单功能接口测试，选择订单编号为3的订单进行测试，当点击拒单时，必须要填写原因（左图），然后点击确定后，则该订单状态为已拒绝，说明代码逻辑没问题 step7 查看数据库订单状态信息，状态为WAIT_PAYMENT的表示已接单，REJECTED表示已拒单，填写的拒单原因存到comment评论字段，证明代码逻辑完全没问题 step8 切换到到18022222222（Hellotaogang）客户账号，进入我的订单中，查看18033333333（张三）房东对于订单的接单以及拒单情况，对于只有房东接单的订单才会出现去支付的功能按钮，因为该接口还没有写，所以在这里不进行演示，显示信息与上面测试结果一样，代码逻辑正确 八丶订单评价后端接口编写1.分析：因为订单评价接口和接单拒单功能接口一样，也是对数据库进行修改操作，所以在定义接口路由的时候请求方式也是选择的是PUT，本来订单评价接口是在支付接口后面才去写的，但因为此接口与拒单接单接口大同小异，所以便一块接着客户订单接口在orders.py中一起写了，需要注意的时这个接口是在订单状态变成待评价时，才能触发这个功能接口进行评价 2.逻辑编写 step1 定义路由接口 12345@api.route(\"/orders/&lt;int:order_id&gt;/comment\", methods=[\"PUT\"])@login_requireddef save_order_comment(order_id): \"\"\"保存订单评价信息\"\"\" pass step2 获取用户id 1user_id = g.user_id step3 获取请求参数中的评价信息 12req_data = request.get_json()comment = req_data.get(\"comment\") step4 校验参数 12if not comment: return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") step5 确保用户只能评价自己的订单并且订单处于待评价的状态 123456try: order = Order.query.filter(Order.id == order_id, Order.user_id == user_id, Order.status == \"WAIT_COMMENT\").first() house = order.houseexcept Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"无法获取订单数据\") step6 查询的订单对象order不存在，则返回错误信息 12if not order: return jsonify(errno=RET.REQERR, errmsg=\"操作无效\") step7 构建订单参数，并提交到数据库中 1234567891011121314try: # 将订单的状态设置为已完成 order.status = \"COMPLETE\" # 保存订单的评价信息 order.comment = comment # 将房屋的完成订单数增加1 house.order_count += 1 db.session.add(order) db.session.add(house) db.session.commit()except Exception as e: current_app.logger.error(e) db.session.rollback() return jsonify(errno=RET.DBERR, errmsg=\"操作失败\") step8 因为在房屋详情中有会显示订单的评价信息，为了在房屋详情中显示最新的评价信息，所以需要删除redis中该订单对应的房屋的信息，并返回正确响应 123456try: redis_store.delete(\"house_info_%s\" % order.house.id)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.OK, errmsg=\"OK\") 3.在order.js中补充处理评论的逻辑 12345678910111213141516171819$.ajax(&#123; url:\"/api/v1.0/orders/\"+orderId+\"/comment\", type:\"PUT\", data:JSON.stringify(data), contentType:\"application/json\", dataType:\"json\", headers:&#123; \"X-CSRFTOKEN\":getCookie(\"csrf_token\"), &#125;, success:function (resp) &#123; if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; $(\".orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-content&gt;div.order-text&gt;ul li:eq(4)&gt;span\").html(\"已完成\"); $(\"ul.orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-title&gt;div.order-operate\").hide(); $(\"#comment-modal\").modal(\"hide\"); &#125; &#125;&#125;); 注：此接口在客户支付订单后，订单状态变成待评价时，才能进行测试 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/86660480","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之手机端租房网站的实战开发（十二）","slug":"Flask项目之手机端租房网站的实战开发（十二）","date":"2019-11-05T04:08:13.660Z","updated":"2019-11-13T12:59:02.278Z","comments":true,"path":"2019/11/05/Flask项目之手机端租房网站的实战开发（十二）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/05/Flask项目之手机端租房网站的实战开发（十二）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶房源列表页后端编写 二丶房源列表页缓存处理 三丶redis中pipeline（管道）的使用 四丶房源列表页前端编写 五丶搜索条件测试","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶房源列表页后端编写 二丶房源列表页缓存处理 三丶redis中pipeline（管道）的使用 四丶房源列表页前端编写 五丶搜索条件测试 一丶房源列表页后端编写1.搜索条件分析：用户在主页页面中点击搜索按钮，即跳转到房源列表页面，需要注意的是，第一用户在不选择任何搜索条件下，点击搜索按钮跳转到的房源列表页，此房源页显示的房屋列表应该是采用默认排序，将所有的房屋信息显示出来；第二用户还可以只选择某一个搜索条件（比如区县或者入住日期）；第三就是用户选择区县以及入住日期，那么在房源列表页则根据用户的搜索条件进行显示 ) 2.入住日期分析：最开始在项目中创建数据库模型类models.py文件中，在House房屋类并未定义入住时间，而是在Order订单类中定义了预定起始以及结束时间，因为在一个房屋可以被多次入住，所以放到House类中显然不合适，而放在Order订单类中 ，是因为一旦订单中出现了该房屋的入住时间，那么代表该房屋其余时间都是可以被用户搜索到并预定下单 3.接口逻辑编写 step1 定义视图函数，需要构建请求地址 12345# /api/v1.0/houses?sd=2019-01-23&amp;ed=2019-01-31&amp;aid=3&amp;sk=new&amp;p=1@api.route(\"/houses\")def get_house_list(): \"\"\"房源页房屋列表信息\"\"\" pass step2 获取请求参数 12345start_date = request.args.get(\"sd\") # 用户入住日期end_date = request.args.get(\"ed\") # 用户离开日期area_id = request.args.get(\"aid\") # 入住区县sort_key = request.args.get(\"sk\", \"new\") # 排序关键字,当未选择排序条件时，默认按最新排序，这个new关键字根据前端定义走的page = request.args.get(\"p\") # 页数 step3 处理日期 用户可能选择入住日期或者是离开日期，所以要一一进行判断 123456789101112try: if start_date: start_date = datetime.strptime(start_date, \"%Y-%m-%d\") if end_date: end_date = datetime.strptime(end_date, \"%Y-%m-%d\") # 当用户两者都选择情况下，需要进行判断，入住日期肯定是小于或等于离开日期的 if start_date and end_date: assert start_date &lt;= end_dateexcept Exception as e: current_app.logger.error(e) return jsonify(errno=RET.PARAMERR, errmsg=\"日期参数有误\") step4 判断区县id 123456if area_id: try: area = Area.query.get(area_id) except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.PARAMERR, errmsg=\"区县参数有误\") step5 处理页数 123456try: page = int(page)except Exception as e: # 如果出现异常则使page=1 page = 1 current_app.logger.error(e) step6 定义过滤条件的参数列表容器以及存放冲突订单对象 12filter_params = []conflict_orders = None step7 在数据库中查询订单表中的冲突订单，这里稍微比较绕，就是以什么条件来筛选订单中冲突的订单，其实简单一句就是用户不管选择的入住日期或者是离开日期又或者是入住以及离开日期，这三种情况中任一情况的日期都不能在Order表中订单起始日期begin_date与end_date结束日期这范围内，即作出以下逻辑判断 12345678910111213try: if start_date and end_date: # 查询冲突的订单所有对象 conflict_orders = Order.query.filter(Order.begin_date &lt;= end_date, Order.end_date &gt;= start_date).all() elif start_date: # 用户只选择入住日期 conflict_orders = Order.query.filter(Order.end_date &gt;= start_date).all() elif end_date: # 用户只选择离开日期 conflict_orders = Order.query.filter(Order.begin_date &lt;= end_date).all()except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"数据库异常\") step8 当获取的冲突订单对象存在时，获取冲突房屋的id，如果冲突的房屋id不为空，则向查询参数中添加条件 1234567if conflict_orders: # 从订单中获取冲突的房屋id conflict_house_ids = [order.house_id for order in conflict_orders] # 使用列表生成式进行简写操作 # 如果冲突的房屋id不为空，向查询参数中添加条件 if conflict_house_ids: filter_params.append(House.id.notin_(conflict_house_ids)) step9 当区县id存在时，向列表中添加条件，这个条件House.area_id == area_id返回的不是True或者是False而是返回的是SQLALchemy表达式，所以才能在filter方法中进行过滤 12if area_id: filter_params.append(House.area_id == area_id) step10 根据过滤参数列表，查询数据库，并进行条件排序 123456789if sort_key == \"booking\": # 入住做多 house_query = House.query.filter(*filter_params).order_by(House.order_count.desc())elif sort_key == \"price-inc\": # 价格低-高 house_query = House.query.filter(*filter_params).order_by(House.price.asc())elif sort_key == \"price-des\": # 价格高-低 house_query = House.query.filter(*filter_params).order_by(House.price.desc())else: # 如果用户什么都没选择，则按照最新排序（数据库字段创建时间） house_query = House.query.filter(*filter_params).order_by(House.create_time.desc()) step11 分页处理 paginate方法需传递三个参数，page:分页页数 per_page:每页显示多少条数据 error_out: 错误输出 12345try: page_obj = house_query.paginate(page=page, per_page=constants.HOUSE_LIST_PAGE_CAPACITY, error_out=False)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"数据库异常\") step12 获取分页页面数据 1234houses = []house_list = page_obj.itemsfor house in house_list: houses.append(house.to_basic_dict()) step13 获取总页数，并返回正确响应数据 12total_page = page_obj.pagesreturn jsonify(errno=RET.OK, errmsg=\"OK\", data=&#123;\"houses\":houses, \"total_page\":total_page, \"current_page\":page&#125;) 4.测试此接口 step1 在Postman工具中向127.0.0.1:5000/api/v1.0/houses接口发送请求，注意该请求未携带任何参数，后端接口逻辑分页设定每页显示2条数据，总页数为4页，说明数据库中房屋数据为7条或者8条 step2 查看数据库房屋信息表，房屋数据为7条，后端分页逻辑正确 step3 为了进行搜索条件测试，博主这里进行发布一套房源，详情如下 step4 点击发布房源，并上传图片，此时再查看数据库则显示刚发布的房屋信息了 step5 向127.0.0.1:5000/api/v1.0/houses接口发送请求，并携带搜索条件参数，按价格从低到高进行筛选 step6 向127.0.0.1:5000/api/v1.0/houses接口发送请求，并携带参数在第3页价格从低到高，因博主之前测试，除了今天发布的房源不同于其他7条数据，之前的7条数据价格都是一样的，所以这里走个过程，但逻辑是没问题的 step7 当发送请求参数中不存在的页数5时，则后端返回一个空列表 二丶房源列表页缓存处理1.分析，为什么添加缓存处理，因为可能会出现不同的用户在进行房源条件搜索时，出现条件相同，所以需要进行页面数据缓存处理 2.具体实现 step1 需要将页面数据以hash类型存到redis数据库 123456\"house_入住_离开_区域id_排序条件\": hash&#123; \"page\": \"&#123;&#125;\" \"1\": \"&#123;&#125;\", \"2\": \"&#123;&#125;\",&#125; step2 将响应数据构建成json格式数据 12resp_dict = dict(errno=RET.OK, errmsg=\"OK\", data=&#123;\"houses\":houses, \"total_page\":total_page, \"current_page\":page&#125;)resp_json = json.dumps(resp_dict) step3 设置redis数据库的key 1redis_key = \"house_%s_%s_%s_%s\" % (start_date, end_date, area_id, sort_key) step4 设置缓存数据 12345try: redis_store.hset(redis_key, page, resp_json) # 将数据存入redis数据 redis_store.expire(redis_key, constants.HOUES_LIST_PAGE_REDIS_CACHE_EXPIRES) # 设置有效期except Exception as e: current_app.logger.error(e) step5 返回正确响应数据 1return resp_json, 200, &#123;\"Content-Type\": \"application/json\"&#125; step6 设置获取参数的默认值，因为需要在数据刚开始需要去数据库获取缓存数据，所以给参数设置默认值，防止查询出错 123start_date = request.args.get(\"sd\", \"\") # 用户入住日期end_date = request.args.get(\"ed\", \"\") # 用户离开日期area_id = request.args.get(\"aid\", \"\") # 入住区县 step7 在接口函数处理完请求完数据时，此时需在数据库从获取缓存数据，使用hget方法获取存入数据的hash类型数据，page为hash数据中的键，当查询获取的json响应数据不为空时，则将该数据进行返回，如果出现异常或者查询数据不存在时，则进入mysql数据库数据查询，设置缓存，以及返回正确响应逻辑操作 123456789redis_key = \"house_%s_%s_%s_%s\" % (start_date, end_date, area_id, sort_key) try: resp_json = redis_store.hget(redis_key, page)except Exception as e: current_app.logger.error(e)else: if resp_json: return resp_json, 200, &#123;\"Content-Type\":\"application/json\"&#125; 3.测试 step1 打开Postman测试工具向127.0.0.1:5000/api/v1.0/houses发送数据，不携带任何参数，此时在工具中返回了正确响应以及数据，第一个箭头表示当前页码，第二个箭头表示总页数 step2 查看redis数据库，因为向接口发送请求时，为携带任何参数，而当初在接口函数中获取请求参数时，设置了默认值为空字符串，所以这里看的key为house____new，通过hget方式获取house____new键page为1的数据 step3 在Postman工具中设置请求参数p=2,，即获取第二页的数据 step4 此时在redis数据库中通过hgetall house____new，查看该键所有数据，此时显示数据出现了第一页和第二页数据 step5 房屋信息数据一共只有8条数据，每页显示2条数据，则总页数为4页，当发送请求参数p=5时，那么编写的逻辑也会把这个不存在的数据存到redis数据库 step6 经查看redis数据库发现，获取到的第5页空数据，也存到了数据库，这可是我不想要的 4.修改代码逻辑，在设置数据缓存的时候进行判断如果current_page &lt;= total_page，然后才设置数据缓存 1234567if page &lt;= total_page: # 设置缓存数据 try: redis_store.hset(redis_key, page, resp_json) # 将数据存入redis数据 redis_store.expire(redis_key, constants.HOUES_LIST_PAGE_REDIS_CACHE_EXPIRES) # 设置有效期 except Exception as e: current_app.logger.error(e) 三丶redis中pipeline（管道）的使用1.为什么使用pipeline，因为我们在设置缓存数据时，使用hash类型进行数据的存储，而不是像之前写的接口的数据缓存那样使用的是str类型存储，所以没有一步到位的存入数据以及有效期的设置放到一块，hash没有setex方法，设想如果将数据存入到redis数据库成功，而expire设置有效期时未成功，那么此数据就变成了永久有效，即使用pipeline是可取的 2.具体实现如下 123456789# 创建redis pipeline 管道对象，可以一次性执行多条语句pipeline = redis_store.pipeline()# 开启多个语句的记录pipeline.multi()# 使用管道对象管理多条语句pipeline.hset(redis_key, page, resp_json) # 将数据存入redis数据pipeline.expire(redis_key, constants.HOUES_LIST_PAGE_REDIS_CACHE_EXPIRES) # 设置有效期# 执行语句pipeline.execute() 四丶房源列表页前端编写1.在房源页面search.js中进行编写 step1 构建js代码中所用到的全局变量 1234var cur_page = 1; // 当前页var next_page = 1; // 下一页var total_page = 1; // 总页数var house_data_querying = true; // 是否正在向后台获取数据 step2 定义decodeQuery函数用于解析url中的查询字符串 12345678function decodeQuery()&#123; var search = decodeURI(document.location.search); return search.replace(/(^\\?)/, '').split('&amp;').reduce(function(result, item)&#123; values = item.split('='); result[values[0]] = values[1]; return result; &#125;, &#123;&#125;);&#125; step3 定义updateFilterDateDisplay函数用于更新用户点选的筛选条件 1234567891011function updateFilterDateDisplay() &#123; var startDate = $(\"#start-date\").val(); var endDate = $(\"#end-date\").val(); var $filterDateTitle = $(\".filter-title-bar&gt;.filter-title\").eq(0).children(\"span\").eq(0); if (startDate) &#123; var text = startDate.substr(5) + \"/\" + endDate.substr(5); $filterDateTitle.html(text); &#125; else &#123; $filterDateTitle.html(\"入住日期\"); &#125;&#125; step4 定义updateHouseData函数用于更新房源列表信息 12345678910111213141516171819202122232425262728293031function updateHouseData(action) &#123; var areaId = $(\".filter-area&gt;li.active\").attr(\"area-id\"); if (undefined == areaId) areaId = \"\"; var startDate = $(\"#start-date\").val(); var endDate = $(\"#end-date\").val(); var sortKey = $(\".filter-sort&gt;li.active\").attr(\"sort-key\"); var params = &#123; aid:areaId, sd:startDate, ed:endDate, sk:sortKey, p:next_page &#125;; $.get(\"/api/v1.0/houses\", params, function(resp)&#123; house_data_querying = false; if (\"0\" == resp.errno) &#123; if (0 == resp.data.total_page) &#123; $(\".house-list\").html(\"暂时没有符合您查询的房屋信息。\"); &#125; else &#123; total_page = resp.data.total_page; if (\"renew\" == action) &#123; cur_page = 1; $(\".house-list\").html(template(\"house-list-tmpl\", &#123;houses:resp.data.houses&#125;)); &#125; else &#123; cur_page = next_page; $(\".house-list\").append(template(\"house-list-tmpl\", &#123;houses: resp.data.houses&#125;)); &#125; &#125; &#125; &#125;)&#125; step5 在页面加载时获取筛选条件中的城市区域信息 1234567891011121314151617181920212223$.get(\"/api/v1.0/areas\", function(data)&#123; if (\"0\" == data.errno) &#123; // 用户从首页跳转到这个搜索页面时可能选择了区县，所以尝试从url的查询字符串参数中提取用户选择的区县 var areaId = queryData[\"aid\"]; // 如果提取到了区县id的数据 if (areaId) &#123; // 遍历从后端获取到的区县信息，添加到页面中 for (var i=0; i&lt;data.data.length; i++) &#123; // 对于从url查询字符串参数中拿到的区县，在页面中做高亮展示 // 后端获取到区县id是整型，从url参数中获取到的是字符串类型，所以将url参数中获取到的转换为整型，再进行对比 areaId = parseInt(areaId); if (data.data[i].aid == areaId) &#123; $(\".filter-area\").append('&lt;li area-id=\"'+ data.data[i].aid+'\" class=\"active\"&gt;'+ data.data[i].aname+'&lt;/li&gt;'); &#125; else &#123; $(\".filter-area\").append('&lt;li area-id=\"'+ data.data[i].aid+'\"&gt;'+ data.data[i].aname+'&lt;/li&gt;'); &#125; &#125; &#125; else &#123; // 如果url参数中没有区县信息，不需要做额外处理，直接遍历展示到页面中 for (var i=0; i&lt;data.data.length; i++) &#123; $(\".filter-area\").append('&lt;li area-id=\"'+ data.data[i].aid+'\"&gt;'+ data.data[i].aname+'&lt;/li&gt;'); &#125; &#125; step6 在页面添加好城区选项信息后，更新展示房屋列表信息 1updateHouseData(\"renew\"); step7 获取页面显示窗口的高度 1var windowHeight = $(window).height(); step8 为窗口的滚动添加事件函数 12345678910111213141516171819202122window.οnscrοll=function()&#123; // var a = document.documentElement.scrollTop==0? document.body.clientHeight : document.documentElement.clientHeight; var b = document.documentElement.scrollTop==0? document.body.scrollTop : document.documentElement.scrollTop; var c = document.documentElement.scrollTop==0? document.body.scrollHeight : document.documentElement.scrollHeight; // 如果滚动到接近窗口底部 if(c-b&lt;windowHeight+50)&#123; // 如果没有正在向后端发送查询房屋列表信息的请求 if (!house_data_querying) &#123; // 将正在向后端查询房屋列表信息的标志设置为真， house_data_querying = true; // 如果当前页面数还没到达总页数 if(cur_page &lt; total_page) &#123; // 将要查询的页数设置为当前页数加1 next_page = cur_page + 1; // 向后端发送请求，查询下一页房屋数据 updateHouseData(); &#125; else &#123; house_data_querying = false; &#125; &#125; &#125; &#125; 2.在search.html中定义模板 123456789101112131415&lt;script id=\"house-list-tmpl\" type=\"text/html\"&gt; &#123;&#123;each houses as house&#125;&#125; &lt;li class=\"house-item\"&gt; &lt;a href=\"/detail.html?id=&#123;&#123;house.house_id&#125;&#125;\"&gt;&lt;img src=\"&#123;&#123;house.img_url&#125;&#125;\"&gt;&lt;/a&gt; &lt;div class=\"house-desc\"&gt; &lt;div class=\"landlord-pic\"&gt;&lt;img src=\"&#123;&#123;house.user_avatar&#125;&#125;\"&gt;&lt;/div&gt; &lt;div class=\"house-price\"&gt;￥&lt;span&gt;&#123;&#123;(house.price/100.0).toFixed(0)&#125;&#125;&lt;/span&gt;/晚&lt;/div&gt; &lt;div class=\"house-intro\"&gt; &lt;span class=\"house-title\"&gt;&#123;&#123;house.title&#125;&#125;&lt;/span&gt; &lt;em&gt;出租&#123;&#123;house.room_count&#125;&#125;间 - &#123;&#123;house.order_count&#125;&#125;次入住 - &#123;&#123;house.address&#125;&#125;&lt;/em&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/script&gt; 五丶搜索条件测试1.用户选择不同的区域信息，显示出对应区域下的房屋列表信息 step1 之前在测试接口的时候，导致有些房屋没有上传图片，所以这里在后台数据库进行补充 step2 查看当前18022222222账号的发布的房源列表 step3 查看主页中显示的房屋图片，此时应该是按最初开发需求那样在主页显示5张房屋logo图片 step4 为了方便主页搜索接口测试，所以这里使用18033333333（张三） 账号进行其他区县房源发布 step5 查看数据库房屋信息，一共有18套房屋包括（成都主城区） step6 在主页选择锦江区，搜索界面如下（右边没完全显示因为截图工具原因），每页显示2个房屋信息，当滚动鼠标时，触发js函数，向后端接口获取第二页数据，依次类推 ) step7 在如上搜索页面，选择青羊区以及金牛区，查看该区域下的房屋列表 ) step8 在如上搜索页面，选择武侯区以及成华区 ，查看该区域下的房屋列表 ) 2.根据用户选择的入住以及离开日期，显示出对应时间下的房屋列表信息 step1 以锦江区为例进行测试（左边图为未选择时间条件，右边图为选择时间条件），可以发现当选择了入住时间以及离开时间后，所对应条件的房屋列表并未发生任何改变，原因是现在所有的房屋都是未被入住，所以在后端接口中未有冲突订单，即房源列表显示一样，此测试等待订单接口写完后，再进行测试 ) step2 当在页面滚动鼠标时，则向接口发送请求数据，期间根据用户鼠标滚动的浮动来决定p为多少 2.根据用户选择排序关键字，显示对应的房源列表信息 说明：首先默认排序为最新上线，这个不用进行测试，然后入住最多是按照订单量来排序，因订单接口还没写，所以也不用测试，这里只需要对价格进行排序 左图为按价格由低到高进行排序，右图为按价格由高到低进行排序 ) ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/86599482","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之手机端租房网站的实战开发（十一）","slug":"Flask项目之手机端租房网站的实战开发（十一）","date":"2019-11-05T03:42:13.457Z","updated":"2019-11-13T12:58:47.025Z","comments":true,"path":"2019/11/05/Flask项目之手机端租房网站的实战开发（十一）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/05/Flask项目之手机端租房网站的实战开发（十一）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶用户房屋管理后端编写 二丶用户房屋管理前端编写 三丶测试用户管理后端接口 四丶主页幻灯片房屋信息后端编写 五丶主页幻灯片房屋信息前端编写 六丶测试主页幻灯片接口和区县信息以及房屋信息缓存 七丶房屋详情页后端编写 八丶房屋详情页前端编写 九丶测试房屋详情页面显示正确数据是否成功","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶用户房屋管理后端编写 二丶用户房屋管理前端编写 三丶测试用户管理后端接口 四丶主页幻灯片房屋信息后端编写 五丶主页幻灯片房屋信息前端编写 六丶测试主页幻灯片接口和区县信息以及房屋信息缓存 七丶房屋详情页后端编写 八丶房屋详情页前端编写 九丶测试房屋详情页面显示正确数据是否成功 一丶用户房屋管理后端编写1.需求分析：在我的房源界面显示出房东发布的房源信息，在前端中就需要从后端接口中发送获取用户id，房屋标题，图片以及房屋信息，显示在前端页面中 2.逻辑编写 step1 在houses.py中定义接口 12345678@api.route(\"/user/houses\", methods=[\"GET\"])@login_requireddef get_user_houses(): \"\"\" 获取房东发布的房源信息 :return: \"\"\" pass step2 获取用户id 1user_id = g.user_id step3 通过用户id从数据库USER中获取用户对象，通过user对象来获取用户发布的房屋 123456try: user = User.query.get(user_id) houses = user.housesexcept Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"获取数据失败\") step4 在models.py中house里面定义一个to_basic_dict方法，将房屋基本信息转换成字典数据 123456789101112131415def to_basic_dict(self): \"\"\"将基本信息转换为字典数据\"\"\" house_dict = &#123; \"house_id\": self.id, \"title\": self.title, \"price\": self.price, \"area_name\": self.area.name, \"img_url\": constants.QINIU_URL_DOMAIN + self.index_image_url if self.index_image_url else \"\", \"room_count\": self.room_count, \"order_count\": self.order_count, \"address\": self.address, \"user_avatar\": constants.QINIU_URL_DOMAIN + self.user.avatar_url if self.user.avatar_url else \"\", \"ctime\": self.create_time.strftime(\"%Y-%m-%d\") &#125; return house_dict step5 将查询到的房屋信息转换成字典数据，添加到定义的houses_list列表中 123houses_list = []for house in houses: houses_list.append(house.to_basic_dict()) step6 最后返回正确响应数据 1return jsonify(errno=RET.OK, errmsg=\"OK\", data=&#123;\"houses\":houses_list&#125;) 二丶用户房屋管理前端编写1.在myhouse.js中通过get请求方式向后端接口发送请求，通过后端返回的正确响应以及data数据，传到前端html中的template模本进行数据显示，如下编写 1234567$.get(\"/api/v1.0/user/houses\", function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\"#houses-list\").html(template(\"houses-list-tmpl\", &#123;houses:resp.data.houses&#125;)); &#125; else &#123; $(\"#houses-list\").html(template(\"houses-list-tmpl\", &#123;houses:[]&#125;)); &#125; &#125;); 2.引入template.js模板，在my.html中进行如下编写 1234567891011121314151617181920212223242526&lt;script id=\"houses-list-tmpl\" type=\"text/html\"&gt; &lt;li&gt; &lt;div class=\"new-house\"&gt; &lt;a href=\"/newhouse.html\"&gt;发布新房源&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &#123;&#123;each houses as house&#125;&#125; &lt;li&gt; &lt;a href=\"/detail.html?id=&#123;&#123;house.house_id&#125;&#125;\"&gt; &lt;div class=\"house-title\"&gt; &lt;h3&gt;房屋ID:&#123;&#123;house.house_id&#125;&#125; —— &#123;&#123;house.title&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"house-content\"&gt; &lt;img src=\"&#123;&#123;house.img_url&#125;&#125;\"&gt; &lt;div class=\"house-text\"&gt; &lt;ul&gt; &lt;li&gt;位于：&#123;&#123;house.area_name&#125;&#125;&lt;/li&gt; &lt;li&gt;价格：￥&#123;&#123;(house.price/100.0).toFixed(0)&#125;&#125;/晚&lt;/li&gt; &lt;li&gt;发布时间：&#123;&#123;house.ctime&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/script&gt; 三丶测试用户管理后端接口1.之前在编写发布房源接口时，已经发布过房源信息了，所以当进入我的房源页面时，就会向后端接口发送请求，获取房源数据，显示在页面上，如下图所示 2.查看数据库房屋信息表ih_house_info 四丶主页幻灯片房屋信息后端编写1.分析：首先主页幻灯片上显示的房屋信息，需要在后端定义一个接口，在这个接口中我们需要在数据库中将房屋订单数目最多的5条数据查询出来，展示到主页上，这个需求也是刚开始开发项目的需求，因为主页时用户大量访问的，所以这5条数据需要缓存到redis数据库中，减少我们对数据库的查询 2.逻辑编写(具体实现) step1 定义视图函数，此接口因为是在主页所以不需要用户登录验证 1234567@api.route(\"/houses/index\", methods=[\"GET\"])def get_house_index(): \"\"\" 获取主页幻灯片房屋信息 :return: \"\"\" pass step2 查询数据库获取房屋订单数目最多的5条数据 123456try: # 查询房屋订单倒序排序并显示5条 houses = House.query.order_by(House.order_count.desc()).limit(constants.HOME_PAGE_MAX_HOUSES)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"查询数据失败\") step3 判断数据是否存在,不存在则返回异常错误信息 12if not houses: return jsonify(errno=RET.NODATA, errmsg=\"无相关数据\") step4 将查询到的房屋信息转换成字典数据，添加到定义的houses_list列表中，如过房屋未设置主图片，则跳过 12345houses_list = []for house in houses: if not house.index_image_url: continue houses_list.append(house.to_basic_dict()) step5 将列表数据转换从json格式的数据，并存到redis数据库中 12345try: json_houses = json.dumps(houses_list) redis_store.setex(\"home_page_data\", constants.HOME_PAGE_DATA_REDIS_EXPIRES, json_houses)except Exception as e: current_app.logger.error(e) step6 返回正确响应数据 1return '&#123;\"errno\":\"0\", \"errmsg\":\"OK\", \"data\":%s&#125;' % json_houses, 200, &#123;\"Content-Type\":\"application/json\"&#125; step7 因为第一次是不存在缓存数据的，所以我们在进入函数时，就先从redis中拿取数据 12345try: ret = redis_store.get(\"home_page_data\")except Exception as e: current_app.logger.error(e) ret = None step8 此时需要对获取数据进行判断，当获取数据结果不为空时，则返回给前端正确响应数据，不存在时else就在数据库中进行数据查询，再将查询结果写入到redis数据库 12345678910111213# 当ret获取数据结果不为空时，则返回给前端正确响应数据，不存在时else就在数据库中进行数据查询，再将查询结果写入到redis数据库if ret: current_app.logger.info(\"house index info from redis\") # 因为redis中保存的是json字符串，所以直接进行字符串拼接返回 return '&#123;\"errno\":0, \"errmsg\":\"OK\", \"data\":%s&#125;' % ret, 200, &#123;\"Content-Type\": \"application/json\"&#125;else: # 查询数据库获取房屋订单数目最多的5条数据 try: # 查询房屋订单倒序排序并显示5条 houses = House.query.order_by(House.order_count.desc()).limit(constants.HOME_PAGE_MAX_HOUSES) except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"查询数据失败\") 五丶主页幻灯片房屋信息前端编写1.在主页前端index.js中，需要向后端接口发送请求来获取主页幻灯片要展示的房屋信息 123456789101112131415// 获取幻灯片要展示的房屋基本信息$.get(\"/api/v1.0/houses/index\", function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\".swiper-wrapper\").html(template(\"swiper-houses-tmpl\", &#123;houses:resp.data&#125;)); // 设置幻灯片对象，开启幻灯片滚动 var mySwiper = new Swiper ('.swiper-container', &#123; loop: true, autoplay: 2000, autoplayDisableOnInteraction: false, pagination: '.swiper-pagination', paginationClickable: true &#125;); &#125;&#125;); 2.在主页页面中选择区县按钮块，需要从后端接口获取区县信息 123456789101112// 获取区县信息$.get(\"/api/v1.0/areas\", function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\".area-list\").html(template(\"area-list-tmpl\", &#123;areas:resp.data&#125;)); $(\".area-list a\").click(function(e)&#123; $(\"#area-btn\").html($(this).html()); $(\".search-btn\").attr(\"area-id\", $(this).attr(\"area-id\")); $(\".search-btn\").attr(\"area-name\", $(this).html()); $(\"#area-modal\").modal(\"hide\"); &#125;); &#125;&#125;); 3.在主页index.html中进行一个模板使用，将后端返回的响应数据显示在模板中，幻灯片部分如下 12345678&lt;script id=\"swiper-houses-tmpl\" type=\"text/html\"&gt; &#123;&#123;each houses as house&#125;&#125; &lt;div class=\"swiper-slide\"&gt; &lt;a href=\"/detail.html?id=&#123;&#123;house.house_id&#125;&#125;\"&gt;&lt;img src=\"&#123;&#123;house.img_url&#125;&#125;\"&gt;&lt;/a&gt; &lt;div class=\"slide-title\"&gt;&#123;&#123;house.title&#125;&#125;&lt;/div&gt; &lt;/div&gt; &#123;&#123;/each&#125;&#125;&lt;/script&gt; 4.在主页index.html中区县模板，编写如下 12345&lt;script id=\"area-list-tmpl\" type=\"text/html\"&gt;&#123;&#123;each areas as area&#125;&#125; &lt;a href=\"#\" area-id=\"&#123;&#123;area.aid&#125;&#125;\"&gt;&#123;&#123;area.aname&#125;&#125;&lt;/a&gt;&#123;&#123;/each&#125;&#125;&lt;/script&gt; 六丶测试主页幻灯片接口和区县信息以及房屋信息缓存1.幻灯片接口 2.区县信息显示 3.查看项目运行日志 4.此时查看数据库缓存 七丶房屋详情页后端编写1.分析：①在房屋详情页面，角色分为房东以及客户，当客户进入时对于前端页面来说需显示预定功能按钮，如是房东角色进入就不展示此功能按钮；②对于角色来说，那么就需要用到user_id了；③尝试从session中去获取用户id，如果存在，说明用户为登录状态，那么将用户id返回给前端，不存在返回user_id = -1 2.逻辑编写 step1 创建视图函数，需要前端给后端传递房屋id 12345678@api.route(\"/houses/&lt;int:house_id&gt;\", methods=[\"GET\"])def get_house_detail(house_id): \"\"\" 获取房屋详情 :param house_id: :return: \"\"\" pass step2 从session中尝试获取用户id,没有则赋值-1 1user_id = session.get(\"user_id\", \"-1\") step3 校验house_id, 不存在则返回错误信息提示 12if not house_id: return jsonify(errno=RET.PARAMERR, errmsg=\"参数缺失\") step4 通过house_id 查询数据库获取房屋对象 12345try: house = House.query.get(house_id)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"查询数据失败\") step5 判断对象是否存在 12if not house: return jsonify(errno=RET.NODATA, errmsg=\"房屋不存在\") step6 在models.py文件House类中定义to_full_dict方法，用作于将详细信息转换为字典数据；在这个方法里面需要将房屋图片，房屋设施以及评论信息，单独添加到列表中，最后在将该列表以值的方式保存到字典house_dict中 123456789101112131415161718192021222324252627282930313233343536373839404142434445def to_full_dict(self): \"\"\"将详细信息转换为字典数据\"\"\" house_dict = &#123; \"hid\": self.id, \"user_id\": self.user_id, \"user_name\": self.user.name, \"user_avatar\": constants.QINIU_URL_DOMAIN + self.user.avatar_url if self.user.avatar_url else \"\", \"title\": self.title, \"price\": self.price, \"address\": self.address, \"room_count\": self.room_count, \"acreage\": self.acreage, \"unit\": self.unit, \"capacity\": self.capacity, \"beds\": self.beds, \"deposit\": self.deposit, \"min_days\": self.min_days, \"max_days\": self.max_days, &#125; # 房屋图片 img_urls = [] for image in self.images: img_urls.append(constants.QINIU_URL_DOMAIN + image.url) house_dict[\"img_urls\"] = img_urls # 房屋设施 facilities = [] for facility in self.facilities: facilities.append(facility.id) house_dict[\"facilities\"] = facilities # 评论信息 comments = [] orders = Order.query.filter(Order.house_id == self.id, Order.status == \"COMPLETE\", Order.comment != None) \\ .order_by(Order.update_time.desc()).limit(constants.HOUSE_DETAIL_COMMENT_DISPLAY_COUNTS) for order in orders: comment = &#123; \"comment\": order.comment, # 评论的内容 \"user_name\": order.user.name if order.user.name != order.user.mobile else \"匿名用户\", # 发表评论的用户 \"ctime\": order.update_time.strftime(\"%Y-%m-%d %H:%M:%S\") # 评价的时间 &#125; comments.append(comment) house_dict[\"comments\"] = comments return house_dict step7 将查询到的房屋对象转换成字典 12345try: house_data = house.to_full_dict()except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DATAERR, errmsg=\"数据错误\") step8 将房屋详情数据转换成json格式的数据，并存到redis数据库中 12345json_houses = json.dumps(house_data)try: redis_store.setex(\"house_info_%s\" % house_id, constants.HOUSE_DETAIL_REDIS_EXPIRE_SECOND, json_houses)except Exception as e: current_app.logger.error(e) step9 构造响应数据, 并返回 12resp = '&#123;\"errno\":\"0\", \"errmsg\":\"OK\", \"data\":&#123;\"user_id\":%s, \"house\":%s&#125;&#125;' %(user_id, json_houses), 200, &#123;\"Content-Type\": \"application/json\"&#125; return resp step10 尝试从redis数据库中获取房屋详情信息, 出现异常则使ret为None，所以需要在进入函数后，那么需要从去数据库中获取房屋详情信息 12345try: ret = redis_store.get(\"house_info_%s\" % house_id)except Exception as e: current_app.logger.error(e) ret = None step11 对ret进行判断, 存在不为None 则直接返回正确响应数据即可 123if ret: current_app.logger.info(\"house info from redis\") return '&#123;\"errno\":\"0\", \"errmsg\":\"OK\", \"data\":&#123;\"user_id\":%s, \"house\":%s&#125;&#125;' % (user_id, ret), 200, &#123;\"Content-Type\": \"application/json\"&#125; 八丶房屋详情页前端编写1.在detail.js文件中 step1 定义decodeQuery函数，用作于解析提取url中的查询字符串参数 12345678function decodeQuery()&#123; var search = decodeURI(document.location.search); return search.replace(/(^\\?)/, '').split('&amp;').reduce(function(result, item)&#123; values = item.split('='); result[values[0]] = values[1]; return result; &#125;, &#123;&#125;);&#125; step2 在$(document).ready(function(){}回调函数中，获取详情页面要展示的房屋编号 12var queryData = decodeQuery();var houseId = queryData[\"id\"]; step3 获取房屋详细信息 12345678910111213141516171819$.get(\"/api/v1.0/houses/\" + houseId, function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\".swiper-container\").html(template(\"house-image-tmpl\", &#123;img_urls:resp.data.house.img_urls, price:resp.data.house.price&#125;)); $(\".detail-con\").html(template(\"house-detail-tmpl\", &#123;house:resp.data.house&#125;)); // resp.user_id为访问页面用户,resp.data.user_id为房东 if (resp.data.user_id != resp.data.house.user_id) &#123; $(\".book-house\").attr(\"href\", \"/booking.html?hid=\"+resp.data.house.hid); $(\".book-house\").show(); &#125; var mySwiper = new Swiper ('.swiper-container', &#123; loop: true, autoplay: 2000, autoplayDisableOnInteraction: false, pagination: '.swiper-pagination', paginationType: 'fraction' &#125;); &#125;&#125;) 2.在detail.html文件中 step1 房屋详情页面中幻灯片房屋信息编写如下 123456789&lt;script id=\"house-image-tmpl\" type=\"text/html\"&gt; &lt;ul class=\"swiper-wrapper\"&gt; &#123;&#123;each img_urls as img_url&#125;&#125; &lt;li class=\"swiper-slide\"&gt;&lt;img src=\"&#123;&#123;img_url&#125;&#125;\"&gt;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;div class=\"house-price\"&gt;￥&lt;span&gt;&#123;&#123;(price/100.0).toFixed(0)&#125;&#125;&lt;/span&gt;/晚&lt;/div&gt;&lt;/script&gt; step2 房屋标题，房屋地址，房屋详情，配套设施以及评价信息编写如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;script id=\"house-detail-tmpl\" type=\"text/html\"&gt; &lt;div class=\"detail-header layout-style\"&gt; &lt;h2 class=\"house-title\"&gt;&#123;&#123;house.title&#125;&#125;&lt;/h2&gt; &lt;div class=\"landlord-pic\"&gt;&lt;img src=\"&#123;&#123;house.user_avatar&#125;&#125;\"&gt;&lt;/div&gt; &lt;h2 class=\"landlord-name\"&gt;房东： &lt;span&gt;&#123;&#123;house.user_name&#125;&#125;&lt;/span&gt;&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"house-info layout-style\"&gt; &lt;h3&gt;房屋地址&lt;/h3&gt; &lt;ul class=\"house-info-list text-center\"&gt; &lt;li&gt;&#123;&#123;house.address&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;ul class=\"house-type layout-style\"&gt; &lt;li&gt; &lt;span class=\"icon-house\"&gt;&lt;/span&gt; &lt;div class=\"icon-text\"&gt; &lt;h3&gt;出租&#123;&#123;house.room_count&#125;&#125;间&lt;/h3&gt; &lt;p&gt;房屋面积:&#123;&#123;house.acreage&#125;&#125;平米&lt;/p&gt; &lt;p&gt;房屋户型:&#123;&#123;house.unit&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=\"icon-user\"&gt;&lt;/span&gt; &lt;div class=\"icon-text\"&gt; &lt;h3&gt;宜住&#123;&#123;house.capacity&#125;&#125;人&lt;/h3&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=\"icon-bed\"&gt;&lt;/span&gt; &lt;div class=\"icon-text\"&gt; &lt;h3&gt;卧床配置&lt;/h3&gt; &lt;p&gt;&#123;&#123;house.beds&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"house-info layout-style\"&gt; &lt;h3&gt;房间详情&lt;/h3&gt; &lt;ul class=\"house-info-list\"&gt; &lt;li&gt;收取押金&lt;span&gt;&#123;&#123;(house.deposit/100.0).toFixed(0)&#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;最少入住天数&lt;span&gt;&#123;&#123;house.min_days&#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;最多入住天数&lt;span&gt;&#123;&#123;if house.max_days==0&#125;&#125;无限制&#123;&#123;else&#125;&#125;&#123;&#123;house.max_days&#125;&#125;&#123;&#123;/if&#125;&#125;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"house-facility layout-style\"&gt; &lt;h3&gt;配套设施&lt;/h3&gt; &lt;ul class=\"house-facility-list clearfix\"&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(1)&gt;=0&#125;&#125;wirelessnetwork-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;无线网络&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(2)&gt;=0&#125;&#125;shower-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;热水淋浴&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(3)&gt;=0&#125;&#125;aircondition-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;空调&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(4)&gt;=0&#125;&#125;heater-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;暖气&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(5)&gt;=0&#125;&#125;smoke-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;允许吸烟&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(6)&gt;=0&#125;&#125;drinking-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;饮水设备&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(7)&gt;=0&#125;&#125;brush-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;牙具&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(8)&gt;=0&#125;&#125;soap-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;香皂&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(9)&gt;=0&#125;&#125;slippers-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;拖鞋&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(10)&gt;=0&#125;&#125;toiletpaper-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;手纸&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(11)&gt;=0&#125;&#125;towel-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;毛巾&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(12)&gt;=0&#125;&#125;toiletries-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;沐浴露、洗发露&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(13)&gt;=0&#125;&#125;icebox-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;冰箱&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(14)&gt;=0&#125;&#125;washer-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;洗衣机&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(15)&gt;=0&#125;&#125;elevator-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;电梯&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(16)&gt;=0&#125;&#125;iscook-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;允许做饭&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(17)&gt;=0&#125;&#125;pet-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;允许带宠物&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(18)&gt;=0&#125;&#125;meet-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;允许聚会&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(19)&gt;=0&#125;&#125;accesssys-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;门禁系统&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(20)&gt;=0&#125;&#125;parkingspace-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;停车位&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(21)&gt;=0&#125;&#125;wirednetwork-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;有线网络&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(22)&gt;=0&#125;&#125;tv-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;电视&lt;/li&gt; &lt;li&gt;&lt;span class=\"&#123;&#123;if house.facilities.indexOf(23)&gt;=0&#125;&#125;hotbathtub-ico&#123;&#123;else&#125;&#125;jinzhi-ico&#123;&#123;/if&#125;&#125;\"&gt;&lt;/span&gt;浴缸&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &#123;&#123;if house.comments &#125;&#125; &lt;div class=\"house-info layout-style\"&gt; &lt;h3&gt;评价信息&lt;/h3&gt; &lt;ul class=\"house-comment-list\"&gt; &#123;&#123; each house.comments as comment&#125;&#125; &lt;li&gt; &lt;p&gt;&#123;&#123;comment.user_name&#125;&#125;&lt;span class=\"fr\"&gt;&#123;&#123;comment.ctime&#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&#123;&#123;comment.comment&#125;&#125;&lt;/p&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &lt;/div&gt; &#123;&#123;/if&#125;&#125;&lt;/script&gt; 九丶测试房屋详情页面显示正确数据是否成功1.运行项目，在浏览器输入http://127.0.0.1:5000，即进入网站主页，如下图所示 2.点击主页任意幻灯片，进入房屋详情页面 3.前端房屋完整信息图如下 4.查询数据库中房屋信息表以及设备设施表id和house_id为3的数据与前端页面显示数据进行对比 step1 在ih_house_info 房屋信息表中查看id=3的数据 step2 在ih_house_facility 房屋设备表中，查看house_id为3的设备数据为9条，与前端页面house_id为3的设备信息一致 step3 将step2 查询结果与ih_facility_info设备表进行一一对应，然后与第3点前端房屋完整信息图进行对比验证 5.查看redis数据库中缓存的房屋详情数据 6.查看项目运行日志，显示成功说明本次进入房屋详情页使用的页面数据为缓存数据 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/86580344","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之手机端租房网站的实战开发（十）","slug":"Flask项目之手机端租房网站的实战开发（十）","date":"2019-11-04T12:40:12.554Z","updated":"2019-11-13T12:58:27.707Z","comments":true,"path":"2019/11/04/Flask项目之手机端租房网站的实战开发（十）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/04/Flask项目之手机端租房网站的实战开发（十）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶区县信息前端编写 二丶发布新房源后端接口编写 三丶发布新房源前端编写 四丶测试接口 五丶celery的使用 六丶测试celery 七丶celery以目录形式创建","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶区县信息前端编写 二丶发布新房源后端接口编写 三丶发布新房源前端编写 四丶测试接口 五丶celery的使用 六丶测试celery 七丶celery以目录形式创建 一丶区县信息前端编写1.分析，当用户进入发布新房源，页面加载完毕即向后端发送请求拿取数据库中的区域信息数据，显示在页面上所在区县栏 2.所以需在此页面newhouse.js中进行如下编写 123456789101112//当页面加载完成时，想后端获取区县信息$.get(\"/api/v1.0/areas\", function (resp) &#123; if (resp.errno == \"0\")&#123; var areas = resp.data; for (i=0; i&lt;areas.length; i++)&#123; var area = areas[i] $(\"#area-id\").append('&lt;option value=\"'+area.aid+'\"&gt;'+area.aname+'&lt;/option&gt;') &#125; &#125;else &#123; alert(resp.errmsg) &#125;&#125;, \"json\") 3.当通过js向后端获取区域信息全部对象，通过循环遍历获取每个对象，将每个对象中的aid以及aname通过append方式追加到id为area_id的select标签下，所以最后需要在newhouse.html中将原有的option标签删除 123456789101112131415161718&lt;select class=\"form-control\" id=\"area-id\" name=\"area_id\"&gt; &lt;!--&lt;option value=\"1\"&gt;锦江区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"2\"&gt;青羊区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"3\"&gt;金牛区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"4\"&gt;武侯区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"5\"&gt;成华区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"6\"&gt;龙泉驿区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"7\"&gt;青白江区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"8\"&gt;新都区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"9\"&gt;温江区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"10\"&gt;郫都区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"11\"&gt;双流区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"12\"&gt;高新区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"13\"&gt;天府新区&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"14\"&gt;新津县&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"15\"&gt;大邑县&lt;/option&gt;--&gt; &lt;!--&lt;option value=\"16\"&gt;金堂县&lt;/option&gt;--&gt;&lt;/select&gt; 4.测试，重新启动程序，清除页面缓存，查看发布房源页面中的所有区县栏是否有数据，此时显示的区县数据，就是从后端数据库获取的 5.查看网页Network，从api/v1.0/area接口获取的数据 6.当前端页面需要从后端拿取很多数据时候，如果用上面的方式通过jquery想后端获取数据，再填充到标签中，这样就太麻烦了，所以这里需要在前端去引入一个js模板，来帮助我们更快的完成页面数据的填充 step1 比如在房间信息详情页面，需要很多数据 step2 使用art_template前端js模板来帮助我们解决此问题 https://aui.github.io/art-template/zh-cn/index.html 7.将发布新房源页面中的所在区县栏使用前端js模板进行改写 step1 在newhouse.html中引入template.js 12345678910111213&lt;script src=\"/static/js/template.js\"&gt;&lt;/script&gt;step2 在newhouse.html中定义模板&lt;script type=\"text/html\" id=\"areas-template\"&gt; &#123;&#123; each areas as area &#125;&#125; &lt;option value=\"&#123;&#123;area.aid&#125;&#125;\"&gt;&#123;&#123;area.aname&#125;&#125;&lt;/option&gt; &#123;&#123; /each &#125;&#125;&lt;/script&gt; ``` - **step3** 在newhouse.js中使用js模板```javascriptvar html_text =template(\"areas-template\", &#123;areas:areas&#125;);$(\"#area-id\").html(html_text) step4 测试，清除缓存，刷新网页，查看结果使用js模板成功 二丶发布新房源后端接口编写1.流程分析，在发布房源前端文件newhouse.html中将该页面下的上传图片栏隐藏了#form-house-image，当用户完成先关填写后，该上传房屋图片表单才会显示出来 step1 在浏览器开发端进行显示 step2 查看发布房源界面 2.在house.py中进行房屋信息接口编写 step1 创建视图 12345678@api.route(\"/houses/info\", methods=[\"POST\"])@login_requireddef save_house_info(): \"\"\" 保存房屋信息 :return: \"\"\" pass step2 获取数据 12user_id = g.user_idhouse_data = request.get_json() step3 从获取的data数据中拿取必填字段的值，facility配套设施可能啥都没有，前端就会传个空列表 123456789101112title = house_data.get(\"title\") # 房屋名称标题price = house_data.get(\"price\") # 房屋单价area_id = house_data.get(\"area_id\") # 房屋所属城区的编号address = house_data.get(\"address\") # 房屋地址room_count = house_data.get(\"room_count\") # 房屋包含的房间数目acreage = house_data.get(\"acreage\") # 房屋面积unit = house_data.get(\"unit\") # 房屋布局（几室几厅)capacity = house_data.get(\"capacity\") # 房屋容纳人数beds = house_data.get(\"beds\") # 房屋卧床数目deposit = house_data.get(\"deposit\") # 押金min_days = house_data.get(\"min_days\") # 最小入住天数max_days = house_data.get(\"max_days\") # 最大入住天数 step4 校验参数 12if not all([title, price, area_id, address, room_count, acreage, unit,capacity, beds, deposit, min_days, max_days]): return jsonify(errno=RET.PARAMERR, errmsg=\"参数不完整\") step5 判断用户输入的房屋单价和押金是否为正确参数，通过存入数据库字段单位分，如果用户输入的值不能转换为float和int类型，说明参数错误 123456try: price = int(float(price)*100) deposit = int(float(deposit)*100)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") step6 判断区县id是否存在 12345try: area = Area.query.get(area_id)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"数据库异常\") step7 如果在数据库中查询不到区域信息，表示区县信息有误 12if area is None: return jsonify(errno=RET.NODATA, errmsg=\"区县信息有误\") step8 保存房屋信息到数据库 123456789101112131415house = House( user_id = user_id, title = title, price = price, area_id = area_id, address = address, room_count = room_count, acreage = acreage, unit = unit, capacity = capacity, beds = beds, deposit = deposit, min_days = min_days, max_days = max_days) step9 获取设备设施数据id值 1facility_ids = house_data.get(\"facility\") step10 对获取设备设施字段的值进行判断,下判断这个值存不存在，当用户勾选设备设施时，举例facility_ids值为[2,4] 12345678if facility_ids: # 通过Facility类中的id值使用in_方法查询其中的id # select * from ih_facility_info where id in facility_ids; try: facilities = Facility.query.filter(Facility.id.in_(facility_ids)).all() except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"数据库异常\") step11 判断查询的每个facility对象是否存在,存在则保存设施数据 123456789if facilities: house.facilities = facilities try: db.session.add(house) db.session.commit() except Exception as e: current_app.logger.error(e) db.session.rollback() return jsonify(errno=RET.DBERR, errmsg=\"保存数据异常\") step12 返回正确响应内容 1return jsonify(errno=RET.OK, errmsg=\"OK\", data=&#123;\"house_id\":house.id&#125;) 3.上传房屋图片接口编写 step1 定义视图 12345@api.route(\"/houses/image\", methods=[\"POST\"])@login_requireddef save_house_image(): \"\"\"保存房屋图片\"\"\" pass step2 获取图片 1image_file = request.files.get(\"house_image\") step3 获取图片id 1house_id = request.form.get(\"house_id\") step4 校验参数 12if not all([image_file, house_id]): return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") step5 判断房屋是否在，存在才上传到七牛，如果不存在就不上传 12345try: house = House.query.get(house_id)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"数据库异常\") step6 house对象不存在则返回错误信息 12if house is None: return jsonify(errno=RET.NODATA, errmsg=\"房屋不存在\") step7 获取图片二进制数据 1image_data = image_file.read() step8 将图片保存到七牛中 12345try: file_name = storage(image_data)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.THIRDERR, errmsg=\"上传图片失败\") step9 保存图片信息到数据库中 12house_image = HouseImage(house_id=house_id, url=file_name)db.session.add(house_image) step10 当house对象中的index_image_url不存在时，设置网站主页房屋图片 123if not house.index_image_url: house.index_image_url = file_name db.session.add(house) step11 提交到数据库 123456try: db.session.commit()except Exception as e: current_app.logger.error(e) db.session.rollback() return jsonify(errno=RET.DBERR, errmsg=\"保存图片异常\") step12 拼接图片完整url，最后返回正确响应数据 12image_url = constants.QINIU_URL_DOMAIN + file_namereturn jsonify(errno=RET.OK, errmsg=\"OK\", data=&#123;\"image_url\":image_url&#125;) 三丶发布新房源前端编写1.在newhouse.js中进行提交房屋信息表单事件编写 12$(\"#form-house-info\").submit(function (e) &#123;&#125;) step1 阻止表单默认行为 1e.preventDefault(); step2 处理表单数据 12var data = &#123;&#125;;$(\"#form-house-info\").serializeArray().map(function (x) &#123; data[x.name] = x.value &#125;); step3 收集用户勾选的设备id 12var facility = [];$(\":checked[name=facility]\").each(function (index, x) &#123;facility[index] = $(x).val()&#125;); step4 将收集到的用户勾选id存到data数据库里的facility属性中 12var facility = [];$(\":checked[name=facility]\").each(function (index, x) &#123;facility[index] = $(x).val()&#125;); step5 通过ajax方式向后端接口发送请求 1234567891011121314151617181920212223242526$.ajax(&#123; url:\"/api/v1.0/houses/info\", type:\"post\", contentType:\"application/json\", data:JSON.stringify(data), dataType:\"json\", headers:&#123; \"X-CSRFToken\": getCookie(\"csrf_token\") &#125;, success: function (resp) &#123; if (resp.errno == \"4101\")&#123; location.href = \"/login.html\" &#125; else if (resp.errno == \"0\")&#123; // 将设备设施表单隐藏 $(\"#form-house-info\").hide(); // 将上传房屋图片表单显示 $(\"#form-house-image\").show(); // 设置上传房屋图片表单中的house_id $(\"#house-id\").val(resp.data.house_id); &#125;else &#123; alert(resp.errmsg) &#125; &#125;&#125;,\"json\") 2.在newhouse.js中进行上传房屋图片表单事件编写 12$(\"#form-house-image\").submit(function (e) &#123;&#125;) step1 阻止表单默认行为 1e.preventDefault(); step2 利用jquery.form.min.js插件通过的ajaxSubmit对表单进行异步提交，当后端返回正确响应时， 往class 为 house-image-cons div标签下去添加img标签，该div下的img标签为用户上传图片的标签，上传一个图片则在此div下追加一个img标签 123456789101112131415161718$(this).ajaxSubmit(&#123; url:\"/api/v1.0/houses/image\", type:\"post\", dataType:\"json\", headers:&#123; \"X-CSRFToken\": getCookie(\"csrf_token\") &#125;, success:function (resp) &#123; if(resp.errno == \"4101\")&#123; location.href = \"/login.html\" &#125;else if (resp.errno == \"0\")&#123; // 往class 为 house-image-cons div标签下去添加img标签 $(\".house-image-cons\").append('&lt;img src=\"' + resp.data.image_url+'\"&gt;') &#125;else &#123; alert(resp.errmsg); &#125; &#125;&#125;) 四丶测试接口1.运行项目，清除浏览器缓存，刷新网页，进入发布房源，博主这里使用的FS截图工具进行滚动窗口截图 2.填写房屋信息 3.填写完数据后，点击发布房源信息，逻辑成功则显示上传房屋图片界面 查看数据库ih_house_info房屋信息表，数据显示为刚填写的表单勾选数据，此时并没有上传图片所以index_image_url为空 4.点击选择文件，选择桌面上的图片后，再点击上传，则显示在页面中 5.依次上传三张图片后 查看此时数据库ih_house_image表信息，在上图上传的三张图片是house_id为6的房屋例子，所以在下标显示house_id为6的图片url链接为三个 6.同时查看七牛云上的存储空间 五丶celery的使用1.问题，我们在做网站后端程序开发时，会碰到这样的需求：用户需要在我们的网站填写注册信息，我们发给用户一封注册激活邮件到用户邮箱，如果由于各种原因，这封邮件发送所需时间较长，那么客户端将会等待很久，造成不好的用户体验. 2.解决，celery适用异步处理问题，当发送邮件、或者文件上传, 图像处理等等一些比较耗时的操作，我们可将其异步执行，这样用户不需要等待很久，提高用户体验。 celery的特点是： 简单，易于使用和维护，有丰富的文档。高效，单个celery进程每分钟可以处理数百万个任务。灵活，celery中几乎每个部分都可以自定义扩展。 3.Task Queue celery通过消息进行通信，通常使用一个叫Broker(中间人)来协client(任务的发出者)和worker(任务的处理者). clients发出消息到队列中，broker将队列中的信息派发给worker来处理。 一个celery系统可以包含很多的worker和broker，可增强横向扩展性和高可用性能 4.在项目ihome目录下创建一个tasks包，用于处理项目中的需要的异步任务，在这个包下创建单一文件来处理对应的异步任务，这种方式是对于所有的web框架来说，都是万能的，像django中使用的djcelery包是别人针对于django框架封装好的包 step1 在task包下创建一个task_sms.py文件，在这个文件中去编写对于发送短信的任务 step2 定义celery对象 1app = Celery(\"ihome\", broker=\"redis://127.0.0.1:6379/1\") step3 定义短信的异步任务 1234@app.taskdef send_sms(): \"\"\"发送短信的异步任务\"\"\" pass step4 导入之前定义好云通讯中封装的CCP类，并创建CCP的对象ccp 1from ihome.libs.yuntongxun.SendSMS import CCP step5 通过ccp对象调用sendTemplateSMS方法，同时调用send_sms方法时传递三个参数，从这三个参数拿sendTemplateSMS方法中即可 12345@app.taskdef send_sms(to, datas, tempId): \"\"\"发送短信的异步任务\"\"\" ccp = CCP() ccp.sendTemplateSMS(to, datas, tempId) step6 回到api_1_0目录下的verify_code中，将之前写的get_sms_code方法中发送短信逻辑代码进行重新编写，跟之前写的逻辑不一样，之前是发送成功则返回发送成功msg，失败则返回发送失败msg，大多网站都是现在以下这种逻辑 12345# 使用celery异步发送短信send_sms.delay(mobile, [sms_code, int(constants.SMS_CODE_REDIS_EXPIRES/60)], 1) # 发送成功与否，用户自己去查看手机，大多网站都是这样做的return jsonify(errno=RET.OK, errmsg=\"发送短信成功\") 六丶测试celery1.在终端中运行项目 2.另开一个终端执行celery -A ihome.tasks.task_sms worker -l info，-l代表开启日志 info级别，但是出现了报错 3.在百度上查询此报错信息，明白原来是celery4.0以上版本不支持windows 4.所以博主这里进行 pip install celery==3.1.7 进行3.x版本安装 5.在新开启的终端上，重新执行celery -A ihome.tasks.task_sms worker -l info，报错问题解决 6.进入网站注册界面http://127.0.0.1:5000/register.html，后进行注册，输入博主本人手机号，输入正确验证码，然后点击获取短信验证码后，回头查看celery终端，结果又报错了 7.这次报的错好像是跟redis有关，查看redis版本为3.0的 8.将redis版本缓存2.0的，再看看是否报错，pip install redis==2.10.5 9.先运行项目，再开启另一终端执行celery -A ihome.tasks.task_sms worker -l info step1 在注册页面进行注册 step2 查看celery终端日志，显示七牛SDK发送短信成功日志 step3 查看博主手机上短信验证码为987427 step4 查看redis数据库1中的keys 七丶celery以目录形式创建1.在ihome/tasks目录下创建main.py用于启动文件，再创建一个config.py用于作配置文件，然后在tasks目录下创建一个sms包，再该包下创建一个tasks.py文件或者是celery.py文件用于创建worker 2.拆分task_sms.py文件 step1 在启动文件main.py中编写以下代码 1app = Celery(\"ihome\", broker=\"redis://127.0.0.1:6379/1\") step2 将如下代码拷贝到tasks.py中 12345@app.taskdef send_sms(to, datas, tempId): \"\"\"发送短信的异步任务\"\"\" ccp = CCP() ccp.sendTemplateSMS(to, datas, tempId) step3 将main.py中创建app对象中的配置文件拿到config.py中 12BROKER_URL = \"redis://127.0.0.1:6379/1\"CELERY_RESULT_BACKEND = 'redis://127.0.0.1:6379/2' step4 回到main.py中进入如下编写 1234567app = Celery(\"ihome\") # 引入配置信息app.config_from_object(config) # 自动搜索任务app.autodiscover_tasks([\"ihome.tasks.sms\"]) step5 回到ihome/api_1_0/verify_code.py中，将之前写的代码进行修改，将不在从from ihome.tasks.task_sms去导入send_sms，而是从我们刚定义好的sms.tasks中去导入send_sms 1from ihome.tasks.sms.tasks import send_sms 3.测试 step1 首先启动项目，再另起终端启动worker，结果又特么报错了 step2 这个错是因为操作系统原因导致的，在linux系统上运行则不会保错 原因：因为windows操作系统的原因，在Windows中，多进程multiprocessing使用的是序列化pickle来在多进程之间转移数据，而socket对象是不能被序列化的，但是在linux操作系统上却没问题，因为在linux上多进程multiprocessing使用的是fork，所以在windows上可以改用多线程，而celery是使用多进程以及携程方式进行异步工作，博主又是在windows环境进行测试开发，所以这里先暂时这样，等开发完成部署在linux服务器即可","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之手机端租房网站的实战开发（九）","slug":"Flask项目之手机端租房网站的实战开发（九）","date":"2019-11-04T11:52:53.445Z","updated":"2019-11-13T12:57:39.107Z","comments":true,"path":"2019/11/04/Flask项目之手机端租房网站的实战开发（九）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/04/Flask项目之手机端租房网站的实战开发（九）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶区县信息后端编写 二丶为区县信息补充缓存机制 三丶缓存数据同步问题 四丶完善后端用户模块 五丶完善前端用户模块 六丶测试用户模块中个人信息栏，我的爱家，实名认证 七丶效果动图展示","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶区县信息后端编写 二丶为区县信息补充缓存机制 三丶缓存数据同步问题 四丶完善后端用户模块 五丶完善前端用户模块 六丶测试用户模块中个人信息栏，我的爱家，实名认证 七丶效果动图展示 一丶区县信息后端编写1.定义视图函数 1234567@api.route(\"/areas\")def get_area_info(): \"\"\" 获取区县信息 :return: \"\"\" pass 2.逻辑编写 step1 从数据库中获取所有区县信息 123456try: # 从数据库中获取所有区县信息 area_li = Area.query.all()except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"数据库异常\") step2 在Area类中构建一个to_dict方法，将对象转换成字典，因为我们给前端传输数据是需要传输json格式数据的 1234567def to_dict(self): \"\"\"将对象转换为字典\"\"\" data = &#123; \"aid\": self.id, \"aname\": self.name &#125; return data step3 遍历对象列表，调用每个对象中的to_dict方法，将返回的值添加到area_dict_li列表中 12345# 将对象转换为字典area_dict_li = [] for area in area_li: area_dict_li.append(area.to_dict()) step4 返回正确响应数据 1return jsonify(errno=RET.OK, errmsg=\"OK\", data=area_dict_li) 3.测试接口 step1 运行项目，打开Postman测试工具，向127.0.0.1:5000/api/v1.0/areas发送get请求 step2 返回接口正确响应数据，因为数据库Area表没有数据，所以返回的响应数据为空 4.向数据库中ih_area_info以及ih_facility_info两张表插入测试数据 step1 执行如下SQL语句 12INSERT INTO `ih_area_info`(`name`) VALUES ('锦江区'),('青羊区'),('金牛区'),('武侯区'),('成华区'),('龙泉驿区'),('青白江区'),('新都区'),('温江区'),('郫都区'),('双流区'),('高新区'),('天府新区'),('新津县'),('大邑县'),('金堂县');INSERT INTO `ih_facility_info`(`name`) VALUES('无线网络'),('热水淋浴'),('空调'),('暖气'),('允许吸烟'),('饮水设备'),('牙具'),('香皂'),('拖鞋'),('手纸'),('毛巾'),('沐浴露、洗发露'),('冰箱'),('洗衣机'),('电梯'),('允许做饭'),('允许带宠物'),('允许聚会'),('门禁系统'),('停车位'),('有线网络'),('电视'),('浴缸'); ih_area_info表 ih_facility_info表 step2 再回到Postman中Send发送请求，显示出正确响应数据 二丶为区县信息补充缓存机制1.为什么要补充缓存机制 step1 在网站首页，需要频繁获取区域数据 step2 在我的爱家中，发布房源也需要频繁获取区域数据 step3 以及在房源列表，搜索栏也要频繁获取区域数据 2.分析，因为区县一般都是固定的，不会经常变化，搜索页面和主页是用户经常访问的地方，那么即我们后端接口以及数据库就会被大量访问，而且是在很短时间内，这样可能会出现异常问题，导致访问速度缓慢，所以完美解决方法就是使用缓存 3.具体实现流程 step1 当用户访问区县信息时，就会调用后端我们写的get_area_info接口，之前写的代码是，每次访问都会从数据库中拿去数据，现在将这一块改变一下，先从redis数据中拿去数据库（这里选择redis数据库，因为是内存级的数据库） step2 如果redis数据库中有区域数据，直接返回给前端 step3 当redis数据库中没有区域数据时，此时再去mysql数据库中进行数据获取，拿到的区域数据不会马上返回给前端，而是将拿到的数据保存到redis数据库中，最后才返回给前端 4.逻辑代码编写 思考：将数据保存到redis数据库中，此时需要思考，以怎么形式保存数据，保存哪些数据到redis数据库 实现：是将整个返回给前端正确响应数据全部以json格式的字符串保存 step1 将数据转换为json字符串 12resp_dict = dict(errno=RET.OK, errmsg=\"OK\", data=area_dict_li)resp_json_str = json.dumps(resp_dict) step2 将构建的json格式的字符串响应数据保存到redis数据库中， 并设置有效期 1234try: redis_store.setex(\"area_info\",constants.AREA_INFO_REDIS_CACHE_EXPIRES, resp_json_str)except Exception as e: current_app.logger.error(e) step3 返回构造响应头数据，设置Content-Type为json，默认的为html 1return resp_json_str, 200, &#123;\"Content-Type\":\"application/json\"&#125; step4 调用接口一开始从redis数据库中拿去区域数据 1234567try: resp_json_str = redis_store.get(\"area_info\")except Exception as e: current_app.logger.error(e)else: if resp_json_str is not None: return resp_json_str, 200, &#123;\"Content-Type\": \"application/json\"&#125; step5 当redis数据库中获取的数据不为空时，往日志info中记录一句话，方便测试是从mysql 还是 redis 获取的区域数据 1current_app.logger.info(\"Area data from redis\") 5.测试redis缓存是否成功 step1 运行项目 step2 在Postman测试工具中向后端接口 第一次Send发送请求，查看程序运行日志，并没有显示我们定义日志信息 第二次Send发送请求，则显示我们定义的info日志信息，说明区域数据是从redis数据库中获取的 step3 查看redis数据库，并获取area_info键的值 三丶缓存数据同步问题问：怎么保证redis缓存的数据和mysql数据保持一致性？ 第一种方式：mysql数据库维护人员在修改区域表数据时，将redis数据库key删除 第二种方式：就是我们这种简单暴力有效的方式，设置数据的有效期，让redis数据库来帮我们把数据进行删除 四丶完善后端用户模块1.对profile模块中的update_name进行修改 step1 修改路由请求方式 1@api.route(\"/users/name\", methods=[\"PUT\"]) step2 从g对象中获取用户id 1user_id = g.user_id step3 获取前端请求中的参数 1req_dict = request.get_json() step4 判断参数是否为空 12if not req_dict: return jsonify(errno=RET.PARAMERR, errmsg=\"参数不完整\") step5 获取用户修改的名字 1name = req_dict.get(\"name\") step6 判断用户是否输入用户名 12if name is None: return jsonify(errno=RET.PARAMERR, errmsg=\"名字不能为空\") step7 将用户修改后的名字保存到数据库，需要注意的是这里不需要判断名字name是否重复，因为当初在创建数据库表字段name的时候设置了唯一索引 1234567try: User.query.filter_by(id=user_id).update(&#123;\"name\": name&#125;) db.session.commit()except Exception as e: db.session.rollback() current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"保存用户名字失败\") step8 因为在登录和注册接口编写时候最后都将name保存到session中，所以当用户修改name后，也需要将新的name进行session保存 1session[\"name\"] = name step9 最后返回正确响应 1return jsonify(errno=RET.OK, errmsg=\"修改成功\", data=&#123;\"name\": name&#125;) 2.获取个人信息在我的爱家中进行显示 step1 定义视图函数 123@api.route(\"/user\", methods=[\"GET\"])@login_requireddef get_user_profile(): step2 获取用户id 1user_id = g.user_id step3 根据用户id在数据库中查询个人信息 12345try: user = User.query.get(user_id)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"获取用户信息失败\") step4 判断用户对象是否为空 12if User is None: return jsonify(errno=RET.NODATA, errmsg=\"无效操作\") step5 在models模块中构建一个to_dict方法，用于构建我们返回给前端的数据 12345678910def to_dict(self): \"\"\"将对象转换为字典数据\"\"\" user_dict = &#123; \"user_id\": self.id, \"name\": self.name, \"mobile\": self.mobile, \"avatar\": constants.QINIU_URL_DOMAIN + self.avatar_url if self.avatar_url else \"\", \"create_time\": self.create_time.strftime(\"%Y-%m-%d %H:%M:%S\") &#125; return user_dict step6 回到profile模块中，返回正确响应数据给前端 1return jsonify(errno=RET.OK, errmsg=\"OK\", data=user.to_dict()) 3.获取用户的实名认证信息 step1 定义视图函数 123@api.route(\"/users/auth\", methods=[\"GET\"])@login_requireddef get_user_auth(): step2 获取用户id 1user_id = g.user_id step3 根据用户id在数据库中进行查询, 获取用户对象 12345try: user = User.query.get(user_id)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"获取用户实名认证信息失败\") step4 判断用户对象是否为空 12if user is None: return jsonify(errno=RET.NODATA, errmsg=\"无效操作\") step5 在models模块中构建一个auth_to_dict方法，用于构建我们返回给前端的数据 12345678def auth_to_dict(self): \"\"\"将用户实名信息转换为字典数据\"\"\" auth_dict = &#123; \"user_id\": self.id, \"real_name\": self.real_name, \"id_card\": self.id_card &#125; return auth_dict step6 回到profile模块中，返回正确响应数据给前端 1return jsonify(errno=RET.OK, errmsg=\"OK\", data=user.auth_to_dict()) 4.向数据库中保存用户实名认证信息 step1 定义视图函数 123@api.route(\"/users/auth\", methods=[\"POST\"])@login_requireddef set_user_auth(): step2 获取用户id 1user_id = g.user_id step3 获取前端发送请求中的参数 1req_data = request.get_json() step4 判断参数是否为空 12if not req_data: return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") step5 获取用户输入的真实姓名和身份证号 12real_name = req_data.get(\"real_name\")id_card = req_data.get(\"id_card\") step6 校验参数完整性 12if not all([real_name,id_card]): return jsonify(errno=RET.PARAMERR, errmsg=\"参数错误\") step7 将用户填写的真实姓名和身份证号保存到数据库中，这里在数据库进行数据更新是为什么将real_name和id_card默认为空，因为在后端来说，用户只能设置一次实名认证，当real_name和id_card为None时，才代用户是第一次进行认证，当获取的real_name和id_card不为空时，说明用户之前已经认证过了 1234567try: User.query.filter_by(id=user_id, real_name=None, id_card=None).update(&#123;\"real_name\":real_name, \"id_card\":id_card&#125;) db.session.commit()except Exception as e: current_app.logger.error(e) db.session.rollback() return jsonify(errno=RET.DBERR, errmsg=\"保存用户实名信息失败\") step8 向前端返回正确响应 1return jsonify(errno=RET.OK, errmsg=\"OK\") 五丶完善前端用户模块1.在profile.html文件中进行如下修改 1&lt;form id=\"form-name\" action=\"/api/profile/name\" method=\"post\"&gt; 2.在profile.js中进行如下编写 step1 在个人信息栏显示用户信息 123456789101112131415// 在页面加载是向后端查询用户的信息 $.get(\"/api/v1.0/user\", function(resp)&#123; // 当后端接口检验登录装饰器返回4101状态码，表示用户未登录，即跳转到登录页面 if (resp.errno == \"4101\") &#123; location.href = \"/login.html\"; &#125; // 后端返回正确响应码，将响应数据中的name填写到id = user-name的标签内容上 else if (resp.errno == \"0\") &#123; $(\"#user-name\").val(resp.data.name); // 头像链接存在则显示到src下 if (resp.data.avatar) &#123; $(\"#user-avatar\").attr(\"src\", resp.data.avatar); &#125; &#125; &#125;, \"json\"); step2 将用户修改后的名字保存到数据库中 12345678910111213141516171819202122232425262728293031// 将用户修改后名字向后端进行发送 $(\"#form-name\").submit(function(e)&#123; e.preventDefault(); // 获取用户输入的名字 var name = $(\"#user-name\").val(); if (!name) &#123; alert(\"请填写用户名！\"); return; &#125; $.ajax(&#123; url:\"/api/v1.0/users/name\", type:\"PUT\", data: JSON.stringify(&#123;name: name&#125;), contentType: \"application/json\", dataType: \"json\", headers:&#123; \"X-CSRFTOKEN\":getCookie(\"csrf_token\") &#125;, success: function (data) &#123; if (data.errno == \"0\") &#123; $(\".error-msg\").hide(); showSuccessMsg(); &#125; else if (data.errno == \"4001\") &#123; $(\".error-msg\").show(); &#125; else if (data.errno == \"4101\") &#123; location.href = \"/login.html\"; &#125; &#125; &#125;); &#125;) 3.在我的爱家my.js中进行如下编写 1234567891011121314151617$(document).ready(function()&#123; $.get(\"/api/v1.0/user\", function(resp)&#123; // 用户未登录 if (resp.errno == \"4101\") &#123; location.href = \"/login.html\"; &#125; // 查询到了用户的信息 else if (resp.errno == \"0\") &#123; $(\"#user-name\").html(resp.data.name); $(\"#user-mobile\").html(resp.data.mobile); if (resp.data.avatar) &#123; $(\"#user-avatar\").attr(\"src\", resp.data.avatar); &#125; &#125; &#125;, \"json\"); &#125;); 4.在实名认证auth.js中进行如下编写 step1 当页面加载完毕时，想后端接口发送请求来获取用户的姓名和身份证 123456789101112131415161718192021$(document).ready(function()&#123; // 查询用户的实名认证信息 $.get(\"/api/v1.0/users/auth\", function(resp)&#123; // 4101代表用户未登录 if (resp.errno == \"4101\") &#123; location.href = \"/login.html\"; &#125; else if (resp.errno == \"0\") &#123; // 如果返回的数据中real_name与id_card不为null，表示用户有填写实名信息 if (resp.data.real_name &amp;&amp; resp.data.id_card) &#123; $(\"#real-name\").val(resp.data.real_name); $(\"#id-card\").val(resp.data.id_card); // 给input添加disabled属性，禁止用户修改 $(\"#real-name\").prop(\"disabled\", true); $(\"#id-card\").prop(\"disabled\", true); // 隐藏提交保存按钮 $(\"#form-auth&gt;input[type=submit]\").hide(); &#125; &#125; else &#123; alert(resp.errmsg); &#125; &#125;, \"json\"); step2 当页面加载完毕时，如果用户已经进行了实名认证，那么就不显示保存按钮以及对输入框进行禁止修改 123456789101112131415161718192021222324252627282930313233343536373839// 管理实名信息表单的提交行为 $(\"#form-auth\").submit(function(e)&#123; e.preventDefault(); // 如果用户没有填写完整，展示错误信息 var realName = $(\"#real-name\").val(); var idCard = $(\"#id-card\").val(); if (realName == \"\" || idCard == \"\") &#123; $(\".error-msg\").show(); &#125; // 将表单的数据转换为json字符串 var data = &#123; real_name: realName, id_card: idCard &#125;; var jsonData = JSON.stringify(data); // 向后端发送请求 $.ajax(&#123; url:\"/api/v1.0/users/auth\", type:\"post\", data: jsonData, contentType: \"application/json\", dataType: \"json\", headers: &#123; \"X-CSRFTOKEN\": getCookie(\"csrf_token\") &#125;, success: function (resp) &#123; if (resp.errno == \"0\") &#123; $(\".error-msg\").hide(); // 显示保存成功的提示信息 showSuccessMsg(); $(\"#real-name\").prop(\"disabled\", true); $(\"#id-card\").prop(\"disabled\", true); $(\"#form-auth&gt;input[type=submit]\").hide(); &#125; &#125; &#125;); &#125;) 5.当用户进行实名制后，那么在我的房源页面，就不应该显示去实名认证按钮 step1 实名制之前显示界面 step2 在myhouse.js中进行判断验证，如果用户已经实名制了，那么就不显示此按钮，否则才会显示 123456789101112131415$(document).ready(function()&#123; // 对于发布房源，只有认证后的用户才可以，所以先判断用户的实名认证状态 $.get(\"/api/v1.0/users/auth\", function(resp)&#123; if (\"4101\" == resp.errno) &#123; // 用户未登录 location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; // 未认证的用户，在页面中展示 \"去认证\"的按钮 if (!(resp.data.real_name &amp;&amp; resp.data.id_card)) &#123; $(\".auth-warn\").show(); return; &#125; &#125; &#125;)&#125;); step3 实名制之后显示页面 六丶测试用户模块中个人信息栏，我的爱家，实名认证1.个人信息栏测试 step1 登录网站，进入个人信息栏，显示如下 step2 当修改用户名后，点击保存，显示保存成功提示 2.我的爱家栏测试，成功显示出用户头像，用户名以及手机号 3.用户实名认证栏测试 step1 首次进行实名认证，界面显示如下 step2 当未填写姓名和身份证号时，出现如下显示 step3 当输入完整信息后，会显示保存成功，出现如下界面 step4 查看数据库信息 step5 此号码已经实名认证成功，再次进入实名认证，则显示如下界面 七丶效果动图展示 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/86488529","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之手机端租房网站的实战开发（八）","slug":"Flask项目之手机端租房网站的实战开发（八）","date":"2019-11-04T07:56:11.905Z","updated":"2019-11-13T12:57:31.893Z","comments":true,"path":"2019/11/04/Flask项目之手机端租房网站的实战开发（八）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/04/Flask项目之手机端租房网站的实战开发（八）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶构建一个用于验证登录状态的装饰器 二丶七牛云的使用 三丶上传头像后端编写 四丶上传头像前端编写 五丶修改用户名后端编写 六丶修改用户名前端编写 七丶在我的爱家上，显示头像用户名以及手机号 八丶最终效果动图","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶构建一个用于验证登录状态的装饰器 二丶七牛云的使用 三丶上传头像后端编写 四丶上传头像前端编写 五丶修改用户名后端编写 六丶修改用户名前端编写 七丶在我的爱家上，显示头像用户名以及手机号 八丶最终效果动图 一丶构建一个用于验证登录状态的装饰器1.因为这个装饰器用的地方比较多，所以就在项目中的utils目录下的commons模块中进行定义 12345678def login_required(view_func): \"\"\" 验证登录状态的装饰器 :param view_func: 需要装饰的视图函数 :return: \"\"\" def wrapper(*args, **kwargs): pass 2.获取session中用户id 1user_id = session.get(\"user_id\") 3.根据user_id来判断用户登录状态，如果user_id不为空，说明用户已经登录，那么就执行视图函数,否则返回对应错误信息 1234if user_id is not None: return view_func(*args, **kwargs)else: return jsonify(errno=RET.SESSIONERR, errmsg=\"用户未登录\") 4.通过flask中的g对象来保存将来在视图函数中要用的user_id 1g.user_id = user_id 5.导入python标准库functools，见名知义，就是函数工具库，这个库有个wraps方法，用于作为在闭包中的内置函数的装饰器，意义就是不会改变函数使用装饰前的特性（建议再定义装饰器时，在内置函数上添加@functools.wraps()装饰器） 12@functools.wraps(view_func)def wrapper(*args, **kwargs): 二丶七牛云的使用1.图片存储服务—七牛云 step1 在https://portal.qiniu.com/signup 进行注册 step2 注册成功后，添加进入对象存储 step3 新建存储空间，如下图所示（需要实名认证审核期为三天） 创建成功后，1个月的测试使用期限 step4 进入文档中心—-》选择SDK&amp;工具—-》官方SDK—-》找到Python（服务端），点击文档说明，有案列以及安装方法 step5 查看官网提供的上传图片案列 1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-# flake8: noqa from qiniu import Auth, put_file, etagimport qiniu.config #需要填写你的 Access Key 和 Secret Keyaccess_key = 'Access_Key'secret_key = 'Secret_Key' #构建鉴权对象q = Auth(access_key, secret_key) #要上传的空间bucket_name = 'Bucket_Name' #上传到七牛后保存的文件名key = 'my-python-logo.png' #生成上传 Token，可以指定过期时间等token = q.upload_token(bucket_name, key, 3600) #要上传文件的本地路径localfile = './sync/bbb.jpg' ret, info = put_file(token, key, localfile)print(info)assert ret['key'] == keyassert ret['hash'] == etag(localfile) step6 Access_Key以及Secret_Key在个人面板—–》密匙管理里进行查看 2.在项目utils目录下创建一个image_storage.py文件，用于我们作进一步的封装 step1 将案列代码拷贝到该py文件中，填写access_key和secret_key，以及要上传的空间名bucket_name step2 不设定key上传到七牛上的文件名，即设定key变量的值为None step3 通过导入的qiniu库，查看qiniu/init中除了案列中import的put_file方法（通过文件名上传），还有另外一个put_data方法（通过文件二进制流上传），我们使用put_data方法，这样直接从本地通过with open read方法直接将图片读取出来的二进制数据上传到七牛 step4 修改代码，不使用put_file方法，使用put_data方法 1ret, info = put_data(token, None, localfile) step5 封装代码到storage方法中 step6 通过with open read方式读取image_storage文件同路径下的1.jpg图片，调用storage方法将读取的二进制内容传给此方法 1234if __name__ == '__main__': with open(\"./1.jpg\",\"rb\") as f: file_data = f.read() storage(file_data) 3.测试七牛云接口，进行图片上传 step1 运行程序，查看打印的ret的值和info的值，状态码200就表示上传成功，hash值顾名思义使用hash转换后的值，因为程序中注释掉了key文件名，所以七牛云就将hash值当作了key值 step2 回到七牛云上，刷新页面，进入存储空间中的内容管理，就能看到我们刚上传的图片了，这里图片名字就是程序运行结果中的hash值 step3 浏览器中打开新的标签，将域名+/+文件名中间以/分割，拼接到一起，粘贴到标签地址栏中，回车则可以查看该我们上传的图片了 三丶上传头像后端编写1.在api_1.0目录下创建profile.py文件，用于作个人信息逻辑编辑 2.在init文件中导入此py文件 1from . import verify_code, passport, profile 3.定义视图函数以及路由规则 12345678@api.route(\"/users/avatar\", methods=[\"POST\"])def set_user_avatar(): \"\"\" 上传头像图片 :param image user_id :return: \"\"\" pass 4.导入之前定义的验证登录状态的装饰器 1from ihome.utils.commons import login_required 5.编写业务逻辑 step1 获取用户id 1user_id = g.user_id step2 获取图片 1image_file = request.files.get(\"avatar\") step3 判断用户是否上传图片 12if image_file is None: return jsonify(errno=RET.PARAMERR, errmsg=\"未上传图片\") step4 读取图片二进制数据 1image_data = image_file.read() step5 修改image_storage文件，当状态码为200时，返回key值，不为200时表示上传失败，返回异常 123456if info.status_code == 200: \"\"\"表示图片上传成功\"\"\" return ret.get(\"key\")else: # 上传失败 raise Exception(\"图片上传七牛云失败\") step6 回到profile中，调用封装好的七牛接口上传图片，返回文件名 12345try: file_name = storage(image_data)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.THIRDERR, errmsg=\"上传图片失败\") step7 将图片地址保存到数据库avatar_url字段，思考，需要将域名与文件名拼接好后保存，还是只保存文件名，为了节省空间，并且只有文件名不同，所以执行保存文件名到数据库avatar_url字段即可 1234567try: User.query.filter_by(id=user_id).update(&#123;\"avatar_url\":file_name&#125;) db.session.commit()except Exception as e: db.session.rollback() current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"保存图片信息失败\") step8 拼接图片完整链接 1avatar_url = constants.QINIU_URL_DOMAIN + file_name step9 保存成功后，返回给前端正确响应 1return jsonify(errno=RET.OK, errmsg=\"保存成功\", data=&#123;\"avatar_url\": avatar_url&#125;) 四丶上传头像前端编写1.前端个人信息HTML代码（不展示） 2.前端个人信息JS代码（不展示） 3.修改profile.html代码，将id=”form-avatar”的表单中的action=”/api/profile/avatar” method=”post”去掉，通过导入的jquery.form.min.js插件来发送表单数据 1234&lt;form id=\"form-avatar\" enctype=\"multipart/form-data\"&gt; 选择头像：&lt;input type=\"file\" accept=\"image/*\" name=\"avatar\"&gt; &lt;input type=\"submit\" class=\"btn btn-success\" value=\"上传\"&gt;&lt;/form&gt; 4.在profile.js中进行如下编写 step1 阻止表单默认行为 123456$(document).ready(function () &#123; $('#form-avatar').submit(function (e) &#123; // 阻止表单默认行为 e.preventDefault(); &#125;)&#125;); step2 利用jquery.form.min.js插件通过的ajaxSubmit对表单进行异步提交 1234567891011121314151617$(this).ajaxSubmit(&#123; url:\"/api/v1.0/users/avatar\", type:\"post\", dataType:\"json\", headers:&#123; \"X-CSRFToken\": getCookie(\"csrf_token\") &#125;, success: function (resp) &#123; if (resp.errno == \"0\")&#123; // 上传成功 var avatarUrl = resp.data.avatar_url; $('#user-avatar').attr(\"src\", avatarUrl) &#125;else &#123; alert(resp.errmsg); &#125; &#125;&#125;) 5.测试 step1 运行项目 1python manage.py runserver step2 输入http://127.0.0.1:5000 主页进行登录，然后进入个人信息，点击修改，选择头像点击上传后，如下图所示 step3 查看七牛云内容管理 五丶修改用户名后端编写1.创建视图函数以及定义路由接口 1234@api.route(\"/users/name\", methods=[\"POST\"])@login_requireddef update_name(): pass 2.逻辑编写，当用户输入昵称后，点击保存，向后端接口发送请求，携带用户填写的昵称name，以json格式发送数据，然后在后端获取name，并通过用户id，数据库操作更新name字段的值为用户输入的昵称name step1 获取用户id 1user_id = g.user_id step2 获取前端发送过来的参数 12req_dict = request.get_json()name = req_dict.get(\"name\") step3 判断用户是否输入用户名 123# 判断用户是否输入用户名 if name is None: return jsonify(errno=RET.NODATA, errmsg=\"昵称不能为空\") step4 判断昵称是否存在 12345678try: user = User.query.filter_by(id=user_id).first() # 从数据中获取用户昵称 user_name = user.name if user_name is not None and user_name == name: return jsonify(errno=RET.DATAEXIST, errmsg=\"用户名已存在\")except Exception as e: current_app.logger.error(e) step5 将用户输入的name昵称保存到数据库中 1234567try: User.query.filter_by(id=user_id).update(&#123;\"name\": name&#125;) db.session.commit()except Exception as e: db.session.rollback() current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"保存用户昵称失败\") step6 最后返回正确响应 1return jsonify(errno=RET.OK, errmsg=\"修改成功\", data=&#123;\"name\": name&#125;) 六丶修改用户名前端编写1.前端个人信息HTML代码（不展示） 2.前端个人信息JS代码（不展示） 3.去掉profile.html中action=”/api/profile/name” method=”post” 1&lt;form id=\"form-name\"&gt; 4.在profile.js中添加脚本，当点击保存时，触发id = form-name的submit回调函数，发送users/name地址调用update_name是视图函数，将构造用户填写的name通过ajax方式传给后端，来完成后端逻辑，当后端返回响应码为0时，代表更新数据库成功，那么在前端直接跳转到登录页，进行登录，登录成功后则显示修改后的用户名了 1234567891011121314151617181920212223242526$('#form-name').submit(function (e) &#123; e.preventDefault(); var name = $(\"#user-name\").val(); var data = &#123; name:name &#125;; var jsonData = JSON.stringify(data); $.ajax(&#123; url:\"/api/v1.0/users/name\", type:\"post\", data:jsonData, contentType:\"application/json\", dataType:\"json\", headers:&#123; \"X-CSRFToken\": getCookie(\"csrf_token\") &#125;, success: function (resp) &#123; if (resp.errno == \"0\")&#123; location.href = \"/login.html\"; &#125;else &#123; alert(resp.errmsg) &#125; &#125; &#125;) &#125;) 5.测试 说明：测试以18022222222账号为例 step1 查看数据库中ih_user_profile表，获取所有用户信息 step2 启动项目 1python manage.py runserver step3 登录18022222222账号进入我的爱家，点击修改，进入修改页面，如下 step4 先输入依存在的用户名，点击保存，如果打印用户名已存在，说明逻辑正确 step5 输入不存在的昵称这里输入的为Hellotaogang，如果成功修改则，,逻辑正确 step6 查看数据库显示为修改后的昵称，表示前后端逻辑编写正确 七丶在我的爱家上，显示头像用户名以及手机号说明：这里可以写一个后端接口用来显示出此三项，我这里写了两个接口，第一个是显示头像的，第二个是显示用户名和手机号 1.先看看实现之前的效果 2.显示头像后端逻辑编写 step1 定义show_avatar视图函数 1234@api.route(\"/users/show_avatar\", methods=[\"POST\"])@login_requireddef show_avatar(): pass step2 因为实现代码太简单，详细过程不细说 1234567891011121314# 获取user_iduser_id = g.user_id # 从数据库中获取avatar_urltry: user = User.query.filter_by(id=user_id).first()except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"获取图片信息失败\")# 拼接图片完整链接avatar_url = constants.QINIU_URL_DOMAIN + user.avatar_url return jsonify(errno=RET.OK, errmsg=\"OK\", data=&#123;\"avatar_url\": avatar_url&#125;) 3.显示用户名和手机号后端逻辑编写 step1 定义show_name_mobile视图函数 1234@api.route(\"/users/show_name_mobile\", methods=[\"POST\"])@login_requireddef show_name_mobile(): pass step2 因为实现代码太简单，详细过程不细说 1234567891011121314151617181920212223# 获取用户iduser_id = g.user_id# 根据用户id 在数据库中获取对应的 用户名和手机号try: user = User.query.filter_by(id=user_id).first()except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"获取用户信息失败\")# 获取用户名use_name = user.name # 获取用户手机号user_mobile = user.mobile # 构造响应数据data = &#123; \"user_name\": use_name, \"user_mobile\": user_mobile&#125; # 将响应数据返回给前端return jsonify(errno=RET.OK, errmsg=\"OK\", data=data) 4.显示头像和显示用户名和手机号前端编写（这里只演示显示头像的，后者可以自己尝试编写，基本一样，逻辑简单） 1234567891011121314151617$(document).ready(function()&#123; $.ajax(&#123; url:\"/api/v1.0/users/show_avatar\", type:\"post\", headers:&#123; \"X-CSRFToken\":getCookie(\"csrf_token\") &#125;, dataType:\"json\", success:function (resp) &#123; if (resp.errno == \"0\")&#123; var avatarUrl = resp.data.avatar_url; $('#user-avatar').attr(\"src\", avatarUrl) &#125;else &#123; alert(resp.errmsg); &#125; &#125; &#125;); 5.代码实现后的效果图 八丶最终效果动图注：这里以18111111111账号为例，进行动图演示 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/86302733","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之手机端租房网站的实战开发（七）","slug":"Flask项目之手机端租房网站的实战开发（七）","date":"2019-11-04T02:59:30.596Z","updated":"2019-11-13T12:57:24.494Z","comments":true,"path":"2019/11/04/Flask项目之手机端租房网站的实战开发（七）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/04/Flask项目之手机端租房网站的实战开发（七）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶登录后端接口编写 二丶登录接口测试 三丶登录前端编写 四丶用户登录功能测试 五丶定义检查登录状态与用户退出接口 六丶效果图","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶登录后端接口编写 二丶登录接口测试 三丶登录前端编写 四丶用户登录功能测试 五丶定义检查登录状态与用户退出接口 六丶效果图 一丶登录后端接口编写1.获取参数 123req_dict = request.get_json()mobile = req_dict.get(\"mobile\")password = req_dict.get(\"password\") 2.校验参数的完整性 12if not all([mobile, password]): return jsonify(errno=RET.PARAMERR, errmsg=\"请求参数不完整\") 3.校验手机号码格式 12if not re.match(r\"1[345789]\\d&#123;9&#125;\", mobile): return jsonify(errno=RET.PARAMERR, errmsg=\"手机号码格式错误\") 4.将用户登录的错误次数以用户的IP作为标识，保存到redis数据库中，通过redis数据库来限制时间，如次数超过10分钟内错误登录超过5次 step1 获取用户IP地址 1user_ip = request.remote_addr step2 判断用户登录错误次数是否超出限制 1234567try: access_nums = redis_store.get(\"access_nums_%s\" % user_ip)except Exception as e: current_app.logger.error(e)else: if access_nums is not None and int(access_nums) &gt;= constants.LOGIN_ERROR_MAX_TIMES: return jsonify(errno=RET.REQERR, errmsg=\"错误次数过多，请稍后重试\") 5.从数据库中根据用户手机号查询对应的数据对象user 12345try: user = User.query.filter_by(mobile=mobile).first()except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"获取用户信息失败\" 6.校验用户输入的手机号以及密码与数据库是否一致，将用户名(手机号)与密码放在一起进行校验，不管是密码错误还是用户名错误，返回的提示信息都为用户名或密码错误，不展示细节与前端上 step1 在models中定义一个校验密码的函数 1234567def check_password(self, passwd): \"\"\" 检验用户输入密码与数据库中密码是否一致 :param passwd: 用户输入的原始密码 :return: 匹配正确返回True 否则 返回false \"\"\" return check_password_hash(self.password_hash, passwd) step2 回过头在passport中进行校验 12if user is None or user.check_password(password) is False: return jsonify(errno=RET.DATAERR, errmsg=\"用户名或密码错误\") 7.验证失败需要记录失败次数，保存到redis数据库中 step1 通过redis数据库python中的incr方法累积保存access_nums_ip到redis数据库中 1redis_store.incr(\"access_nums_%s\" % user_ip) step2 设置access_nums_ip键的有效期 1redis_store.expire(\"access_nums_%s\" % user_ip, constants.LOGIN_ERROR_FORBID_TIME) step3 抛出异常，并记录到日志中 12345try: redis_store.incr(\"access_nums_%s\" % user_ip) redis_store.expire(\"access_nums_%s\" % user_ip, constants.LOGIN_ERROR_FORBID_TIME)except Exception as e: current_app.logger.error(e) 8.如果用户名和密码验证成功，则将登录成功状态保存到session中，并返回正确响应 12345session[\"name\"] = user.namesession[\"mobile\"] = user.mobilesession[\"user_id\"] = user.id return jsonify(errno=RET.OK, errmsg=\"登录成功\") 二丶登录接口测试1.在ihome/init中注释CSRF验证，运行程序 1python manage.py runserver 2.Postman测试工具中添加127.0.0.1:5000/api/v1.0/sessions登录接口路由 3.查看之前我们测试注册接口时注册的账号密码 4.在Postman工具中构造Body体JSON数据 step1 构造错误数据，输入错误密码，查看提示 step2 输入错误账号 step3 多次错误登录 查看数据库中保存的登录错误次数 step4 输入正确账号和密码 三丶登录前端编写1.前端登录HTML代码（不展示） 2.前端登录JS代码（不展示） 3.在login.js中在submit提交回调函数中进行如下编写 12345678910111213141516171819202122232425262728// 将表单的数据存到对象data中var data = &#123; mobile:mobile, password:passwd&#125;;// 将data数据转换成json字符串var jsonData = JSON.stringify(data);$.ajax(&#123; url:\"/api/v1.0/sessions\", type:\"post\", data:jsonData, contentType:\"application/json\", dataType:\"json\", headers:&#123; \"X-CSRFToken\":getCookie(\"csrf_token\") &#125;, success:function (data) &#123; if(data.errno == \"0\")&#123; // 则代表登录成功，跳转到主页 location.href = \"/\"; &#125; else &#123; // 登录不成功则在页面中显示错误信息 $(\"#password-err span\").html(data.errmsg); $(\"#password-err\").show(); &#125; &#125;&#125;) 4.在js构建一个getCookie的方法来获取前端名为csrf_token的cookie的值 1234function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125; 5.将获取的cookie的值，放在请求头中的X-CSRFToken键中，方便后端进行csrf验证（需将ihome/init中的CSRF验证开启） 123headers:&#123; \"X-CSRFToken\":getCookie(\"csrf_token\") &#125;, 四丶用户登录功能测试1.运行程序后，在http://127.0.0.1:5000/login.html 上进行测试 2.输入错误的账号或密码 3.输入正确的用户名和密码，跳转到主页（这里还没有完善，在登录成功后右上角不再显示登录与注册，而是显示登录时的用户名 ） 五丶定义检查登录状态与用户退出接口1.检查登录状态 12345678910111213@api.route(\"/session\", methods=[\"GET\"])def check_login(): \"\"\" 检查登录状态 :return: \"\"\" # 从注册和登录成功时保存到session数据中获取name的值 name = session.get(\"name\") # name不为空，则返回ok，并将name以字典形式传给前端，为空则返回对应错误信息 if name is not None: return jsonify(errno=RET.OK, errmsg=\"true\", data=&#123;\"name\":name&#125;) else: return jsonify(errno=RET.SESSIONERR, errmsg=\"false\") 2.用户退出(清除session数据) 12345678@api.route(\"/session\", methods=[\"DELETE\"])def logout(): \"\"\" 用户退出 清除session数据 :return: \"\"\" session.clear() return jsonify(errno=RET.OK, errmsg=\"OK\") 3.登录成功时，跳转到主页，那么在index.js中进行编写，因为是当页面加载完时需要显示出用户名，所以在$(document).ready下进行编写即可 123456789$.get(\"/api/v1.0/session\", function (resp) &#123; if (resp.errno == \"0\")&#123; $(\".top-bar&gt;.user-info&gt;.user-name\").html(resp.data.name); $(\".top-bar&gt;.user-info\").show(); &#125; else &#123; $(\".top-bar&gt;.register-login\").show(); &#125; &#125;\"json\"); 4.当登录成功后，主页右上角显示用户名（手机号），点击用户名进入后，在个人主页，点击退出再回到主页，此时主页右上角显示登录和注册，那么需要在my.js中进行如下代码编写 123456789101112131415function logout() &#123; $.ajax(&#123; url:\"/api/v1.0/session\", type:\"delete\", headers:&#123; \"X-CSRFToken\":getCookie(\"csrf_token\") &#125;, dataType:\"json\", success:function (resp) &#123; if (resp.errno == \"0\")&#123; location.href = \"/\" &#125; &#125; &#125;)&#125; 六丶效果图 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/86247891","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"/"}},{"title":"Flask项目之手机端租房网站的实战开发（六）","slug":"Flask项目之手机端租房网站的实战开发（六）","date":"2019-11-03T10:50:08.631Z","updated":"2019-11-13T12:41:43.114Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（六）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（六）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶补充 二丶短信验证码前端编写 三丶注册后端接口编写 四丶注册后端测试 五丶注册前端编写 六丶用户注册功能测试","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶补充 二丶短信验证码前端编写 三丶注册后端接口编写 四丶注册后端测试 五丶注册前端编写 六丶用户注册功能测试 一丶补充1.之前写的获取的图片验证码，有一个地方需要做进一步的处理，需要删除redis数据库中的图片验证码，防止用户使用同一个图片验证码验证多次，所以将删除代码放在取出redis数据库中图片验证码的值之后，也就是在real_image_code变量之后进行删除，这样即使删除了redis数据中的数据，也不会影响接下来的判断校验，这样做的目的就是说不管用户填对填错，只有一次验证机会 2.测试以上逻辑是否正确 step1 重新运行程序，刷新http://127.0.0.1:5000/register.html 注册页面 step2 查看redis数据库图片验证码的值 step3 在Postman工具中发送短信验证码路由地址 此时绑定的手机号码上就会收到我们定义的6位数验证码 step4 查看redis数据库(这个时候并没有超过180秒)，发现图片验证码的key已经被删除 3.短信验证码这一块，大多网站都会在用户发送第一次验证码后，在前端页面会出现60s后再试之类的提醒，那么对于后端来说，也是需要的，比如被人知道了后我端口的接口，1分钟之类不断的发送短信，那可就不好了，所以为了做到优化以及安全防范，那么就需要在后端进行一个禁止60s内发送第二次短信的一个逻辑，不仅仅限于前端 step1 逻辑分析，首先当发送第一次短信时，需要记住发送短信记录，当时间超过60s以上，才可以发送第二条短信，此时就需要想想是在什么时候将这个发送短信的记录存到redis数据库，大多公司是这样做的，不管发送成功与否，都是需要等待60s后才能发送第二次，所以我们这里也是这样做的，在发送短信之前就将记录存到redis数据库当中去 step2 当在保存短信验证码的时候，将这个第一次发送短信的记录存到redis数据库中，让redis数据库去维护记录的有效期60s，这个记录的数据随便起，这里设置1，那么当在redis数据库查询不到这个记录时，代表可以记录过了有效期被删除了，则代表可以发送第二条短信验证码了 1redis_store.setex(\"send_sms_code_%s\" % mobile, constants.SEND_SMS_CODE_INTERVAL, 1) step3 然后在判断手机号是否注册之前进行校验判断，判断对于此手机号码在60s以内有没有之前发送短信的操作，如果有，则不代表用户操作频繁，不予处理（注：经测试如果在判断获取记录的值的时候代码为if send_flag == 1时，会出现bug，所以建议使用is not None即可） 4.测试以上逻辑是否正常 step1 启动项目程序 step2 刷新http://127.0.0.1:5000/register.html 注册页面，生成新的图片验证码，将验证码内容以及对应编码通过发送短信路由发送到对应接口进行测试 step3 此时从redis数据库中查看图片验证码的id以及值 step4 在Postman工具中，对短信接口地址进行访问，并携带image_code以及image_code_id 同时收到手机短信验证码 step5 最关键的一步，与此同时，刷新图片验证码，获取新的图片验证码，然后在redis数据查询id以及图片验证码的值后在Postman中进行再次发送（注：这里的演示是在60s之内发送第二次请求给后端短信接口），出现如下提示，代表逻辑正确 二丶短信验证码前端编写1.在register.js中构造请求数据 1234var req_data = &#123; \"image_code\": imageCode, //用户输入图片验证码的值 \"image_code_id\": imageCodeId //对应图片验证码的编号 &#125;; 2.通过ajax方式想后端去发送请求 123456789101112131415161718192021222324// 想后端发送请求$.get(\"/api/v1.0/sms_codes/\"+mobile, req_data, function (resp) &#123; // 回调函数中的resp是后端返回的json字符串，通过ajax将这个字符串转换成js对象 // 所以这里的resp为ajax转换后的对象 if (resp.error == \"0\") &#123; // 表示发送成功 var num = 60; var timer = setInterval(function () &#123; if (num&gt;1) &#123; // 修改倒计时的文本内容 $(\".phonecode-a\").html(num + \"s\"); num -= 1 &#125; else &#123; $(\".phonecode-a\").html(\"获取验证码\"); $(\".phonecode-a\").attr(\"onclick\", \"sendSMSCode();\"); clearInterval(timer) &#125; &#125;, 1000, 60) &#125; else &#123; alert(resp.errmsg); $(\".phonecode-a\").attr(\"onclick\", \"sendSMSCode();\"); &#125; &#125;); 3.测试 step1 启动程序 step2 访问http://127.0.0.1:5000/register.html 注册界面 step3 输入手机号，图片验证码后点击获取短信验证码，成功出现倒计时，同时手机收到短信验证码 手机验证码 step4 在谷歌浏览器中查看接口地址的NetWork General数据 Response响应数据 三丶注册后端接口编写1.在项目api_1_0目录下创建passport.py文件用作于注册以及登录的逻辑接口文件 2.构建register视图函数，并在ihome/init文件中导入passport模块 123@api.route(\"/users\", methods=[\"POST\"])def register(): pass 3.逻辑编写 step1 获取前端请求发送请求中的json数据 12345req_dict = request.get_json()mobile = req_dict.get(\"mobile\") #跟前端约定好的sms_code = req_dict.get(\"sms_code\")password = req_dict.get(\"password\")password2 = req_dict.get(\"password2\") step2 校验参数 12if not all([mobile, sms_code, password, password2]): return jsonify(errno=RET.PARAMERR, errmsg=\"请求参数不完整\") step3 判断用户输入的手机号码格式 step4 从redis数据库中取出短信验证码 12345try: real_sms_code = redis_store.get(\"sms_code_%s\" % mobile)except Exception as e: current_app.logger.error(e) return jsonify(errno=RET.DBERR, errmsg=\"读取真实短信验证码异常\") step5 判断短信验证码是否过期 12if real_sms_code is None: return jsonify(errno=RET.NODATA, errmsg=\"短信验证码失效\") step6 判断用户输入的短信验证码是否正确 12if real_sms_code != sms_code: return jsonify(errno=RET.DATAERR, errmsg=\"短信验证码填写错误\") step7 同图片验证码一样，在redis数据库中进行删除，防止一个短信验证码多次使用 1234try: redis_store.delete(\"sms_code_%s\" % mobile)except Exception as e: current_app.logger.error(e) step8 判断用户的手机号是否注册过 step9 将用户注册的数据保存到mysql数据库中，这时候为了减少数据库的查询，不增加程序运行的负荷，所以我们在判断用户手机号是否注册过的时候，不再进行查询，而是在保存用户注册数据时候，判断手机号码是否存在，因之前在models中创建数据库表时，将mobile字段的数据设置为唯一约束，所以当数据库ih_user_profile表中已存在mobile字段的数据时，再进行插入相同手机号mobile的数据时，mysql数据库则会抛出异常，那么我们就利用数据库抛出的异常来判断手机号码是否存在，从而减少在视图函数中数据库的查询 数据库测试mobile字段异常 step10 注释step8代码重新编写，大体如下，因密码需要进行加密后再存到数据库，所以到最后面再进行处理 说明：这里的注册名为手机号，后面会另写接口让name为名字昵称，当出现异常时候，需要进行数据库回滚操作 step11 将登陆状态保存到session中，并返回注册成功结果 12345session[\"name\"] = mobilesession[\"mobile\"] = mobilesession[\"user_id\"] = user.id return jsonify(errno=RET.OK, errmsg=\"注册成功\") step12 将用户输入的密码进行加密 说明：将对用户输入的密码添加salt值(盐值)，再进行加密存储，说白了就是，在户输入的密码基础上再添加一个随机生成的字符串，即使用户1和用户2密码一样，但在进行salt处理后，在数据库中也不会相同，不存在撞库说法，这样做安全性极高，即使密码泄露，破解出来后也并不是用户的真是密码 问题：反过来当用户注册成功后，进行用户登录时，那么这个密码是如何进行判断？是将用户输入的密码进行加密后再和数据库加密密码进行对比，可是当初在注册时对用户输入的密码进行加密时候添加了随机的salt值，所以这里需要注意思考一下，我们这里的想法是通过在注册时候将salt值进行保存在数据库中另起一个字段，这是其一方法，其二是将这个salt值与加密后的密码中间以某个分隔符进行分隔，这样做的话就不用再创建表字段另存salt值，如qwe@ohcuncacaucaooa08c03qoca08q08，@符前为salt值，后为用户加密后的密码 注：MD5已被攻破，利用暴力测试以及算法公式成功反推出加密前的密码，sh1估计等不了几年就会被破解，我们这里使用的是sha256进行密码的加密 ①在models文件中通过导入werkzeug.security类中的generate_password_hash方法将密码进行加密，并存到数据库中 12def generate_password_hash(self, origin_password): self.password_hash = generate_password_hash(origin_password) ②在passport文件中，在构建User对象的时候，通过调用models文件中的generate_password_hash方法，将前端用户输入的password传参给此方法，并保存到User模型类的passwor_hash字段中 1user.generate_password_hash(password) 4.property装饰器的使用 step1 将函数调用转换为对象属性设置（在passport文件中） 1user.password = password step2 在models中注释之前的generate_password_hash方法的调用，使用property装饰器对新创建的password函数装饰为password属性(注，在passport文件中user.password对象的password属性名要与models文件中的方法同名)，再通过password属性的setter方法，设置类属性的值，这个值就是我们在passport文件中通过user.password = password这个password值 四丶注册后端测试 step1 因测试users注册后端接口使用的POST请求方式，而此时还没有编写注册前端端口测试，所以需要在ihome/init文件中将csrf后端机制关闭，再进行测试 12# 为flask补充csrf防护# CSRFProtect(app) step2 运行程序，在浏览器输入http://127.0.0.1:5000/register.html，进入注册页面 step3 在注册页面输入错误手机号，正确的图片验证码，当点击获取短信验证码时候，会提示发送短信失败，无所谓，我们从redis数据库直接读取sms_code即可 step4 在redis数据库中获取短信验证码(因为在上一步输入的是错误手机号，导致无法发送短信，测试无所谓嘛) step5 在测试工具Postman中，添加127.0.0.1:5000/api/v1.0/users地址，构造json格式的body体数据，就是我们注册页面所需要的数据，成功返回注册成功响应数据，代表注册后端接口没问题 step6 响应数据表示注册成功后，查看数据库ih_user_profile表信息，第一条数据是之前测试使用的 五丶注册前端编写1.前端注册HTML代码（不展示） 2.前端注册JS代码（不展示） 3.在register.js文件中通过ajax方式向后端接口发送注册请求（在callback for submit()） 1234567891011121314151617181920212223242526272829// 调用ajax向后端发送注册请求 var req_data = &#123; mobile:mobile, sms_code:phoneCode, password:passwd, password2:passwd2 &#125;; var req_json = JSON.stringify(req_data) $.ajax(&#123; url:\"/api/v1.0/users\", type:\"post\", data:req_json, contentType:\"application/json\", dataType: \"json\", headers:&#123; \"X-CSRFToken\":getCookie(\"csrf_token\") &#125;, success: function (resp) &#123; if (resp.errno== \"0\")&#123; // 注册成功，即跳转到主页 location.href = \"/index.html\"; &#125;else &#123; alert(resp.errmsg); &#125; &#125; &#125;) 4.在js构建一个getCookie的方法来获取前端名为csrf_token的cookie的值 1234function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125; 5.将获取的cookie的值，放在请求头中的X-CSRFToken键中，方便后端进行csrf验证（需将ihome/init中的CSRF验证开启） 123headers:&#123; \"X-CSRFToken\":getCookie(\"csrf_token\") &#125;, 六丶用户注册功能测试1.进行注册测试，输入不存在的号码是为了演示给大家，虽然提示发送短信验证码失败，但我可以从redis数据库去拿取短信验证码，注册成功后，即跳转到登录页面 2.用户注册成功后，查看数据库中ih_user_profile表的内容，成功将用户注册信息保存到数据库 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85934776","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（五）","slug":"Flask项目之手机端租房网站的实战开发（五）","date":"2019-11-03T09:54:24.218Z","updated":"2019-11-13T12:37:50.135Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（五）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（五）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶图片验证码前端编写 二丶短信验证码后端编写 三丶测试向后端接口发送短信验证码","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶图片验证码前端编写 二丶短信验证码后端编写 三丶测试向后端接口发送短信验证码 一丶图片验证码前端编写1.当用户进入到注册页后，页面进行刷新，所以在static前端静态资源register.js中定义一个generateImageCode函数，当页面加载完后，形成图片验证码的后端地址， 设置到页面中，让浏览请求验证码图片，同理在register.html中onclick点击验证码图片时，也要触发generateImageCode函数 register.html 1&lt;div class=\"input-group-addon image-code\" οnclick=\"generateImageCode();\"&gt;&lt;img src=\"\"&gt;&lt;/div&gt; register.js 12$(document).ready(function() &#123; generateImageCode();&#125; 2.生成图片验证码编号两种方式：第一种是时间轴；第二种是UUID全局唯一标识符，这里我们使用UUID step1 在js中获取UUID的值（这里在网上找的一个代码） 123456789101112function generateUUID() &#123; var d = new Date().getTime(); if(window.performance &amp;&amp; typeof window.performance.now === \"function\")&#123; d += performance.now(); //use high-precision timer if available &#125; var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) &#123; var r = (d + Math.random()*16)%16 | 0; d = Math.floor(d/16); return (c=='x' ? r : (r&amp;0x3|0x8)).toString(16); &#125;); return uuid;&#125; step2 在generateImageCode函数中调用generateUUID，将生成的UUID赋值给imageCodeId变量，记得先使用var在函数外声明该变量 1234function generateImageCode() &#123; // 生成图片验证码编号 imageCodeId = generateUUID();&#125; 3.拼接二维码图片的url地址，设置register.html中图片二维码div标签class=image_code下的img标签的src地址为拼接后的url，也就是二维码图片的链接地址 12var url = \"/api/v1.0/image_codes/\" + imageCodeId; $(\".image-code img\").attr(\"src\", url); 4.运行程序，清除浏览器缓存，输入http://127.0.0.1:5000/register.html后，查看注册页面二维码生成是否成功 5.在后端redis数据库中成功生成image_code_uuid的key了 6.效果图，鼠标连续点击图片验证码，请注意验证码 二丶短信验证码后端编写1.发送短信服务介绍，这里使用的是容联云，云通讯 step1 需要在官网https://www.yuntongxun.com/进行注册，注册时会通过打电话形式告诉你验证码，注册成功后会赠送8元测试费用，如下图 step2 然后选择测试平台，添加测试手机号，最多三个，验证成功才能添加上 step3 进入开发文档—Rest API—-短信—-短信发送接口，具体文档说明请到官网自寻查看 step4 我们直接去下载官方给开发人员封装好的工具SDK，找到Demo示例，然后在文章上方点击Demo下载，找到python语言对应的SDK进行下载即可 step5 解压后的目录文件如下，请查看README.txt等说明文件，DEMO问案列，这里我们只需要将SDK文件拷贝到项目中的libs目录下，并命名为yuntongxun，然后再将DEMO文件夹中的SendTemplateSMS.py文件拷贝到yuntongxun目录下 2.封装发送短信辅助工具 step1 在libs以及云通讯目录下创建init文件，使其变成python的包 step2 在SendTemplateSMS.py文件中创建一个CCP的类，用于封装发送短信的辅助类，目的是在我们调用sendTemplateSMS方法的时候，只初始化一次REST SDK，使用python单例达到不管创建多少个对象，都只初始化一次 step3 将云通讯开发者主账号中的ACCOUNT SID和AUTH TOKEN以及AppID，复制到代码中 step4 编写测试脚本，内容分为验证码9527，有效期5分钟，使用测试模板1 step5 运行sendTemplateSMS程序，最下面的statusCode为000000，代表短信发送成功，在官网短信接口有详细说明 step6 此时手机便收到了短信 step7 修改代码，不需要使用官方的代码将result字典数据进行遍历打印，而是只获取状态statusCode进行判断，如果为000000代表发送成功返回0，否则发送失败返回-1 查看运行结果，验证逻辑没有问题 step8 将sendTemplateSMS重命名为sendSMS，为了后面使用方便 3.定义获取短信接口 step1 在接口文件verify_code中定义一个get_sms_code的视图函数 1def get_sms_code() step2 构建路由规则，同理与构建图片验证码一样，使用restful风格，并且需要有一个短信验证码的编码，以手机进行编号，之前在分析图片验证码时，已经说过发送短信验证码时需携带图片验证码的文本内容以及图片验证码的编号，所以路由如下 1# GET /api/v1.0/sms_codes/&lt;mobile&gt;?image_code=xxxx&amp;image_code_id=xxxx step3 获取image_code以及image_code_id 12image_code = request.args.get(\"image_code\")image_code_id = request.args.get(\"image_code_id\") step4 校验参数 1234# 校验参数if not all([image_code, image_code_id]): # 参数不完整返回对应错误 return jsonify(errno=RET.PARAMERR, errmsg=\"参数不完整\") step5 业务逻辑处理，从redis数据库取出验证码与用户输入的验证码进行校验，期间需要对验证码是否存在进行判断 step6 接下来判断手机号是否存在 step7 随机生成6位数验证码（使用字符串格式化的方式来生成，从0到999999，当不足6位时，以0做填充） 1sms_code = \"%06d\" % random.randint(0, 999999) step8 在redis数据库中保存真实的短信验证码 step9 发送短信 step10 异常说明 放在try与except中的代码越少越好，会影响程序执行效率 三丶测试向后端接口发送短信验证码 step1 打开Postman测试工具，发送接口路由127.0.0.1:5000/api/v1.0/sms_codes/180xxxxxx96?image_code&amp;image_code_id step2 运行项目 step3 在浏览器输入http://127.0.0.1:5000/register.html，进入项目注册页面 step4 回到Postman工具，取消参数，什么都不传的情况下，出现如下错误信息，就是我们在程序中定义的错误信息 step5 此时刷新http://127.0.0.1:5000/register.html注册页，查看验证码，并在redis数据中获取验证码 获取redis数据库中图片验证码的文本值与注册页图片二维码的值一样 step6 当过了180s后也就是我们在constants.py中设置的图片验证码有效期，在Postman工具中发送地址，提示 我们定义的错误图片验证码失效，在程序中的逻辑为无法在redis数据库中获取image_code_id键的值，或者说不存在此键，返回结果为None step7 刷新注册页面，获取新的验证码，在Postman工具中向错误号码发送验证码，或者说是未在云通讯测试平台关联的号码发送验证码，则出现以下错误提示，这个提示就是我们在接口文件中写的res不等于0的时候，返回错误的json格式的错误信息 step8 刷新http://127.0.0.1:5000/register.html，将最新的验证码存储到redis数据库，在Postman工具中向正确地址发送正确号码，返回的响应数据为发送成功，如下图所示 注册页界面 redis数据库中的图片验证码值 Postman响应数据 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85858348","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（四）","slug":"Flask项目之手机端租房网站的实战开发（四）","date":"2019-11-03T09:26:31.303Z","updated":"2019-11-13T12:35:04.635Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（四）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（四）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶在项目中添加静态资源文件 二丶关于csrf防护机制 三丶用户注册模块（图片验证码以及短信验证码） 四丶测试后端verify_code接口是否正确","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶在项目中添加静态资源文件 二丶关于csrf防护机制 三丶用户注册模块（图片验证码以及短信验证码） 四丶测试后端verify_code接口是否正确 一丶在项目中添加静态资源文件1.将静态资源文件拷贝到项目static目录下 2.在终端上运行项目python manage.py runserver 3.在浏览器中输入http://127.0.0.1:5000/static/html/index.html 访问前端主页，如下图 4.当在不使用nginx服务器给用户提供静态资源，而是以flask来提供，当用户在浏览器中输入/static/html/index.html就会显得不友好，正常来说访问主页只需要输入ip地址或者是域名加端口号就可以了，那么就需要我们专门写个视图函数来提供有好的链接地址，把地址前缀给去掉 5.创建一个蓝图，专门负责提供静态文件的 step1 在ihome目录下创建一个web_html.py文件 step2 创建蓝图html 1html = Blueprint(\"web_html\", __name__) step3 在utils目录下创建一个init.py文件，使这个目录变成python的包，然后在这个utils包中创建commons.py文件，作为通用工具，在里面定义一个正则转换器 step4 在ihome/init文件中，在创建app对象时候，将ReConverter对象添加到app中 step5 回到commons.py文件中，定义视图函数get_html step6 在ihome/init中进入此蓝图注册 step7 启动项目 1python manage.py runserver step8 清除网页缓存数据 step9 在浏览器地址栏输入http://127.0.0.1:5000/就直接跳转到主页了index.html了 step10 输入http://127.0.0.1:5000/register.html也是没有问题的，直接跳转到register.html 二丶关于csrf防护机制1.csrf验证机制：从cookie中获取一个csrf_token的值，再从请求体中获取一个csrf_token的值，如果这两个值相同，则检验通过，可以进入视图函数中执行，如果两个值不同，则检验失败，会想前端返回状态码404的错，之前在ihome/init中设置的csrf只是负责验证，并不负责cookie与请求体中的csrf_token的值从哪里来 12# 为flask补充csrf防护CSRFProtect(app) 2.分析：前后端不分离时跟django一样直接在模板中进行设置csrf，而我们这个项目使用的是前后端分离，没有模板，对于cookie我们可以提前进行设置csrf_token，然后对于请求体中的cookie而言，当 发送POST请求时，就将那时候的请求体数据中设置csrf_token这样就能csrf防护了 3.设置cookie中的csrf_token step1 为web_html.py中导入csrf包 1from flask_wtf import csrf step2 创建一个csrf_token的值 1csrf_token = csrf.generate_csrf() step3 导入make_response，将返回的静态文件方法的值构建成响应对象 1resp = make_response(current_app.send_static_file(html_file_name)) step4 设置cookie的值，有效期为临时会话 1resp.set_cookie(\"csrf_token\", csrf_token) step5 重新启动程序，刷新网页，查看我们设置的cookie 三丶用户注册模块（图片验证码以及短信验证码）1.图片验证码使用流程 step1 分析流程： 第一步，需要前端像后端发起一个获取图片验证码的请求，对于后端来说就需要去生成一个随机的验证码图片；第二步将生成的验证码图片返回给前端；第三步验证图片验证码的准确性，如果正确，才能发起获取短信验证码的请求 step2 具体细节 在发起获取短信验证码请求的时候将携带填写的图片验证码与后端生成的图片验证码进行校验，因此后端在生成图片验证码的时候，需要将图片进行保存，意义是为了与用户输入的图片验证码进行对比，对比成功，才会给用户返回短信验证码 step3 问题分析 后端生成的图片验证码是存在哪里，谁来维护有效期，不可能一张图片一直用下去，所以将在后端生成的图片验证码，存到redis数据库中，在后端进行验证的时候，就从redis中取出这个值，与前端用户输入的值进行对比即可；但是对于多个用户来说同一时间向我发送获取图片验证码时，该怎么去判断谁是谁的，所以要将图片验证码进行编号处理，来分辨是属于哪个用户的图片验证码，那么就需要在用户发起短信验证码请求的携带参数里面除了填写的图片验证码，还需要携带一个用户编号，因此对于后端服务器来说，除了生成图片验证码的值，还需要生成一个对应验证码的编码，一起保存到redis数据库中，还需要将验证码值和编码返回给前端用户，那么就需要从返回的响应体中取解析编码，这样做太麻烦了，为了减轻后端的压力，将不再由后端去生成这个编码了，而是由前端在一开始就去生成这个编号，再前端向后端服务器发起获取图片验证码请求的时候携带一个编码参数，然后后端将编码和图片验证码的值一起存到redis数据库中 step4 在ihome/api_1_0目录下创建一个verify_code.py文件，将图片验证码以及短信验证码放在这个文件里面进行使用 step5 使用restful风格构建前端向后端发起图片验证码请求地址 1GET http://127.0.0.1:5000/api/v1.0/image_codes/&lt;image_code_id&gt; 2.图片验证码后端接口编写 step1 将图片验证码工具包captcha拷贝到ihome/utils目录下 step2 在verify.py中导入captcha包中的captcha模块中的captcha对象 1from ihome.utils.captcha.captcha import captcha step3 通过调用captcha对象中的generate_captcha方法来获取生成的验证码名字，文本内容，以及图片二进制数据 1name, text, image_data = captcha.generate_captcha() step4 选择存储数据类型，将验证码的文本内容以及编码存到redis数据库中，并设置有效期 可以使用哈希格式进行存储，但是无法设置单个图片的有效期 示例： 1\"image_codes\": &#123;\"id1\":\"abc\", \"\":\"\"&#125; 哈希 hset(\"image_codes\", \"id1\", \"abc\") hget(\"image_codes\", \"id1\") 使用字符串格式对数据进行存储，以编码作为key，以文本内容作为value值进行存储即可 示例： 1234\"image_code_编号1\": \"真实值\"\"image_code_编号2\": \"真实值\"redis_store.set(\"image_code_%s\" % image_code_id, text)redis_store.expire(\"image_code_%s\" % image_code_id, constants.IMAGE_CODE_REDIS_EXPIRES) step5 在verify.py中导入redis数据库连接对象，然后将编码和文本内容存到redis数据库 123from ihome import redis_store redis_store.set(\"image_code_%s\" %image_code_id, text) step6 设置图片验证码有效期为三分钟，首先在ihome目录下创建一个constants.py文件，用于存放常量 1redis_store.expire(\"image_code_%s\" %image_code_id, constants.IMAGE_CODE_REDIS_EXPIRES) 设置值和有效期一步到位 1redis_store.setex(\"image_code_%s\" %image_code_id, constants.IMAGE_CODE_REDIS_EXPIRES, text) step7 对于数据库连接，可能会出现连接错误以及连接不上等问题，所以需要捕获异常，并且将捕获到的异常保存到日志中 1current_app.logger.error(e) step8 当出现异常后，需要返回错误信息的json数据，先将工程项目定义好的response_code.py响应状态码文件，拷贝到utils中 1return jsonify(errno=RET.DBERR, errmsg=\"save image code failed\") step9 没有出现异常，则先通过make_response构造图片image_data数据响应体对象，再设置该响应体对象的请求头中的Content-Type为图片格式jpg，返回给前端 3.开发流程与编写接口文档 step1 开发流程 分析需求 编写代码 编写单元测试 自测 编写接口文档 提测代码 step2 编写接口文档 123456789101112131415161718192021222324252627282930313233接口文档 1. 接口名字2. 描述（描述清楚接口的功能）3. url4. 请求方式5. 传入参数6. 返回值 接口：获取图片验证码 描述：前端访问，可以获取到验证码图片 url： /api/v1.0/image_codes/&lt;image_code_id&gt; 请求方式： GET 传入参数： 格式：路径参数 （参数是查询字符串、请求体的表单、json、xml） 名字 类型 是否必须 说明 image_code_id 字符串 是 验证码图片的编号 返回值： 格式： 正常：图片， 异常：json 名字 类型 是否必传 说明 errno 字符串 否 错误代码 errmsg 字符串 否 错误内容 实例： &apos;&#123;&quot;errno&quot;: &quot;4001&quot;, &quot;errmsg&quot;: &quot;保存图片验证码失败&quot;&#125;&apos; 四丶测试后端verify_code接口是否正确1.需要在api_1_0/init中导入我们写的接口文件verify_code让蓝图知道有一个verify_code的模块 1from . import verify_code 2.运行程序 1python manage.py runserver 3.在浏览器中输入http://127.0.0.1:5000/api/v1.0/image_codes/123，成功显示出验证码图片 4.查看程序运行日志 5.此时查看redis数据库中，会发现出现了一个image_code_123的键，获取该键的值就是图片验证码的文本值，说明我们写的后端接口没问题 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85706012","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（三）","slug":"Flask项目之手机端租房网站的实战开发（三）","date":"2019-11-03T06:29:09.631Z","updated":"2019-11-13T12:32:17.095Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（三）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（三）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶关于在项目中循环导入的问题 二丶日志功能实现 三丶项目数据库设计 四丶数据库迁移","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶关于在项目中循环导入的问题 二丶日志功能实现 三丶项目数据库设计 四丶数据库迁移 一丶关于在项目中循环导入的问题1.在上一篇中创建api_1_0蓝图下的demo.py视图函数文件中，肯定会用到导入数据库db的，那么就会出现flask项目循环导包的问题，当启动项目时，会提示cannot import name db，这个提示就是代表循环导入包的问题 2.针对flask项目出现此问题的解决方法 step1 分析导包流程，首先在manage.py启动文件中，程序从上往下执行，一开始就从ihome包下导入数据库连接对象db，然后进入到ihome\\init.py文件中，同理执行到从ihome导入蓝图目录api_1_0时，即进入api_1_0\\init.py文件中，执行到导入相对路径下demo文件时，回到demo.py文件中，在该文件中从ihome包下导入db时，就会发现此时在ihome\\init.py文件中，并还没有执行到创建数据库db对象，所以程序执行到这一步时，就会提示以上错误 step2 解决方法，选择推迟导入，修改代码在什么时候需导入api_1_0时，我们就在什么后导入即可，发现在create_app方法中在注册蓝图的时候才需要导入api_1_0，所以将导入代码，放到此处即可 123# 注册蓝图from ihome import api_1_0app.register_blueprint(api_1_0.api, url_prefix=\"/api/v1.0\") step3 再次启动项目，就不会提示cannot import name db 了，成功解决flask项目中循环导入包的问题 3.一个完整的项目工程还需要在核心目录下创建项目所需的目录，用来分别存放包和库的，所以需在ihome目录下创建utils目录用来存放项目所需的工具包以及工具函数等，然后再创建一个libs目录用来存放第三方的库，不是通过pip install 安装的库，而是源码安装的库，这样才是完整的实战工程项目 二丶日志功能实现1.一个正常的网站包括软件等，都会有日志来记录历史操作信息等，在公司中一般会将存放日志目录与工程目录隔离开，这里为了方便演示，即将日志目录和工程目录放到一起，在项目根目录创建logs目录，用来存放日志文件 2.因为flask框架没有去提供日志这一块的库以及工具，所以我们就是用python记录日志标准库logging来进行日志记录保存 step1 在ihome/init文件中导入logging库 1import logging step2 并配置日志信息以及设置日志等级 step3 配置后日志信息后，需要在api_1_0/demo视图函数中进行记录日志，有两种方法，第一种是直接在demo文件中使用logging标准库模块，第二种是使用flask 框架中的全局上下文current_app对象，为什么能使用current_app对象，因为这个对象把logging模块中的logger塞到了这个对象中了 step4 启动项目，在浏览器输入http://127.0.0.1:5000/api/v1.0/index测试日志是否成记录并写入到logs目录下的log文件中 成功在logs目录下创建log日志文件，并将日志信息写入到该文件中 注： 在开发环境develop中配置了DEBUG=True调试模式下，会导致我们配置的日志等级，不生效，flask会强制忽略到我们配置的日志信息 三丶项目数据库设计1.分析项目所需要的表 step1 用户表User，先从注册界面来说，需要哪些字段(user_id，作为主键，手机号mobile，用户名name，密码password，存放头像的路径avatar_url，用户真实姓名real_name，真实身份证号real_id_card，验证码图片存到redis数据库即可) step2 房子表House，字段(house_id，作为主键，user_id，与用户表主键id保持一致，作为外键关联哪个用户的房子，一个用户有多套房子一对多关系，房子标题title，房子所在区域area_name，通过创建的Area表所以这里将area_name改为area_id通过外键来查询即可)思考：当查询房屋表中某个区域的数据时，select distinct area_name from house并去重，当数据很少的时候可以这样进行查询，随着时间推移导致数据达到几千万时，那么通过这样的方式查询数据，时间就会很长，不利于用户体验，所以这里需再创建一个区域表Area来解决查询时间过长的问题 step3 区域表Area，字段(area_id，作为主键，name区域名，price价格，image_url1,image_url2…)，Area表对于House表也是一对多关系，一个区域多个房子思考：在第四步我们将图片链接地址存到Area表中，那么今后如果用户上传图片扩大为10张，那么就需要改表结构，这样不是明智的选择，所以另建一个House_Image表来存储用户上传的房屋图片 step4 房屋图片表House_Image，字段(image_id，作为主键，url图片地址，house_id外键)，房子House表对于图片地址House_Image表一对多关系，一个房子有多张图片思考：分析需求，发现只有房屋详情时才会查询多张图片，而在查询列表和主页图片时，只需要一张，那么我们在房子表House中需添加一个index_image_url字段，这样做的目的是减少关联查询，在数据库中以空间换时间的理念来减少查询时间 step5 房屋配套设施表Facility，字段(facility_id，作为主键，name设施名字)思考：设施表Facility与房屋表House是多对多关系，一个设施如冰箱可以在多个不同房子中拥有，一个房子同时也可以拥有多个设备设施如电视，空调，wifi等，那么存储多对多关系的表数据，就需要创建一个中间表 step6 创建中间表House_Facility表，字段(id，作为主键，外键house_id和facility_id) step7 客户订单表Order，字段(order_id，作为主键，外键user_id哪个用户和house_id哪个房子，create_time订单创建时间，start_date入住日期，end_date离开日期，price房屋单价，amount合计金额，days入住天数，status订单状态，comment评价) 思考1：之所以要在Order订单表中创建price字段是考虑到比如房东在第二天需要将房屋价格上涨或者下降，保证用户是按实时价格进行计算的，加入amount不仅是为了前端，重要的是为了后期运营人员进行统计方便，节省统计的开销问题：关于房东拒绝订单是否填写拒绝原因，设定是必须填写拒绝原因，那么是需要在Order 表中添加一个字段么？分析：因为一旦填写拒绝原因那么就不存在comment评价了，所以这拒绝原因和评价两个关系为互斥关系，所以我们这里不添加拒绝原因字段，当有了评论信息那么肯定就不会出现拒绝原因，可以通过订单状态status来判断是评价还是拒绝原因思考2： 当在房源搜索房屋的时候，会出现按照最新上线，入住最多，价格高低排序，当按照入住最多排序时，那么就是相当于按照订单量最多的房屋进行排序，那么就需要在Order表中按照订单量来进行排序，首先就需要根据入住时间和区域来来进入过滤查询，还要将查询的结果安装订单量进行排序，这样查询代价就比较大了，那么同理还是使用以空间换时间的概念，在House表中添加order_count来订单量，当没下一单就在对应的order_count的值加1，回过来通过直接查询House表中的order_count字段按大小排序就能查询到订单最多的房屋了 2.在models.py中创建数据库抽象模型类 step1 定义BaseModel模型基类，用于为每个模型添加创建时间和更新时间 step2 定义User用户表 step3 定义Area城区表 step4 定义House房屋表 step5 定义Facility设施表 step6 定义HouseImage房屋图片表 step7 定义Order订单表 四丶数据库迁移 step1 初始化数据库对象db step2 执行迁移文件，结果提示No change in….. 解决：因为models.py文件对于其他文件来说，并不知道它的存在，所以只需要在视图文件demo中导入models即可 1from ihome import db, models step3 再次执行迁移 ，则显示迁移成功 step4 执行升级，将数据写入到mysql中的ihome_python数据库中 step5 以上步骤完成后，进入mysql，使用ihome_python数据库，查询数据库表成功生成 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85676643","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（二）","slug":"Flask项目之手机端租房网站的实战开发（二）","date":"2019-11-03T05:47:29.581Z","updated":"2019-11-13T12:29:09.964Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（二）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（二）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶创建项目 二丶创建工程目录(拆分manage.py) 三丶以开发环境进行项目测试","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶创建项目 二丶创建工程目录(拆分manage.py) 三丶以开发环境进行项目测试 一丶创建项目1.新建ihome_python项目文件夹 2.在Pycharm中打开此文件 ，并配置项目解释器(python2环境) 3.在工程目录下创建manage.py作为项目启动文件 step1 实现flask中最基本的工作 12345678910111213# coding:utf-8 from flask import Flask app = Flask(__name__) @app.route('/index')def index(): return \"index page\" if __name__ == '__main__': app.run() step2 配置mysql数据库用于存储用户数据 123456789101112class Config(object): \"\"\"配置信息\"\"\" DEBUG = True SECRET_KEY = \"cdtaogang**CSDN@uhduqw82981h\" # 连接mysql数据库 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/ihome_python\" SQLALCHEMY_TRACK_MODIFICATIONS = True app.config.from_object(Config) db = SQLAlchemy(app) step3 在本地mysql中创建ihome_python数据库 1create database ihome_python charset=utf8; step4 配置redis数据库用于保存session信息以及缓存数据（因为flask框架默认将session数据存到cookie中），所以这里需要利用flask_session这个工具包帮助我们将flask存储的session数据交给我们管理，这样就可以将session数据存到redis数据库中了 1234567891011121314151617181920class Config(object): \"\"\"配置信息\"\"\" DEBUG = True SECRET_KEY = \"cdtaogang**CSDN@uhduqw82981h\" # 连接mysql数据库 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/ihome_python\" SQLALCHEMY_TRACK_MODIFICATIONS = True # redis数据库配置 REDIS_HOST = \"127.0.0.1\" REDIS_PORT = 6379 app.config.from_object(Config) db = SQLAlchemy(app) #创建redis数据库连接对象redis_store = redis.StrictRedis(host=Config.REDIS_HOST, port=Config.REDIS_PORT) step5 配置flask_session用于我们操作session到redis数据库（说明在Config类中再次创建redis数据库连接，是因为在实际线上环境中，可能需要将session数据存到不同的服务器上） 12345678 # flask_session配置 SESSION_TYPE = \"redis\" SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) SESSION_USE_SIGNER = True # 对cookie中session_id进行隐藏处理 PERMANENT_SESSION_LIFETIME = 86400 # session数据的有效期，单位秒 # 利用flask_session， 将session数据保存到redis中Session(app) step6 开启csrf防护机制(导入flask_WTF中的CSRFProtect类) 12# 为flask补充csrf防护CSRFProtect(app) 二丶创建工程目录(拆分manage.py)1.拆分配置文件 step1 在项目根目录下创建一个config.py文件，将manage.py中的Config配置类放到该文件中 step2 工程实现后，有两种运行环境，开发测试环境以及生成环境(线上环境)，所以flask程序在运行时，就需要配置两个配置类，一个是用于开发环境，另一个用于生成环境 1234567class DevelopmentConfig(Config): \"\"\"开发环境配置信息\"\"\" DEBUG = True class ProductConfig(Config): \"\"\"生成环境配置信息\"\"\" pass step3 将app对象设计为工厂模式 step4 在config.py中创建配置映射 12345#构建配置映射关系config_map = &#123; \"develop\": DevelopmentConfig, \"product\": ProductConfig&#125; step5 导入config中的config_map，通过调用create_app方法，创建app对象，将我们需要的配置环境通过传参的方式来决定是用开发环境还是生产环境，在create_app方法中就按照指明的环境进行配置即可 step6 因最初创建的manage.py作为项目启动文件，所以我们在manage文件中只保留启动代码即可，需将其余代码抽离出去，保证manage文件中没有其他的代码，项目根目录下只需要保留启动文件manage以及config配置文件，即在项目根目录下创建一个ihome的python包，将create_app代码放到这个ihome包的init文件中即可，随后在ihome包下创建一个static目录用于存放静态文件，再创建一个models.py文件用于做数据库的迁移 step7 在manage中创建并绑定app对象的代码，放到init中，会导致无法绑定create_app方法里面的app，所以使用SQLAlchemy对象db提供的init_app方法，在create_app方法里面对db进行初始化，这样就解决了 step8 在models.py文件中导入数据库对象db 1from ihome import db step9 将manage文件中创建的redis数据库连接对象放到init文件中，需要思考是否放在create_app方法中，因为最初在manage文件中创建的redis数据库连接需要从config文件中拿去host以及port配置，所以我们在全局声明redis_store变量为None，然后在方法中通过config_map获取的环境配置类config_class，说白了也就是config中的开发类DevelopmentConfig，直接拿去类中我们配置好的r连接redis数据库的port和host step10 对于Session(app)和CSRFProtect(app)，不会用到这两个对象来进行进一步操作，只是刚开始使用这两个对象来初始化app，一个是为了我们将session数据存到redis数据库，另一个是为了开启CSRF防护机制，所以直接放到create_app类即可 12345# 利用flask_session， 将session数据保存到redis中Session(app) # 为flask补充csrf防护CSRFProtect(app) step11 创建蓝图，用于管理不同版本的视图，在ihome核心目录下创建一个api_1_0python包，代表1.0版本的蓝图，在这个蓝图下就可以创建各种各样的视图了，在api_1_0蓝图下创建一个demo.py文件，将启动文件manage中的视图函数放到里面 123@app.route('/index')def index(): return \"index page\" step12 在api_1_0包下的init文件中创建蓝图 step13 在flask项目应用文件init中注册蓝图 ，首先在init文件中通过绝对路径导入api_1_0包，再通过app应用对象中的register_blueprint方法，注册api_1_0包中的api蓝图名字，并定义url前缀地址为/api/v1.0表示1.0版本 12# 注册蓝图app.register_blueprint(api_1_0.api, url_prefix=\"/api/v1.0\") step14 在创建工程时，可能会用到数据库models文件，那么就需要使用迁移插件，从flask_script中引入脚本命令管理对象，再从flask_migrate中导入迁移执行者Migrate，迁移命令解析人员Migratecommand / 三丶以开发环境进行项目测试 step1 在Pycharm终端中，执行python manage.py runserver 默认端口，运行项目 step2 打开浏览器输入http://127.0.0.1:5000/api/v1.0/index，测试运行项目是否成功 在浏览器中成功渲染出index视图函数返回的字符串，如下图 step3 回到Pycharm终端查看程序日志，请求方式和地址以及状态码都是完全正确，代表项目设计成功 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85623829","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"Flask项目之手机端租房网站的实战开发（一）","slug":"Flask项目之手机端租房网站的实战开发（一）","date":"2019-11-03T05:22:54.117Z","updated":"2019-11-16T03:32:06.277Z","comments":true,"path":"2019/11/03/Flask项目之手机端租房网站的实战开发（一）/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/Flask项目之手机端租房网站的实战开发（一）/","excerpt":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶项目介绍 二丶前后端分离 三丶项目需求","text":"该篇文章是博主一字一码编写的，实属不易，请尊重原创，谢谢大家！温馨提示：需要项目源码的朋友，请添加博主微信进行获取！ &nbsp;&nbsp;本文目录 一丶项目介绍 二丶前后端分离 三丶项目需求 一丶项目介绍 产品：关于手机移动端的租房网站 角色：在这个产品中用户包括房东与房客 功能：房东可以在这个平台发布自己的房屋，房客可以在这个平台寻找自己想要租的房子(类似短租平台) 设计模式：使用前后端分离进行项目开发(后端不再控制前端的效果展示) 前端效果展示 二丶前后端分离 前后端分离的认识 叙述：用户直接在浏览器中输入网址，不再是后端对应的动态逻辑了，而是一个静态页面从/index 变成了 index.html文本文件，对于静态资源就从提供静态资源服务器中去拿(nginx)前端页面中对于数据这块的需求必定是从后端拿去数据，后端也不需要去渲染模板，直接将前端需要的数据转换成json格式字符串返回给前端即可(通过jquery以及其他前端框架去将数据渲染到页面)具体做成什么效果，跟后端没有什么关系，前端什么时候需要数据，后端就给数据，这就是前后端分离。 优点：无论对于手机上的浏览器还是app程序向后端拿数据时，只要在后端已经定义好了接口，这个接口都是可以直接用的，体现出后端接口的复用性。 流程：用户在浏览器中输入网址的时候，需要向后端(nginx)去要网页，在这个网页中没有任何的数据，只是普通的前端呈现的样式而已，在这个网页当中的js里面，通过ajax方式向后端接口要取数据，后端接口当中给前端返回的是json字符串，前端拿到这个字符串在到ajax回调函数中，通过jquery方式把数据填充到页面上。 缺点：对于搜索引擎优化SEO不友好，无法将网页的数据通过搜索引擎搜索关键字查询此网页信息，爬虫拿取页面信息，并没有任何数据，导致在搜索引擎上排名无法靠前 三丶项目需求需求功能 主页 1.1 最多5个房屋logo图片展示，点击可跳转至房屋详情页面 1.2 提供登陆/注册入口，登陆后显示用户名，点击可跳转至个人中心 1.3 用户可以选择城区、入住时间、离开时间等条件进行搜索 1.4 城区的区域信息需动态加载 注册 2.1 用户账号默认为手机号 2.2 图片验证码正确后才能发送短信验证码 2.3 短信验证码每60秒可发送一次 2.4 每个条件出错时有相应错误提示 登陆 3.1 用手机号与密码登陆 3.2 错误时有相应提示 房屋列表页 4.1 可根据入住离开时间、区域进行筛选，并可进行排序 4.2 房屋信息分页加载 4.3 区域信息动态加载 4.4 筛选条件更新后，页面立即刷新 房屋详情页 5.1 需展示的详细信息参考设计图 5.2 提供预定入口 5.3 若是房东本人查看房屋信息时，预定入口不显示 房屋预定 6.1 由用户确定入住时间 6.2 根据用户确定的入住离开时间实时显示合计天数与总金额 我的爱家 7.1 显示个人头像、手机号、用户名（用户名未设置时为用户手机号） 7.2 提供修改个人信息的入口 7.3 提供作为房客下单的查询入口 7.4 提供成为房东所需实名认证的入口 7.5 提供作为房东发布房屋信息的入口 7.6 提供作为房东查询客户订单的入口 7.7 提供退出的入口 个人信息修改 8.1 可以修改个人头像 8.2 可以修改用户名 8.3 登陆手机号不能修改 8.4 上传头像与用户名分开保存 8.5 上传新头像后页面理解显示新头像 我的订单（房客） 9.1 按时间倒序显示订单信息 9.2 订单完成后提供评价功能 9.3 已评价的订单能看到评价信息 9.4 被拒绝的订单能看到拒单原因 实名认证10.1 实名认证只可进行一次10.2 提交认证信息后再次进入只能查看信息，不能修改10.3 认证信息包含姓名与身份证号 我的房源11.1 未实名认证的用户不能发布新房源信息，需引导到实名认证页面11.2 按时间倒序显示已经发布的房屋信息11.3 点击房屋可以进入详情页面11.4 对实名认证的用户提供发布新房屋的入口 发布新房源12.1 需要用户填写全部房屋信息12.2 房屋的文字信息与图片分开操作 客户订单（房东）13.1 按时间倒序显示用户下的订单13.2 对于新订单提供接单与拒单的功能13.3 拒单必须填写拒单原因13.4 若客户进行了订单评价，需显示 退出14.1 提供退出功能 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85613780","categories":[{"name":"Flask开发","slug":"Flask开发","permalink":"https://hellotaogang.github.io/categories/Flask开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"Flask网站实战开发","slug":"Flask网站实战开发","permalink":"https://hellotaogang.github.io/tags/Flask网站实战开发/"},{"name":"手机端租房网站开发","slug":"手机端租房网站开发","permalink":"https://hellotaogang.github.io/tags/手机端租房网站开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"微信公众号开发之微信网页授权获取用户个人信息","slug":"微信公众号开发之微信网页授权获取用户个人信息","date":"2019-11-03T04:24:17.193Z","updated":"2019-11-03T06:27:22.702Z","comments":true,"path":"2019/11/03/微信公众号开发之微信网页授权获取用户个人信息/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/微信公众号开发之微信网页授权获取用户个人信息/","excerpt":"","text":"一丶概述 微信网页授权 如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。 现在，我们要实现一个微信内网页，通过微信访问网页时，网页会展示微信用户的个人信息。因为涉及到用户的个人信息，所以需要有用户授权才可以。当用户授权后，我们的网页服务器（开发者服务器）会拿到用户的“授权书”（code）,我们用这个code向微信服务器领取访问令牌（accecc_token）和用户的身份号码（openid)，然后凭借access_token和openid向微信服务器提取用户的个人信息。 第一步：用户同意授权，获取code 第二步：通过code换取网页授权access_token 第三步：拉取用户信息(需scope为 snsapi_userinfo) 那么，如何拿到用户的授权code呢？ 授权是由微信发起让用户进行确认，在这个过程中是微信在与用户进行交互，所以用户应该先访问微信的内容，用户确认后再由微信将用户导向到我们的网页链接地址，并携带上code参数。我们把这个过程叫做网页回调，类似于我们在程序编写时用到的回调函数，都是回调的思想。 关于网页授权回调域名的说明 1、在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；关于网页授权回调域名的说明 2、授权回调域名配置规范为全域名，比如需要网页授权的域名为：www.qq.com，配置以后此域名下面的页面http://[www.qq.com/music.html](www.qq.com/music.html) 、 http://www.qq.com/login.html 都可以进行OAuth2.0鉴权。但http://pay.qq.com 、 http://music.qq.com 、 http://qq.com无法进行OAuth2.0鉴权 3、如果公众号登录授权给了第三方开发者来进行管理，则不必做任何设置，由第三方代替公众号实现网页授权即可。 第一步：用户同意授权，获取code在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），引导关注者打开如下页面： https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 尤其注意：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问 参考链接(请在微信客户端中打开此链接体验):scope为snsapi_basehttps://open.weixin.qq.com/connect/oauth2/authorize?appid=wx520c15f417810387&amp;redirect_uri=https%3A%2F%2Fchong.qq.com%2Fphp%2Findex.php%3Fd%3D%26c%3DwxAdapter%26m%3DmobileDeal%26showwxpaytitle%3D1%26vb2ctag%3D4_2030_5_1194_60&amp;response_type=code&amp;scope=snsapi_base&amp;state=123#wechat_redirectscope为snsapi_userinfohttps://open.weixin.qq.com/connect/oauth2/authorize?appid=wxf0e81c3bee622d60&amp;redirect_uri=http%3A%2F%2Fnba.bluewebgame.com%2Foauth_response.php&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirec 尤其注意：跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。 参数说明 参数 是否必须 说明 appid 是 公众号的唯一标识 redirect_uri 是 授权后重定向的回调链接地址， 请使用 urlEncode 对链接进行处理 response_type 是 返回类型，请填写code scope 是 应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ） state 否 重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节 #wechat_redirect 是 无论直接打开还是做页面302重定向时候，必须带此参数 下图为scope等于snsapi_userinfo时的授权页面： 用户同意授权后 如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE。 code说明： code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期。 第二步：通过code换取网页授权access_token首先请注意，这里通过code换取的是一个特殊的网页授权access_token,与基础支持中的access_token（该access_token用于调用其他接口）不同。公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。 尤其注意：由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起。 请求方法 获取code后，请求以下链接获取access_token： https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 参数说明 参数 是否必须 说明 appid 是 公众号的唯一标识 secret 是 公众号的appsecret code 是 填写第一步获取的code参数 grant_type 是 填写为authorization_code 返回说明 正确时返回的JSON数据包如下： 12345&#123; \"access_token\":\"ACCESS_TOKEN\",\"expires_in\":7200,\"refresh_token\":\"REFRESH_TOKEN\",\"openid\":\"OPENID\",\"scope\":\"SCOPE\" &#125; 参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 expires_in access_token接口调用凭证超时时间，单位（秒） refresh_token 用户刷新access_token openid 用户唯一标识，请注意，在未关注公众号时，用户访问公众号的网页，也会产生一个用户和公众号唯一的OpenID scope 用户授权的作用域，使用逗号（,）分隔 错误时微信会返回JSON数据包如下（示例为Code无效错误）: 1&#123;\"errcode\":40029,\"errmsg\":\"invalid code\"&#125; 第三步：拉取用户信息(需scope为 snsapi_userinfo)如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。 请求方法 http：GET（请使用https协议） https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN 参数说明 参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 openid 用户的唯一标识 lang 返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语 返回说明 正确时返回的JSON数据包如下： 12345678910&#123; \"openid\":\" OPENID\",\" nickname\": NICKNAME,\"sex\":\"1\",\"province\":\"PROVINCE\"\"city\":\"CITY\",\"country\":\"COUNTRY\",\"headimgurl\": \"http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46\",\"privilege\":[ \"PRIVILEGE1\" \"PRIVILEGE2\" ],\"unionid\": \"o6_bmasdasdsad6_2sgVt7hMZOPfL\"&#125; 参数 描述 openid 用户的唯一标识 nickname 用户昵称 sex 用户的性别，值为1时是男性，值为2时是女性，值为0时是未知 province 用户个人资料填写的省份 city 普通用户个人资料填写的城市 country 国家，如中国为CN headimgurl 用户头像，最后一个数值代表正方形头像大小（有0、46、64、96、132数值可选，0代表640*640正方形头像），用户没有头像时该项为空。若用户更换头像，原有头像URL将失效。 privilege 用户特权信息，json 数组，如微信沃卡用户为（chinaunicom） unionid 只有在用户将公众号绑定到微信开放平台帐号后，才会出现该字段。 错误时微信会返回JSON数据包如下（示例为openid无效）: 1&#123;\"errcode\":40003,\"errmsg\":\" invalid openid \"&#125; 二丶代码实现 思路分析 首选在我们的flask程序中需要定义一个视图函数路由规则为/wechat8007/index，定义微信服务器重定向网址redirect_uri为服务器域名+/wechat8007/index（例如http://www.xxxx.com/wechat8007/index），通过访问微信提供的引导页面，让用户同意授权，然后重定向到我们定义的网址，此时微信服务器就会给我们的服务一个code，我们的服务器再通过code向微信服务器换取网页授权access_token(存取令牌)，如果网页授权作用域为snsapi_userinfo，则此时可以通过access_token和openid拉取用户信息了。 step1 同意授权，这一块不需要代码实现，只需要提供授权链接即可 step2 定义视图函数，当用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE ，在flask程序中定义一个是视图函数接口index，让用户同意授权后，去访问的视图 上一篇博客定义的wechat视图，是由微信服务器访问，现在定义的index视图为用户访问的 123@app.route(\"/wechat8007/index\")def index(): \"\"\"让用户通过微信访问的网页页面视图\"\"\" step3 刚开始还没拉去用户资料时，可直接返回一个模板 1return render_template(\"index.html\") step4 从微信服务器中获取用户的资料数据，将用户的资料数据填充到index.html模板中 1.获取code参数 1code = request.args.get(\"code\") 2.当code不存在时，返回字符串 12if not code: return u\"缺失code参数\" 3.向微信服务器发送http请求，获取access_token，在获取之前要在代码定义全局变量WECHAT_APPID以及WECHAT_APPSECRET的值，用来填充https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 微信提供获取access_token链接地址中的APPID以及SECRET和CODE的值，再通过python中的urllib2库向这个url发送请求，read方法读取文本内容获取json格式的字符串，然后使用json当中的loads方法将json格式的字符串转换为字典 1234567url = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&amp;secret=%s&amp;code=%s&amp;grant_type=authorization_code\" %(WECHAT_APPID,WECHAT_APPSECRET,code) response = urllib2.urlopen(url) # 获取响应体数据,微信返回的json数据json_str = response.read()resp_dict = json.loads(json_str) 4.提取access_token，首先对获取到的响应体数据进行判断，如果不存在，直接返回提示字符串，存在则通过get方式拿去字典中的access_token键的值以及用户编号openid的值 12345if \"errcode\" in resp_dict: return u\"获取access_token失败\" access_token = resp_dict.get(\"access_token\")open_id = resp_dict.get(\"openid\") # 用户的编号 step5 向微信服务器发送http请求，获取用户的资料数据 1234567url = \"https://api.weixin.qq.com/sns/userinfo?access_token=%s&amp;openid=%s&amp;lang=zh_CN\" %(access_token,open_id) response = urllib2.urlopen(url) # 读取微信传回的json的响应体数据user_json_str = response.read()user_dict_data = json.loads(user_json_str) step6 判断微信返回的响应体数据中是否有errorcode字段，如果存在则返回失败信息，不存在说明微信返回的json数据为正确数据，则将该数据传给index.html模板，当用户访问http://xxx/wechat8007/index地址时，会渲染出我们定义的index.html模板 12345if \"errcode\" in user_dict_data: return u\"获取用户信息失败\"else: # 将用户的资料数据填充到页面中 return render_template(\"index.html\", user=user_dict_data) step7 当前目录下创建templates模板目录，在该目录中创建index.html文件 ，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&#123;&#123;user[\"nickname\"]&#125;&#125;的个人主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img alt=\"头像\" src=\"&#123;&#123;user['headimgurl']&#125;&#125;\" width=\"60\"&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;openid&lt;/th&gt; &lt;td&gt;&#123;&#123;user[\"openid\"]&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;昵称&lt;/th&gt; &lt;td&gt;&#123;&#123;user[\"nickname\"]&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;性别&lt;/th&gt; &lt;td&gt; &#123;% if 1 == user[\"sex\"] %&#125; 男 &#123;% elif 2 == user[\"sex\"] %&#125; 女 &#123;% else %&#125; 未知 &#123;% endif %&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;省份&lt;/th&gt; &lt;td&gt;&#123;&#123;user[\"province\"]&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;城市&lt;/th&gt; &lt;td&gt;&#123;&#123;user[\"city\"]&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;国家&lt;/th&gt; &lt;td&gt;&#123;&#123;user[\"country\"]&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 三丶部署测试 step1 将代码推送到服务器上 成功推送到服务器上 step2 在服务器上进入虚拟环境，运行此程序 step3 拼接微信提供网址 https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 注：正式公众号redirect_uri地址必须为服务器的域名地址，不能是IP地址 在拼接redirect_uri时，服务器的域名为http://www.xxx.com/wechat8007/index，微信提供的授权地址http://中不可能包含一个redirect_uri为http://www.xxx.com/wechat8007/index用户同意授权后跳转的地址，所以需要对重定向地址http://www.xxx.com/wechat8007/index 进行转义 使用python urllib库中的quote方法进行转义 1234In [1]: import urllib In [2]: urllib.quote(\"http://www.xxx.com/wechat8007/index\")Out[2]: 'http%3A//www.xxx.com/wechat8007/index' 拼接好的用户访问的url地址为 step4 可以将该网址生成二维码，使用微信扫一扫，也可以在接口公众号直接发送此链接地址 使用谷歌浏览器的二维码插件，将网址生成对应的二维码(这里以百度首页网址为例) 直接在浏览器中输入此地址会提示请在微信客户端打开链接 step5 测试，在手机微信上打开此链接，出现授权登录提示，点击允许即可获取用户个人信息 点击允许后，进入如下界面 点击继续访问，则出现博主个人的微信信息了，如下图 此时查看服务器上程序运行日志 四丶完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# coding:utf-8from flask import Flask, request, render_templateimport json, urllib2 WECHAT_APPID = \"yourappid\"WECHAT_APPSECRET = \"yoursecret\" app = Flask(__name__) @app.route(\"/wechat8007/index\")def index(): code = request.args.get(\"code\") if not code: return u\"缺失code参数\" url = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&amp;secret=%s&amp;code=%s&amp;grant_type=authorization_code\" % (WECHAT_APPID, WECHAT_APPSECRET, code) response = urllib2.urlopen(url) json_str = response.read() resp_dict = json.loads(json_str) if \"errcode\" in resp_dict: return u\"获取access_token失败\" access_token = resp_dict.get(\"access_token\") open_id = resp_dict.get(\"openid\") url = \"https://api.weixin.qq.com/sns/userinfo?access_token=%s&amp;openid=%s&amp;lang=zh_CN\" % (access_token, open_id) response = urllib2.urlopen(url) user_json_str = response.read() user_dict_data = json.loads(user_json_str) if \"errcode\" in user_dict_data: return u\"获取用户信息失败\" else: return render_template(\"index.html\", user=user_dict_data) if __name__ == '__main__': app.run(port=8007, debug=True) 总结：微信公众号接口开发，根据官方提供的开发文档，进行开发，逻辑实现都很简单，多想多思考多练习，你会越来越棒的！ ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85334634","categories":[{"name":"WeChat开发","slug":"WeChat开发","permalink":"https://hellotaogang.github.io/categories/WeChat开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://hellotaogang.github.io/tags/微信公众号/"},{"name":"微信开发","slug":"微信开发","permalink":"https://hellotaogang.github.io/tags/微信开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"微信公众号开发之接收与发送消息","slug":"微信公众号开发之接收与发送消息","date":"2019-11-03T03:54:41.583Z","updated":"2019-11-03T06:26:46.502Z","comments":true,"path":"2019/11/03/微信公众号开发之接收与发送消息/","link":"","permalink":"https://hellotaogang.github.io/2019/11/03/微信公众号开发之接收与发送消息/","excerpt":"","text":"一丶概论 公众号接收与发送消息 验证URL有效性成功后即接入生效，成为开发者。如果公众号类型为服务号（订阅号只能使用普通消息接口），可以在公众平台网站中申请认证，认证成功的服务号将获得众多接口权限，以满足开发者需求。 此后用户每次向公众号发送消息、或者产生自定义菜单点击事件时，开发者填写的服务器配置URL将得到微信服务器推送过来的消息和事件，然后开发者可以依据自身业务逻辑进行响应，例如回复消息等。 用户向公众号发送消息时，公众号方收到的消息发送者是一个OpenID，是使用用户微信号加密后的结果，每个用户对每个公众号有一个唯一的OpenID。 1.接收普通消息当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上。 微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。假如服务器无法保证在五秒内处理并回复，可以直接回复空串，微信服务器不会对此作任何处理，并且不会发起重试。 各消息类型的推送使用XML数据包结构，如： 12345678&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[gh_866835093fea]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[ogdotwSc_MmEEsJs9-ABZ1QL_4r4]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1478317060&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;&lt;MsgId&gt;6349323426230210995&lt;/MsgId&gt;&lt;/xml&gt; 注意：&lt;![CDATA 与 ]]&gt; 括起来的数据不会被xml解析器解析 2.普通消息类别 文本消息 图片消息 语音消息 视频消息 小视频消息 地理位置消息 链接消息 文本消息 12345678&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt; 3. 回复的消息类型 文本消息 图片消息 语音消息 视频消息 音乐消息 图文消息 回复文本消息 1234567&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;&lt;/xml&gt; 注：开发文档可以到 https://mp.weixin.qq.com/wiki/home/index.html 进行阅读查看 二丶代码实现需求：我们现在来实现一个针对文本消息的收发程序。实现的业务逻辑，关注者发什么内容，我们就传回给什么内容。 说明：微信服务器推送消息还是往/wechat/8007，所以在之前代码上进行修改即可 1.开发步骤 step1 如何区分微信服务器发过来的是第一次的验证操作还是消息操作 验证操作为GET请求，消息操作为POST请求 1@app.route(\"/wechat8007\", methods=[\"GET\", \"POST\"]) step2 参数变更，echostr参数只是在第一次验证的时候需要，无论是POST请求还是GET请求这三种参数都必要要，因为需要验证是不是微信服务器发送过来的数据 123signature = request.args.get(\"signature\")timestamp = request.args.get(\"timestamp\")nonce = request.args.get(\"nonce\") step3 对微信服务器发送的请求进行验证判断，如果是GET请求，那么代表是第一次的验证操作，那么就需要获取echostr字段的内容，如果内容为空则抛出404，存在则返回echostr 123456if request.method == \"GET\": # 表示是第一次接入微信服务器的验证 echostr = request.args.get(\"echostr\") if not echostr: abort(404) return echostr step4 如果为POST请求，那么代表为微信服务器转发消息过来，获取请求中的data xml数据 ，数据为空抛出400 12345elif request.method == \"POST\": # 表示微信服务器转发消息过来 xml_str = request.data if not xml_str: abort(400) step5 将对获取的数据进行解析，通过xmltodict模块中的parse方法将字符串类型的xml数据，转换成字典类型的xml格式数据，因为xml数据最外层有一个标签，通过get方式获取标签里的内容，再通过get获取内容中的MsgType消息类型字段的值 123456# 对xml字符串进行解析xml_dict = xmltodict.parse(xml_str)xml_dict = xml_dict.get(\"xml\") # 提取消息类型msg_type = xml_dict.get(\"MsgType\") step6 对消息类型进行判断，如果为text文本消息，则返回文本消息，不是文本消息还是返回文本消息，这里可以拓展为(image，voice，video等等可以查看开发文档)，这里为了演示，就简单写写 12345678910111213141516171819202122 if msg_type == \"text\": # 表示发送的是文本消息 # 构造返回值，经由微信服务器回复给用户的消息内容 resp_dict = &#123; \"xml\": &#123; \"ToUserName\": xml_dict.get(\"FromUserName\"), \"FromUserName\": xml_dict.get(\"ToUserName\"), \"CreateTime\": int(time.time()), \"MsgType\": \"text\", \"Content\": \"taogang say:\" + xml_dict.get(\"Content\") &#125; &#125;else: resp_dict = &#123; \"xml\": &#123; \"ToUserName\": xml_dict.get(\"FromUserName\"), \"FromUserName\": xml_dict.get(\"ToUserName\"), \"CreateTime\": int(time.time()), \"MsgType\": \"text\", \"Content\": \"Dear I Love you so much\" &#125; &#125; step7 最后将我们构造的响应返回值通过unparse方法转换成xml格式的字符串，返回给微信服务器 1234# 将字典转换为xml字符串resp_xml_str = xmltodict.unparse(resp_dict)# 返回消息数据给微信服务器return resp_xml_str 2.部署测试 step1 将代码推送到服务器上 step2 在服务器上进入虚拟环境，运行此程序 step3 进入微信公众平台，用手机扫描测试号二维码，进行关注测试 扫码后进行关注 关注后进入此公众号，公众号则发送我们在开发步骤step 6，Dear I Love you so much 消息内容 回到服务器程序运行日志上，显示为POST请求，说明程序逻辑完全没问题 公众号测试平台用户列表将我的微信添加上去了 step4 测试，在关注的此公众中，进行消息(文本，表情，语言，图片，视频）发送，当消息类型为文本时，即返回此消息内容，如果不是都是返回文本类型，内容为Dear I Love you so much 此时的服务器代码运行日志 3.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# coding:utf-8from flask import Flask, request, abort, render_templateimport hashlibimport xmltodict, time # 常量# 微信的token令牌WECHAT_TOKEN = \"cdtaogang\" app = Flask(__name__) @app.route(\"/wechat8007\", methods=[\"GET\", \"POST\"])def wechat(): \"\"\"对接微信公众号服务器\"\"\" # 接收微信服务器发送的参数 signature = request.args.get(\"signature\") timestamp = request.args.get(\"timestamp\") nonce = request.args.get(\"nonce\") if not all([signature, timestamp, nonce]): abort(400) # 按照微信的流程进行计算签名 li = [WECHAT_TOKEN, timestamp, nonce] # 排序 li.sort() # 拼接字符串 tmp_str = ''.join(li) # 进行sha1加密, 得到正确的签名值 sign = hashlib.sha1(tmp_str).hexdigest() # 将自己计算的签名值与请求的签名参数进行对比，如果相同，则证明请求来自微信服务器 if sign != signature: # 表示请求不是微信发的 abort(403) else: # 表示是微信发送的请求 if request.method == \"GET\": # 表示是第一次接入微信服务器的验证 echostr = request.args.get(\"echostr\") if not echostr: abort(404) return echostr elif request.method == \"POST\": # 表示微信服务器转发消息过来 xml_str = request.data if not xml_str: abort(400) # 对xml字符串进行解析 xml_dict = xmltodict.parse(xml_str) xml_dict = xml_dict.get(\"xml\") # 提取消息类型 msg_type = xml_dict.get(\"MsgType\") if msg_type == \"text\": # 表示发送的是文本消息 # 构造返回值，经由微信服务器回复给用户的消息内容 resp_dict = &#123; \"xml\": &#123; \"ToUserName\": xml_dict.get(\"FromUserName\"), \"FromUserName\": xml_dict.get(\"ToUserName\"), \"CreateTime\": int(time.time()), \"MsgType\": \"text\", \"Content\": \"taogang say:\" + xml_dict.get(\"Content\") &#125; &#125; else: resp_dict = &#123; \"xml\": &#123; \"ToUserName\": xml_dict.get(\"FromUserName\"), \"FromUserName\": xml_dict.get(\"ToUserName\"), \"CreateTime\": int(time.time()), \"MsgType\": \"text\", \"Content\": \"Dear I Love you so much\" &#125; &#125; # 将字典转换为xml字符串 resp_xml_str = xmltodict.unparse(resp_dict) # 返回消息数据给微信服务器 return resp_xml_str if __name__ == '__main__': app.run(port=8007, debug=True) ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85330265","categories":[{"name":"WeChat开发","slug":"WeChat开发","permalink":"https://hellotaogang.github.io/categories/WeChat开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://hellotaogang.github.io/tags/微信公众号/"},{"name":"微信开发","slug":"微信开发","permalink":"https://hellotaogang.github.io/tags/微信开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"微信公众号之接入微信公众号服务器开发（二）","slug":"微信公众号之接入微信公众号服务器开发（二）","date":"2019-10-31T09:54:08.258Z","updated":"2019-11-03T06:27:33.776Z","comments":true,"path":"2019/10/31/微信公众号之接入微信公众号服务器开发（二）/","link":"","permalink":"https://hellotaogang.github.io/2019/10/31/微信公众号之接入微信公众号服务器开发（二）/","excerpt":"","text":"一丶叙述开发说明 Python代码实现（以Flask框架为例） 将使用公众号消息会话 客户端—-＞微信服务器—-＞nginx服务器—-＞开发者服务器 在微信服务器与开发者服务器之间搭建了nginx服务器默认为80端口(也是微信支持的端口)，跟开发者服务器属于同一个主机 在nginx服务器上配置了多个端口，方便多人进行测试，转发规则：location/wechat8007 在微信公众号测试平台接口配置url为host/wechat8007时，当微信服务器发送消息给host/wechat8007时，host为nginx服务器时，就会按照/wechat8007转发规则匹配，一旦匹配成功后，由nginx服务器转发给开发者服务器上127.0.0.1:8007进程的用户，这样可以实现多个账号共享一个80端口，并可以收到微信服务器对应用户的消息 注：在写的flask程序中视图网址也必须是/wechat8007，因为nginx在向后台转发的时候，它只是按照/wechat8007规则知道转发给谁，它会把微信用户的请求原封不动的往后去发，因为微信服务器在向我们发送请求路径就是/wechat:8007,意味着nginx再转发给我们的时候，在我们写的flask程序收到的请求里面，你会发现对应的请求路径也是/wechat8007，所以我们flask程序中的route路径也必须是/wechat8007 如果是在公司做开发的话，不涉及到多个账户使用一个80端口，所以直接把程序在开发者服务器上以80端口运行，然后在微信公众测试平台配置url为配置程序地址即可 博主之所以这样做，那是因为我还没有购买服务器（●︿●） 接入微信公众平台接入微信公众平台开发，开发者需要按照如下步骤完成： 填写服务器配置 验证服务器地址的有效性 依据接口文档实现业务逻辑 填写服务器配置登录微信公众平台官网后，在公众平台后台管理页面 - 开发者中心页，点击“修改配置”按钮，填写服务器地址（URL）、Token和EncodingAESKey，其中URL是开发者用来接收微信消息和事件的接口URL。Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥。 同时，开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。模式的选择与服务器配置在提交后都会立即生效，请开发者谨慎填写及选择。加解密方式的默认状态为明文模式，选择兼容模式和安全模式需要提前配置好相关加解密代码，详情请参考消息体签名及加解密部分的文档。 1.进入微信公众平台后，找到开发栏，进入基本配置 2.利用测试平台测试平台登录地址：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login在手机微信上进行扫码登录即可 二丶验证服务器地址的有效性开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带四个参数： 开发者通过检验signature对请求进行校验。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。 校验流程： 将token、timestamp、nonce三个参数进行字典序排序 将三个参数字符串拼接成一个字符串进行sha1加密 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 1.根据上面微信公众平台提供的开发文档进行代码编写代码实现如下 12345678910111213141516171819202122232425262728293031323334353637383940# coding:utf-8from flask import Flask, request, abortimport hashlib # 常量# 微信的token令牌WECHAT_TOKEN = \"cdtaogang\" app = Flask(__name__) @app.route(\"/wechat8007\")def wechat(): \"\"\"对接微信公众号服务器\"\"\" # 接收微信服务器发送的参数 signature = request.args.get(\"signature\") timestamp = request.args.get(\"timestamp\") nonce = request.args.get(\"nonce\") echostr = request.args.get(\"echostr\") # 校验参数 if not all([signature, timestamp, nonce, echostr]): abort(400) # 按照微信的流程进行计算签名 li = [WECHAT_TOKEN, timestamp, nonce] # 排序 li.sort() # 拼接字符串 tmp_str = ''.join(li) # 进行sha1加密, 得到正确的签名值 sign = hashlib.sha1(tmp_str).hexdigest() # 将自己计算的签名值与请求的签名参数进行对比，如果相同，则证明请求来自微信服务器 if sign != signature: # 表示请求不是微信发的 abort(403) else: return echostr if __name__ == '__main__': app.run(port=8007, debug=True) 2.测试连接开发者服务器 step1 使用ssh命令测试连接服务器 step2 使用scp命令将程序文件推送到服务器 step3 在开发者服务器上运行wechat程序 step4 回到微信公众测试平台配置接口 注意：当没有在服务器运行wechat程序时，进行提交会显示失败 此时，回头看服务器程序运行日志，微信给我发了一个以get方式请求过来的数据 大功告成！说明该服务器具有有效性…. ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85321424","categories":[{"name":"WeChat开发","slug":"WeChat开发","permalink":"https://hellotaogang.github.io/categories/WeChat开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://hellotaogang.github.io/tags/微信公众号/"},{"name":"微信开发","slug":"微信开发","permalink":"https://hellotaogang.github.io/tags/微信开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"微信公众号之接入微信公众号服务器开发（一）","slug":"微信公众号之接入微信公众号服务器开发（一）","date":"2019-10-31T02:38:05.755Z","updated":"2019-11-03T06:27:40.820Z","comments":true,"path":"2019/10/31/微信公众号之接入微信公众号服务器开发（一）/","link":"","permalink":"https://hellotaogang.github.io/2019/10/31/微信公众号之接入微信公众号服务器开发（一）/","excerpt":"","text":"一丶概述公众号与公众平台1.微信账号类型 个人号 公众号&ensp;– 订阅号&ensp;– 服务号 企业号 2.公众号微信公众号主要面向名人、政府、媒体、企业等机构推出的合作推广业务。在这里可以通过微信渠道将品牌推广给上亿的微信用户，减少宣传成本，提高品牌知名度，打造更具影响力的品牌形象。 3.公众平台微信公众平台是运营者通过公众号为微信用户提供资讯和服务的平台，而公众平台开发接口则是提供服务的基础，开发者在公众平台网站中创建公众号、获取接口权限后，可以通过阅读公众平台开发接口文档来帮助开发。 微信公众平台可以用来注册、管理公众号和企业号。 登录网址：https://mp.weixin.qq.com/ 进入上面网址，可进行登录及注册注册流程： step1 基本信息 step2 选择类型 step3 信息登记 step4 公众号信息 step5 完成注册后，进行登录，首先需使用手机进行扫码 在手机端显示此界面，确认无误后，确定即可 通过身份验证后，即可在网页端对创建的公众号进行简单配置，如下图 一些简单的功能添加以及配置(需要啥配置啥即可，简单操作这里不做详细说明了) 4.公众号与个人号的区别微信公众号和个人号是完全不同的。 微信对个人号的定位是普通用户之间的交流和通讯，微信并不鼓励和支持使用个人号进行营销推广(微信曾经大规模封杀好友过多的营销个人号）。 而公众号则完全是为品牌推广、信息推送等服务而定制的。使用公众号，可以向关注者（即粉丝)群发图文消息，粉丝在对话界面看到消息后，可以点击跳转到一个图文页面。公众号还提供关键词自动回复等基础功能，以此可以随时、自动的和粉丝进行互动。 除了这些基础功能之外，更大的区别是，微信针对公众号开放了很多程序接口。在这些接口的基础上，可以向粉丝提供更多的服务。此外，认证的服务号还可以申请微信支付。粉丝可以使用微信支付向进行付款（订购服务或购买商品）。所有这些，都是个人号不具备的。 微信公众号的注册几乎是没有门槛的。不过针对不同类型的公众号，微信提供的功能不同，资质要求也不一样。 二丶微信开发原理公众号主要通过 公众号消息会话 公众号内网页 来为用户提供服务的。 公众号消息会话 公众号是以微信用户的一个联系人形式存在的，消息会话是公众号与用户交互的基础。 公众号内网页 许多复杂的业务场景，需要通过网页形式来提供服务。 使用微信服务器提供的功能无法满足我们的需求 设想两个场景： 1.公众号的消息自动回复想做的智能一些，类似于iphone的Siri，例如粉丝发送“今天的北京天气”到公众号，回复粉丝信息时要按照特定时间特定城市给予反馈; 2.公众号内嵌的网页需要获取浏览用户的微信头像、昵称、当前定位等信息 模型分类1.无扩展应用模型1.公众号消息会话2.公众号内网页 2.有扩展应用模型1.公众号消息会话2.公众号内网页 公众号接口1.公众号消息会话目前公众号内主要有这样几类消息服务的类型，分别用于不同的场景。 群发消息 公众号可以以一定频次（订阅号为每天1次，服务号为每月4次），向用户群发消息，包括文字消息、图文消息、图片、视频、语音等。 被动回复消息 在用户给公众号发消息后，微信服务器会将消息发到开发者预先在开发者中心设置的服务器地址（开发者需要进行消息真实性验证），公众号可以在5秒内做出回复，可以回复一个消息，也可以回复命令告诉微信服务器这条消息暂不回复。被动回复消息可以设置加密（在公众平台官网的开发者中心处设置，设置后，按照消息加解密文档来进行处理。其他3种消息的调用因为是API调用而不是对请求的返回，所以不需要加解密）。 客服消息 在用户给公众号发消息后的48小时内，公众号可以给用户发送不限数量的消息，主要用于客服场景。用户的行为会触发事件推送，某些事件推送是支持公众号据此发送客服消息的，详见微信推送消息与事件说明文档。 模板消息 在需要对用户发送服务通知（如刷卡提醒、服务预约成功通知等）时，公众号可以用特定内容模板，主动向用户发送消息。 2.公众号内网页对于公众号内网页，提供以下场景接口： 网页授权获取用户基本信息 通过该接口，可以获取用户的基本信息 微信JS-SDK 是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。 3.微信开发者文档文档链接地址：https://mp.weixin.qq.com/wiki/home/index.html ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/85319116","categories":[{"name":"WeChat开发","slug":"WeChat开发","permalink":"https://hellotaogang.github.io/categories/WeChat开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hellotaogang.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://hellotaogang.github.io/tags/Flask/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://hellotaogang.github.io/tags/微信公众号/"},{"name":"微信开发","slug":"微信开发","permalink":"https://hellotaogang.github.io/tags/微信开发/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"软件测试用例设计总结","slug":"测试笔记","date":"2019-10-18T08:44:03.237Z","updated":"2019-10-31T13:31:51.920Z","comments":true,"path":"2019/10/18/测试笔记/","link":"","permalink":"https://hellotaogang.github.io/2019/10/18/测试笔记/","excerpt":"","text":"1.测试流程需求分析—测试需求—测试计划–测试方案—测试用例—执行测试—测试报告 2.测试用例的特性 有效性：能使用，不同人使用结果一致（测试用例的能够被使用，且被不同人员使用测试结果一致） 可复用性：良好的测试用例具有重复使用的功能 易组织性：好的测试用例会分门别类地提供给测试人员参考和使用 可评估性：从测试管理的角度，测试用例的通过率和软件缺陷的数目是软件产品质量好坏的测试标准（测试计划） 可管理性：测试用例可以作为检验测试人员进度、工作量以及跟踪/管理测试人员工作效率的因素（对测试人员进行工作量和绩效考核） 3.测试用例的八大要素①测试编号②测试模块③测试标题④测试级别⑤测试环境⑥测试输入⑦测试步骤⑧预期结果 测试编号：每个测试用例都有唯一的标识号，用以区别其他测试用例例：系统测试用例的编号这样定义规则： PROJECT1-ST-001 ，命名规则是项目名称＋测试阶段类型（系统测试阶段）＋编号 测试模块：指明并简单描述本测试用例是用来测试哪些项目、子项目或软件特性的例：购物模块 测试标题：对测试用例的描述，测试用例标题应该清楚表达测试用例的用途例：“ 测试用户登录时输入错误密码时，软件的响应情况 ” 测试级别：定义测试用例的优先级别，可以粗略地分为 “ 高 ” 和 “ 低 ” 两个级别例： 核心功能 —高 界面风格 —低 测试环境：描述执行测试用例所需要的具体测试环境，包括硬件环境和软件环境例： 硬件 ——计算机的具体配置，见测试计划；软件——操作系统 linux 数据库 mysql 中间件 weblogic 测试输入：用来执行测试用例的输入要求。这些输入可能是数据、文件或具体操作例： 数据 ： 12 文件 ： D:\\baidu\\文件couture 动作 ： 单击鼠标，在键盘做按键处理 测试步骤：执行本测试用例所需的每一步操作例： 求和运算 输入加数12 输入被加数 24 点击“加法按钮” 预期结果：描述被测项目或被测特性所希望或要求达到的输出或指标例： 加法器 12+24 预期结果： 36 4.测试用例操作步骤1.设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这个过程，直至所有的有效等价类均被测试用例所覆盖 2.设计一个新的测试用例，使其仅覆盖一个无效等价类，重复这个过程，直至所有的无效等价类均被测试用例所覆盖 3.设计数据要注意 ①无效等价类在一个用例中只能出现一次 ②有效等价类在一个用例中可以出现多次4.等价类划分技巧 ①测试用例分析最好用xmind ②按等价类给出数据最好用电子表格 ③当产生意见分歧，回看需求规格说明书 5.软件测试用例方法1.输出域 覆盖所有的输出，不管输入2.输入域 覆盖所有的输入，不管输出3.异常分析法： 断电，断网的异常情况（重点关注）4.错误猜测法： 有经验的人对系统做出判断，找到肯能出现错误的地方5.探索性测试： 根据自己的测试经验，尝试性测试系统功能6.因果图7.场景法 流程有序8.状态迁移 状态无序9.正交试验 多条件组合，不予许出现负值10.判定表 多条件组合，可以出现负值11.边界值12.等价类 6.软件生存周期及其模型软件生存周期（Software life cycle）又称为软件生命期，生存期。是指从形成开发软件概念起，所开发的软件使用以后，知道失去使用价值消亡为止的整个过程。一般来说，整个生存周期包括计划（定义）、开发、运行（维护）三个时期，每个时期又划分为若干个阶段。每个阶段有明确的任务。 周期模型（典型的几种）: 瀑布模型：快速原型模型：快速原型模型允许在需求分析阶段对软件的需求进行初步而非完全的分析和定义，快速设计开发出软件系统的原型，该原型向用户展示待开发软件的全部或部分功能和性能；用户对该原型进行测试评定，给出具体改进意见以丰富细化软件需求；开发人员据此对软件进行修改完善，直至用户满意认可之后，进行软件的完整实现及测试、维护。 迭代模型：迭代包括产生产品发布（稳定、可执行的产品版本）的全部开发活动和要使用该发布必需的所有其他外围元素。在某种程度上，开发迭代是一次 完整地经过所有工作流程的过程：需求分析、设计、实施和测试工作流程。实质上，它类似小型的瀑布式项目。RUP认为，所有的阶段都可以细分为迭代。每一次 的迭代都会产生一个可以发布的产品，这个产品是最终产品的一个子集。 生命周期阶段： 软件计划与可行性分析 需求分析 软件设计 编码 软件测试 运行与维护 7.什么是软件测试？软件测试的目的与原则在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。 软件测试的目的： 测试是程序的执行过程，目的在于发现错误 一个成功的测试用例在于发现至今未发现的错误 一个成功的测试是发现了至今未发现的错误的测试 确保产品完成了它所承诺或公布的功能，并且用户可以访问到的功能都有明确的书面说明。 确保产品满足性能和效率的要求 确保产品是健壮的和适应用户环境的 软件测试的原则： 测试用例中一个必须部分是对预期输出或接过进行定义 程序员应避免测试自己编写的程序 编写软件的组织不应当测试自己编写的软件 应当彻底检查每个测试的执行结果 测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和未预料到的输入情况 检擦程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的” 应避免测试用例用后即弃，除非软件本身就是个一次性的软件 计划测试工作时不应默许假定不会发现错误 程序某部分存在更多错误的可能性，与该部分已经发现错误的数量成正比 软件测试是一项极富创造性，极具智力的挑战性的工作。 8.软件的安全性应从哪几个方面去测试软件安全性测试包括程序、数据库安全性测试。根据系统安全指标不同测试策略也不同。用户认证安全的测试要考虑问题： 明确区分系统中不同用户权限 、系统中会不会出现用户冲突 、系统会不会因用户的权限的改变造成混乱 、用户登陆密码是否是可见、可复制 、是否可以通过绝对途径登陆系统（拷贝用户登陆后的链接直接进入系统）、用户退出系统后是否删除了所有鉴权标记，是否可以使用后退键而不通过输入口令进入 系统 、系统网络安全的测试要考虑问题 、测试采取的防护措施是否正确装配好，有关系统的补丁是否打上 、模拟非授权攻击，看防护系统是否坚固 、采用成熟的网络漏洞检查工具检查系统相关漏洞（即用最专业的黑客攻击工具攻击试一下，现在最常用的是 NBSI 系列和 IPhacker IP ） 、采用各种木马检查工具检查系统木马情况 、采用各种防外挂工具检查系统各组程序的外挂漏洞. 数据库安全考虑问题： 系统数据是否机密（比如对银行系统，这一点就特别重要，一般的网站就没有太高要求）、系统数据的完整性（我刚刚结束的企业实名核查服务系统中就曾存在数据 的不完整，对于这个系统的功能实现有了障碍） 、系统数据可管理性 、系统数据的独立性 、系统数据可备份和恢复能力（数据备份是否完整，可否恢复，恢复是否可以完整） 9.什么是测试用例 什么是测试脚本 两者的关系是什么？为实施测试而向被测试系统提供的输入数据、操作或各种环境设置以及期望结果的一个特定的集合。 测试脚本是为了进行自动化测试而编写的脚本。 测试脚本的编写必须对应相应的测试用例。 10.什么是静态测试、动态测试、黑盒测试、白盒测试、α测试 β测试？静态测试是不运行程序本身而寻找程序代码中可能存在的错误或评估程序代码的过程。 动态测试是实际运行被测程序，输入相应的测试实例，检查运行结果与预期结果的差异，判定执行结果是否符合要求，从而检验程序的正确性、可靠性和有效性，并分析系统运行效率和健壮性等性能。 黑盒测试一般用来确认软件功能的正确性和可操作性,目的是检测软件的各个功能是否能得以实现,把被测试的程序当作一个黑盒,不考虑其内部结构,在知道该程序的输入和输出之间的关系或程序功能的情况下,依靠软件规格说明书来确定测试用例和推断测试结果的正确性。 白盒测试根据软件内部的逻辑结构分析来进行测试,是基于代码的测试，测试人员通过阅读程序代码或者通过使用开发工具中的单步调试来判断软件的质量，一般黑盒测试由项目经理在程序员开发中来实现。 α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。 β测试是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。 11.软件产品质量特性是什么?功能性：适应性、准确性、互操作性、依从性、安全性。 可靠性：成熟性、容错性、易恢复性。 可使用性：易理解性、易学习性、易操作性。 效率：时间特性、资源特性。 可维护性：易分析性、易变更性、稳定性、易测试性。 可移植性：适应性、易安装性、遵循性、易替换性 12.软件测试分为几个阶段 各阶段的测试策略和要求是什么?和开发过程相对应，测试过程会依次经历单元测试、集成测试、系统测试、验收测试 四个主要阶段：单元测试：单元测试是针对软件设计的最小单位––程序模块甚至代码段进行正确性检验的测试工作，通常由开发人员进行。 集成测试：集成测试是将模块按照设计要求组装起来进行测试，主要目的是发现与接口有关的问题。由于在产品提交到测试部门前，产品开发小组都要进行联合调试，因此在大部分企业中集成测试是由开发人员来完成的。 系统测试：系统测试是在集成测试通过后进行的，目的是充分运行系统，验证各子系统是否都能正常工作并完成设计的要求。它主要由测试部门进行，是测试部门最大最重要的一个测试，对产品的质量有重大的影响。 验收测试：验收测试以需求阶段的《需求规格说明书》为验收标准，测试时要求模拟实际用户的运行环境。对于实际项目可以和客户共同进行，对于产品来说就是最后一次的系统测试。测试内容为对功能模块的全面测试，尤其要进行文档测试。 单元测试测试策略：自顶向下的单元测试策略：比孤立单元测试的成本高很多，不是单元测试的一个好的选择。 自底向上的单元测试策略：比较合理的单元测试策略，但测试周期较长。 孤立的单元测试策略：最好的单元测试策略。 集成测试的测试策略：大爆炸集成：适应于一个维护型项目或被测试系统较小 自顶向下集成：适应于产品控制结构比较清晰和稳定；高层接口变化较小；底层接口未定义或经常可能被修改；产口控制组件具有较大的技术风险，需要尽早被验证；希望尽早能看到产品的系统功能行为。 自底向上集成：适应于底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。 基于进度的集成 优点：具有较高的并行度；能够有效缩短项目的开发进度。 缺点：桩和驱动工作量较大；有些接口测试不充分；有些测试重复和浪费。 系统测试的测试策略：数据和数据库完整性测试；功能测试；用户界面测试；性能评测；负载测试；强度测试；容量测试；安全性和访问控制测试；故障转移和恢复测试；配置测试；安装测试；加密测试；可用性测试；版本验证测试；文档测试 13.软件测试各个阶段通常完成什么工作？单元测试阶段：各独立单元模块在与系统地其他部分相隔离的情况下进行测试，单元测试针对每一个程序模块进行正确性校验，检查各个程序模块是否正确地实现了规定的功能。生成单元测试报告，提交缺陷报告。 集成测试阶段：集成测试是在单元测试的基础上，测试在将所有的软件单元按照概要设计规格说明的要求组装成模块、子系统或系统的过程中各部分工作是否达到或实现相应技术指标及要求的活动。该阶段生成集成测试报告，提交缺陷报告。 系统测试阶段：将通过确认测试的软件，作为整个给予计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行环境下，对计算机系统进行全面的功能覆盖。该阶段需要提交测试总结和缺陷报告。 14.测试人员在软件开发过程中的任务是什么？1、尽可能早的找出系统中的Bug； 2、避免软件开发过程中缺陷的出现； 3、衡量软件的品质，保证系统的质量； 4、关注用户的需求，并保证系统符合用户需求。 总的目标是：确保软件的质量。 15.一条软件缺陷（或者叫Bug）记录都包含了哪些内容？一条Bug记录最基本应包含： bug编号； bug严重级别，优先级； bug产生的模块； 首先要有bug摘要，阐述bug大体的内容； bug对应的版本； bug详细现象描述，包括一些截图、录像….等等； bug出现时的测试环境，产生的条件即对应操作步骤； 16.黑盒测试和白盒测试的优缺点黑盒测试的优点有：比较简单，不需要了解程序内部的代码及实现；与软件的内部实现无关； 从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题；基于软件开发文档，所以也能知道软件实现了文档中的哪些功能；在做软件自动化测试时较为方便。 黑盒测试的缺点有：不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%；自动化测试的复用性较低。 白盒测试的优点有：帮助软件测试人员增大代码的覆盖率，提高代码的质量，发现代码中隐藏的问题。 白盒测试的缺点有：程序运行会有很多不同的路径，不可能测试所有的运行路径；测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；系统庞大时，测试开销会非常大。 17.如何测试一个纸杯？功能度：用水杯装水看漏不漏；水能不能被喝到 安全性：杯子有没有毒或细菌 可靠性：杯子从不同高度落下的损坏程度 可移植性：杯子在不同的地方、温度等环境下是否都可以正常使用 兼容性：杯子是否能够容纳果汁、白水、酒精、汽油等 易用性：杯子是否烫手、是否有防滑措施、是否方便饮用 用户文档：使用手册是否对杯子的用法、限制、使用条件等有详细描述 疲劳测试：将杯子盛上水（案例一）放24小时检查泄漏时间和情况；盛上汽油（案例二）放24小时检查泄漏时间和情况等 压力测试：用根针并在针上面不断加重量，看压强多大时会穿透 18.详细的描述一个测试活动完整的过程1.项目经理通过和客户的交流，完成需求文档，由开发人员和测试人员共同完成需求文档的评审，评审的内容包括：需求描述不清楚的地方和可能有明显冲突或者无法实现的功能的地方。项目经理通过综合开发人员，测试人员以及客户的意见，完成项目计划。然后SQA(软件质量保证)进入项目，开始进行统计和跟踪。 2.开发人员根据需求文档完成需求分析文档，测试人员进行评审，评审的主要内容包括是否有遗漏或双方理解不同的地方。测试人员完成测试计划文档，测试计划包括的内容上面有描述。 3.测试人员根据修改好的需求分析文档开始写测试用例，同时开发人员完成概要设计文档，详细设计文档。此两份文档成为测试人员撰写测试用例的补充材料。 4.测试用例完成后，测试和开发需要进行评审。 5.测试人员搭建环境 6.开发人员提交第一个版本，可能存在未完成功能，需要说明。测试人员进行测试，发现BUG后提交给BugZilla。 7.开发提交第二个版本，包括Bug Fix以及增加了部分功能，测试人员进行测试。 8.重复上面的工作，一般是3-4个版本后BUG数量减少，达到出货的要求。 9.如果有客户反馈的问题，需要测试人员协助重现并重新测试。 ————————————————版权声明：本文为CSDN博主「cdtaogang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41782425/article/details/96853248","categories":[{"name":"总结","slug":"总结","permalink":"https://hellotaogang.github.io/categories/总结/"}],"tags":[{"name":"测试流程","slug":"测试流程","permalink":"https://hellotaogang.github.io/tags/测试流程/"},{"name":"用例特性","slug":"用例特性","permalink":"https://hellotaogang.github.io/tags/用例特性/"},{"name":"用例要素","slug":"用例要素","permalink":"https://hellotaogang.github.io/tags/用例要素/"},{"name":"用例步骤","slug":"用例步骤","permalink":"https://hellotaogang.github.io/tags/用例步骤/"},{"name":"用例方法","slug":"用例方法","permalink":"https://hellotaogang.github.io/tags/用例方法/"}],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}},{"title":"文章加密测试","slug":"第一篇博客","date":"2019-10-09T13:41:11.000Z","updated":"2019-10-31T13:08:03.330Z","comments":true,"path":"2019/10/09/第一篇博客/","link":"","permalink":"https://hellotaogang.github.io/2019/10/09/第一篇博客/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('别搞了，你破解不了的'); const txt = document.getElementById('enc_content').innerHTML; // alert(txt,\"1\") // alert(pwd,\"2\") // alert(onError,\"3\") let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); if(plaintext == \"\"){ document.getElementById(\"enc_pwd_input\").value=\"\"; document.getElementById(\"enc_error\").innerHTML = \"密码错误!\"; return } // alert(plaintext) } catch(err) { if(onError) { // alert(onError,\"4\") // alert(err,\"5\") onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1836qAERquDawMq7zjvpULbA1JzE+1mLJo6lNhyFoPU0smI5nzHI+wgomsaz5HhFL59PkDKiEdRwO/M07WQn6BVKWQK+pZnHJhF7muod+bdKU1zQ/RPN02WX5U6e4T5ykHoVQQdPXvLByZzzbMKmDwwOzZgIWG14/emHXyywbtntK2pvCba4oQF var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"密码错误!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[],"tags":[],"author":{"name":"cdtaogang","avatar":"https://cdn.jsdelivr.net/gh/Hellotaogang/cdn@4.4.3/images/avatar_4.png","url":"https://hellotaogang.github.io/"}}]}